"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[53],{8167:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>w,contentTitle:()=>g,default:()=>T,frontMatter:()=>k,metadata:()=>v,toc:()=>y});var a=o(7462),i=(o(7294),o(3905)),t=(o(8209),o(4866)),r=o(5162),l=o(4903),d=o(1912),s=o(1166);const p='package rendering\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.text\n\n//sampleStart\nclass MyView: View() {\n    override fun render(canvas: Canvas) {\n        canvas.flipHorizontally(around = width / 2) {\n            text("hello", color = Black)\n        }\n    }\n}\n//sampleEnd',c="import io.nacular.doodle.core.View\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color.Companion.Blue\nimport io.nacular.doodle.drawing.paint\n\n//sampleStart\nclass RectView: View() {\n    override fun render(canvas: Canvas) {\n        canvas.rect(bounds.atOrigin, Blue.paint)\n    }\n}\n//sampleEnd",m='package timerdsl\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.Color.Companion.Green\nimport io.nacular.doodle.drawing.Color.Companion.Red\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.drawing.rect\nimport io.nacular.doodle.drawing.text\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.scheduler.Scheduler\nimport io.nacular.doodle.time.Clock\nimport io.nacular.measured.units.Time.Companion.milliseconds\nimport io.nacular.measured.units.times\n\n//sampleStart\nclass Timer(display: Display, clock: Clock, scheduler: Scheduler): Application {\n    init {\n        display += view {\n            size = Size(200)\n\n            scheduler.every(1 * milliseconds) {\n                rerender()\n            }\n\n            render = {\n                rect(bounds.atOrigin, Stroke(Red))\n                text("${clock.epoch}", color = Black)\n                rect(bounds.at(y = 20.0), color = Green)\n            }\n        }\n    }\n\n    override fun shutdown() {}\n}\n//sampleEnd',u='package timerrenderprop\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.renderProperty\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.Color.Companion.Green\nimport io.nacular.doodle.drawing.Color.Companion.Red\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.drawing.rect\nimport io.nacular.doodle.drawing.text\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.scheduler.Scheduler\nimport io.nacular.doodle.time.Clock\nimport io.nacular.measured.units.Time.Companion.milliseconds\nimport io.nacular.measured.units.times\n\n//sampleStart\nclass Timer(display: Display, clock: Clock, scheduler: Scheduler): Application {\n    init {\n        display += object: View() {\n            var time by renderProperty(clock.epoch)\n\n            init {\n                size = Size(200)\n\n                scheduler.every(1 * milliseconds) {\n                    time = clock.epoch\n                }\n            }\n\n            override fun render(canvas: Canvas) {\n                canvas.rect(bounds.atOrigin, Stroke(Red))\n                canvas.text("$time", color = Black)\n                canvas.rect(bounds.at(y = 20.0), color = Green)\n            }\n        }\n    }\n\n    override fun shutdown() {}\n}\n//sampleEnd',h="package rendering\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.renderProperty\nimport io.nacular.doodle.drawing.AffineTransform.Companion.Identity\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color.Companion.Red\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.drawing.stripedPaint\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.measured.units.Angle.Companion.degrees\nimport io.nacular.measured.units.times\n\n// Doodle's implementation of striped-paint looks something like this\n/*\nfun stripedPaint(\n    stripeWidth : Double,\n    evenRowColor: Color? = null,\n    oddRowColor : Color? = null,\n    transform   : AffineTransform2D = Identity\n): PatternPaint = PatternPaint(Size(if (evenRowColor.visible || oddRowColor.visible) stripeWidth else 0.0, 2 * stripeWidth), transform) {\n    evenRowColor?.let { rect(Rectangle(                  stripeWidth, stripeWidth), ColorPaint(it)) }\n    oddRowColor?.let  { rect(Rectangle(0.0, stripeWidth, stripeWidth, stripeWidth), ColorPaint(it)) }\n}\n*/\n\n//sampleStart\nclass SomeView: View() {\n    private val stripeWidth = 20.0\n    private var paintAngle by renderProperty(0 * degrees)\n\n    override fun render(canvas: Canvas) {\n        val paintCenter = Point(canvas.size.width / 2, canvas.size.height / 2)\n\n        canvas.rect(bounds.atOrigin, stripedPaint(\n            stripeWidth  = stripeWidth,\n            evenRowColor = Red,\n            oddRowColor  = White,\n            transform    = Identity.rotate(around = paintCenter, by = paintAngle)\n        ))\n    }\n}\n//sampleEnd",k={title:"Overview"},g="Rendering",v={unversionedId:"rendering/overview",id:"rendering/overview",title:"Overview",description:"Rendering is managed entirely by Views. Each  draws its content to a Canvas via the  method. These calls update the screen so the View's contents are displayed. Doodle calls render whenever a View needs a visual update. This is the simplest way to define the way a custom View looks.",source:"@site/docs/rendering/overview.mdx",sourceDirName:"rendering",slug:"/rendering/overview",permalink:"/doodle/docs/rendering/overview",draft:!1,tags:[],version:"current",frontMatter:{title:"Overview"},sidebar:"tutorialSidebar",previous:{title:"Where's My View?",permalink:"/doodle/docs/display/gotchas"},next:{title:"Text",permalink:"/doodle/docs/rendering/text"}},w={},y=[{value:"Efficient Rendering",id:"efficient-rendering",level:2},{value:"The Canvas",id:"the-canvas",level:2},{value:"Transforms",id:"transforms",level:3},{value:"Pattern Paints",id:"pattern-paints",level:3}],C={toc:y},f="wrapper";function T(e){let{components:n,...o}=e;return(0,i.kt)(f,(0,a.Z)({},C,o,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"rendering"},"Rendering"),(0,i.kt)("p",null,"Rendering is managed entirely by ",(0,i.kt)("inlineCode",{parentName:"p"},"Views"),". Each ",(0,i.kt)(s.G7x,null)," draws its content to a ",(0,i.kt)("a",{parentName:"p",href:"#the-canvas"},"Canvas")," via the ",(0,i.kt)(s.oTL,null)," method. These calls update the screen so the View's contents are displayed. Doodle calls ",(0,i.kt)("inlineCode",{parentName:"p"},"render")," whenever a ",(0,i.kt)("inlineCode",{parentName:"p"},"View")," needs a visual update. This is the simplest way to define the way a custom ",(0,i.kt)("inlineCode",{parentName:"p"},"View")," looks."),(0,i.kt)(d.O,{mdxType:"KPlayground"},c),(0,i.kt)("p",null,"This ",(0,i.kt)("inlineCode",{parentName:"p"},"RectView")," draws a rectangle (filled with ",(0,i.kt)(s.Yy$,null)," ",(0,i.kt)(s.l4u,null)," covering its bounds) that covers its bounds."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)(s.oTL,null)," is automatically called on ",(0,i.kt)(s.du0,null)," changes and ",(0,i.kt)(s.D$9,null)," changing to `true`"),(0,i.kt)("h2",{id:"efficient-rendering"},"Efficient Rendering"),(0,i.kt)("p",null,"Doodle optimizes rendering to avoid re-applying operations when rendering the same content repeatedly. For example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Timer")," app below renders the epoch time every millisecond. However, Doodle only updates the changing regions (i.e. the DOM for Web apps). The text in this case."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Doodle uses ",(0,i.kt)("a",{parentName:"p",href:"https://nacular.github.io/measured/"},"Measured")," for time, angles etc.")),(0,i.kt)(t.Z,{mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"Demo",mdxType:"TabItem"},(0,i.kt)(l.l,{functionName:"timer",height:"200",mdxType:"DoodleApp"})),(0,i.kt)(r.Z,{value:"View DSL",mdxType:"TabItem"},(0,i.kt)(d.O,{mdxType:"KPlayground"},m)),(0,i.kt)(r.Z,{value:"Render Property",mdxType:"TabItem"},(0,i.kt)(d.O,{mdxType:"KPlayground"},u))),(0,i.kt)("h2",{id:"the-canvas"},"The Canvas"),(0,i.kt)("p",null,"All drawing is done via the ",(0,i.kt)(s.Xz7,null)," API, which offers a rich set of operations for geometric shapes, paths, images, and text. It also supports different ",(0,i.kt)(s.wGU,null)," types (i.e. ",(0,i.kt)(s.l4u,null),", ",(0,i.kt)(s.AQR,null),", and ",(0,i.kt)("a",{parentName:"p",href:"/doodle/docs/rendering/overview#pattern-paints"},"PatternPaint"),") for filling regions."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Canvas")," provided to a ",(0,i.kt)("inlineCode",{parentName:"p"},"View"),"'s ",(0,i.kt)(s.oTL,null)," method has a coordinate system that anchors ",(0,i.kt)("inlineCode",{parentName:"p"},"0,0")," on the ",(0,i.kt)("inlineCode",{parentName:"p"},"Canvas")," to the ",(0,i.kt)("inlineCode",{parentName:"p"},"View"),"'s origin. The Canvas itself extends in all directions beyond the bounds of the View; but the contents drawn to it will be clipped to the view's bounds by default."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Sub-classes can disable clipping by setting ",(0,i.kt)(s.LeJ,null),"\nto ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),".")),(0,i.kt)("h3",{id:"transforms"},"Transforms"),(0,i.kt)("p",null,"The canvas can also be transformed using any ",(0,i.kt)(s.oi,null),". Transforms can also be nested to create combined effects to. Here, the view flips the Canvas horizontally around its mid-point and draws some text."),(0,i.kt)(d.O,{mdxType:"KPlayground"},p),(0,i.kt)("h3",{id:"pattern-paints"},"Pattern Paints"),(0,i.kt)("p",null,"Sometimes you need to fill a region with a repeating pattern, like an image or some geometric shapes. Doodle has the ",(0,i.kt)(s.Eb3,null),' to make this easy. This paint has a "render" body that provides a powerful and familiar way of creating repeating patterns.'),(0,i.kt)("p",null,"You create this paint by specifying a ",(0,i.kt)("inlineCode",{parentName:"p"},"size")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"paint")," lambda, which has access to the full ",(0,i.kt)(s.Xz7,null)," APIs."),(0,i.kt)(t.Z,{mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"Demo",mdxType:"TabItem"},(0,i.kt)(l.l,{functionName:"patternPaint",height:"300",mdxType:"DoodleApp"})),(0,i.kt)(r.Z,{value:"Code",mdxType:"TabItem"},(0,i.kt)(d.O,{mdxType:"KPlayground"},h))),(0,i.kt)("p",null,"This app shows how a ",(0,i.kt)(s.Eb3,null)," can be transformed using ",(0,i.kt)(s.V29,null),", like rotated around its center for example."))}T.isMDXComponent=!0}}]);