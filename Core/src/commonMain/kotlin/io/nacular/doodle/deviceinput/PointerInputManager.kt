package io.nacular.doodle.deviceinputimport io.nacular.doodle.controls.panels.ScrollPanelimport io.nacular.doodle.core.Displayimport io.nacular.doodle.core.Internalimport io.nacular.doodle.core.Viewimport io.nacular.doodle.event.PointerEventimport io.nacular.doodle.event.withimport io.nacular.doodle.system.Cursorimport io.nacular.doodle.system.PointerInputServiceimport io.nacular.doodle.system.SystemPointerEventimport io.nacular.doodle.system.SystemPointerEvent.Typeimport io.nacular.doodle.system.SystemPointerEvent.Type.Clickimport io.nacular.doodle.system.SystemPointerEvent.Type.Downimport io.nacular.doodle.system.SystemPointerEvent.Type.Dragimport io.nacular.doodle.system.SystemPointerEvent.Type.Enterimport io.nacular.doodle.system.SystemPointerEvent.Type.Exitimport io.nacular.doodle.system.SystemPointerEvent.Type.Moveimport io.nacular.doodle.system.SystemPointerEvent.Type.Up@Internalpublic interface PointerInputManager {    public fun shutdown()}@Internal@Suppress("NestedLambdaShadowedImplicitParameter")public class PointerInputManagerImpl(private val display: Display, private val inputService: PointerInputService, private val viewFinder: ViewFinder): PointerInputManager, PointerInputService.Listener {    private var pointerDown       = false    private var latestSystemEvent = null as SystemPointerEvent?    private var clickedView       = null as View?    private var coveredView       = null as View?        set(new) {            if (new == field) {                return            }            field?.let { unregisterListeners(it) }            field = new            field?.let { registerListeners  (it) }        }    private var cursor = null as Cursor?        set(new) {            field = new            inputService.cursor = cursor ?: display.cursor        }    private var toolTipText = ""        set(new) {            field = new            inputService.toolTipText = field        }    private val displayCursorChanged = { _: Display, _: Cursor?, new: Cursor? -> cursor = new }    private val enabledChanged = { view: View, _: Boolean, enabled: Boolean ->        latestSystemEvent?.let {            coveredView = view(from = it)            when {                enabled -> view.handlePointerEvent_(createPointerEvent(it, view, Enter))                else    -> view.handlePointerEvent_(createPointerEvent(it, view, Exit ))            }        }        Unit    }    private val viewCursorChanged = { view: View, _: Cursor?, _: Cursor? ->        cursor = cursor(of = view)    }    init {        inputService += this        display.cursorChanged += displayCursorChanged        cursor = display.cursor    }    override fun shutdown() {        inputService -= this        display.cursorChanged -= displayCursorChanged    }    override fun changed(event: SystemPointerEvent) {        when (event.type) {            Up -> when(event.clickCount) {                1    -> pointerUp(event)                else -> doubleClick(event)            }            Move -> pointerMove(event)            Down -> pointerDown(event)            else -> {}        }    }    private fun pointerUp(event: SystemPointerEvent) {        latestSystemEvent = event        val view = view(from = event)        if (clickedView != null || pointerDown) {            clickedView?.let {                deliver(event, createPointerEvent(event, it))                if (view === it) {                    deliver(event, createPointerEvent(event, it, Click))                    // Fake exit event for touch devices                    if (event.fromTouch) {                        deliver(event, createPointerEvent(event, it, Exit))                    }                }            }            if (view !== clickedView) {                clickedView?.let {                    // Avoid case where pointer-move hasn't been seen (possible if drag-drop happened)                    if (coveredView == it) {                        coveredView = null                        deliver(event, createPointerEvent(event, it, Exit))                    }                }                if (view != null) {                    coveredView = view                    deliver(event, createPointerEvent(event, view, Enter))                    deliver(event, createPointerEvent(event, view, Up   ))                    // Fake exit event for touch devices                    if (event.fromTouch) {                        deliver(event, createPointerEvent(event, view, Exit))                    }                    cursor = cursor(of = view)                } else {                    cursor = display.cursor                }            } else {                cursor = cursor(of = view)            }            clickedView = null        } else if (view != null) {            deliver(event, createPointerEvent(event, view, Enter))            deliver(event, createPointerEvent(event, view       ))            cursor = cursor(of = view)        } else {            cursor = display.cursor        }        pointerDown = false    }    private fun pointerDown(event: SystemPointerEvent) {        latestSystemEvent = event        toolTipText = ""        view(from = event)?.let { view ->            if (view != coveredView) {                createPointerEvent(event, view, Enter).also {                    deliver(event, it)                    toolTipText = view.toolTipText(it)                }                coveredView = view                cursor      = cursor(of = coveredView)            }            deliver(event, createPointerEvent(event, view))            clickedView = view        }        pointerDown = true    }    private fun doubleClick(event: SystemPointerEvent) {        toolTipText = ""        view(from = event)?.let {            deliver(event, createPointerEvent(event, it, Up   ))            deliver(event, createPointerEvent(event, it, Click))        }    }    private fun pointerMove(event: SystemPointerEvent) {        latestSystemEvent = event        clickedView?.let {            deliver(event, createPointerEvent(event, it, Drag))            cursor = cursor(of = it)        }        val view = view(from = event)        if (view !== coveredView) {            coveredView?.let {                if (!pointerDown || it === clickedView) {                    deliver(event, createPointerEvent(event, it, Exit))                }            }            coveredView = view            if (view != null) {                if (!pointerDown || view === clickedView) {                    createPointerEvent(event, view, Enter).also {                        deliver(event, it)                        toolTipText = view.toolTipText(it)                    }                    cursor = cursor(of = coveredView)                }            } else if (clickedView == null) {                toolTipText = ""                cursor = null            }        } else if (!pointerDown) {            coveredView?.let {                deliver(event, createPointerEvent(event, it, Move))            }            if (coveredView == null) {                toolTipText = ""            }            cursor = cursor(of = coveredView)        }    }    private fun deliver(systemEvent: SystemPointerEvent, event: PointerEvent): Boolean {        val chain = mutableListOf(event.target)        var view = event.target.parent        while (view != null) {            if (view.enabled && view.visible) {                chain += view            }            view = view.parent        }        // Sinking        chain.asReversed().forEach {            val newEvent = event.with(source = it)            when (newEvent.type) {                Move, Drag -> it.filterPointerMotionEvent_(newEvent)                else       -> it.filterPointerEvent_      (newEvent)            }            if (newEvent.consumed) {                systemEvent.consume()                return true            }        }        // Floating        chain.forEach {            val newEvent = event.with(source = it)            when (newEvent.type) {                Move, Drag -> it.handlePointerMotionEvent_(newEvent)                else       -> it.handlePointerEvent_      (newEvent)            }            if (newEvent.consumed) {                systemEvent.consume()                return true            }        }        return false    }    private fun registerListeners(view: View) {        view.cursorChanged  += viewCursorChanged        view.enabledChanged += enabledChanged    }    private fun unregisterListeners(view: View) {        view.cursorChanged  -= viewCursorChanged        view.enabledChanged -= enabledChanged    }    private fun cursor(of: View?) = when (display.cursor) {        null -> of?.cursor        else -> display.cursor    }    private fun view(from: SystemPointerEvent): View? {        var view = viewFinder.find(from.location)        return view?.let {            if (from.nativeScrollPanel) {                while(view != null && view !is ScrollPanel) {                    view = view?.parent                }            }            view        }    }    private fun createPointerEvent(event: SystemPointerEvent, target: View, type: Type = event.type) = PointerEvent(            target,            target,            type,            target.fromAbsolute(event.location),            event.buttons,            event.clickCount,            event.modifiers)}