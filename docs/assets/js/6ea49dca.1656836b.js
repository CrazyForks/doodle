"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[2088],{5937:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>D,contentTitle:()=>M,default:()=>S,frontMatter:()=>j,metadata:()=>A,toc:()=>k});var o=t(7624),i=t(2172),a=t(1268),l=t(5388),r=t(5720),s=t(7996),d=t(1504),p=t(5972),c=t.n(p),h=t(312),m=t(1130);t(5544);class u extends d.Component{constructor(e){super(e),e.args&&(this.args=JSON.parse(e.args)),this.height=e.height,this.functionName="reactComponent",this.ref=d.createRef()}componentDidMount(){let e=this.ref.current.children[1];this.ref.current.removeChild(this.ref.current.children[1]),this.app=c()[this.functionName](this.ref.current.children[0],e)}componentWillUnmount(){this.app&&c().shutDownApp(this.app)}render(){return(0,o.jsxs)("div",{className:h.c.doodle,ref:this.ref,children:[(0,o.jsx)("div",{style:{position:"relative",height:this.height+"px"}}),(0,o.jsx)(m.cp,{})]})}}var w=t(3148);const y='package display\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.core.WindowGroup\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.layout.constraints.fill\n\n//sampleStart\nclass MyCoolApp(windows: WindowGroup): Application {\n    init {\n        // main window\'s display, same as if Display were injected\n        windows.main.apply {\n            title = "Main Window"\n\n            // manipulate main window\'s display\n            display += view {}\n        }\n\n        // create a new window\n        windows {\n            title                = "A New Window!"\n            size                 = Size(500)\n            enabled              = false\n            resizable            = false\n            triesToAlwaysBeOnTop = true\n\n            // manipulate the new window\'s display\n            display += view {}\n            display.layout = constrain(display.first(), fill)\n\n            closed += {\n                // handle window close\n            }\n        }\n    }\n\n    override fun shutdown() {}\n}\n//sampleEnd',f='package display\n\nimport io.nacular.doodle.controls.popupmenu.MenuBehavior.ItemInfo\nimport io.nacular.doodle.core.Icon\nimport io.nacular.doodle.core.Window\n\nfun example(window: Window, icon1: Icon<ItemInfo>, icon2: Icon<ItemInfo>) {\n//sampleStart\n    window.menuBar {\n        menu("Menu 1") {\n            action("Do action 2", icon1) { /*..*/ }\n            menu("Sub menu") {\n                action("Do action sub", icon = icon2) { /*..*/ }\n                separator()\n                prompt("Some Prompt sub") { /*..*/ }\n            }\n            separator()\n            prompt("Some Prompt") { /*..*/ }\n        }\n\n        menu("Menu 2") {\n            // ...\n        }\n    }\n//sampleEnd\n}',b='package display\n\nimport io.nacular.doodle.controls.popupmenu.MenuBehavior.ItemInfo\nimport io.nacular.doodle.core.Icon\nimport io.nacular.doodle.core.Window\nimport io.nacular.doodle.geometry.Point\n\nfun contextMenu(window: Window, icon1: Icon<ItemInfo>, icon2: Icon<ItemInfo>) {\n//sampleStart\n    window.popupMenu(at = Point()) {\n        action("Do action 2", icon1) { /*..*/ }\n        menu("Sub menu") {\n            action("Do action sub", icon = icon2) { /*..*/ }\n            separator()\n            prompt("Some Prompt sub") { /*..*/ }\n        }\n        separator()\n        prompt("Some Prompt") { /*..*/ }\n    }\n//sampleEnd\n}',g='package io.nacular.doodle.docs.apps\n\nimport io.nacular.doodle.HtmlElementViewFactory\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.controls.text.Label\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.then\nimport io.nacular.doodle.docs.utils.DateRangeSelectionModel\nimport io.nacular.doodle.docs.utils.HorizontalCalendar\nimport io.nacular.doodle.docs.utils.ShadowCard\nimport io.nacular.doodle.drawing.Font\nimport io.nacular.doodle.geometry.PathMetrics\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.theme.Theme\nimport io.nacular.doodle.theme.ThemeManager\nimport kotlinx.datetime.DatePeriod\nimport kotlinx.datetime.LocalDate\nimport kotlinx.datetime.plus\nimport org.w3c.dom.HTMLElement\n\nclass ReactCalendarApp(\n    display        : Display,\n    font           : Font,\n    today          : LocalDate,\n    animate        : Animator,\n    pathMetrics    : PathMetrics,\n    themeManager   : ThemeManager,\n    theme          : Theme,\n    htmlElementView: HtmlElementViewFactory,\n    reactCalendar  : HTMLElement,\n    appHeight      : (Double) -> Unit\n): Application {\n\n    private val doodleCalendar = HorizontalCalendar(\n        today,\n        animate,\n        pathMetrics,\n        startDate = today,\n        endDate   = today + DatePeriod(years = 10),\n        DateRangeSelectionModel()\n    ).apply {\n        this.font = font\n    }\n\n    init {\n        themeManager.selected = theme\n\n//sampleStart\n        display += Label("Doodle").apply { this.font = font }\n        display += ShadowCard(doodleCalendar)\n        display += Label("React").apply { this.font = font }\n        display += htmlElementView(element = reactCalendar)\n//sampleEnd\n\n        val spacing = 20\n\n        display.layout = constrain(\n            display.children[0],\n            display.children[1],\n            display.children[2],\n            display.children[3]\n        ) { doodleLabel, doodle, reactLabel, react ->\n\n            doodle.top          eq doodleLabel.bottom + spacing\n            doodle.height       eq 280\n            react.height        eq doodle.height\n\n            doodleLabel.top     eq spacing\n            doodleLabel.centerX eq doodle.centerX\n            doodleLabel.width.preserve\n            doodleLabel.height.preserve\n\n            reactLabel.centerX  eq react.centerX\n            reactLabel.width.preserve\n            reactLabel.height.preserve\n\n            when {\n                parent.width.readOnly > 800 -> {\n                    doodle.width    eq (parent.width - 3 * spacing) / 2\n                    doodle.right    eq parent.centerX - spacing / 2\n                    react.top       eq doodle.top\n                    react.width     eq doodle.width\n                    react.left      eq doodle.right + spacing\n                    reactLabel.top  eq doodleLabel.top\n                }\n                else -> {\n                    doodle.left     eq spacing\n                    doodle.right    eq parent.right - spacing\n                    react.top       eq reactLabel.bottom + spacing\n                    react.left      eq spacing\n                    react.right     eq parent.right - spacing\n                    reactLabel.top  eq doodle.bottom + spacing\n                }\n            }\n        }.then { container ->\n            // signal to outer docs about height of the app\n            appHeight(container.children.maxOf { it.bounds.bottom } + spacing)\n        }\n    }\n\n    override fun shutdown() {\n        // no-op\n    }\n}',v="package elementview\n\nimport io.nacular.doodle.HtmlElementViewFactory\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.application.HtmlElementViewModule\nimport io.nacular.doodle.application.Modules\nimport io.nacular.doodle.application.application\nimport io.nacular.doodle.core.Display\nimport org.kodein.di.instance\nimport org.w3c.dom.HTMLElement\n\nprivate class MyApp(\n    display    : Display,\n    viewFactory: HtmlElementViewFactory,\n    element    : HTMLElement\n): Application {\n    init {\n        display += viewFactory(element)\n    }\n\n    override fun shutdown() {}\n}\n\nfun main(element: HTMLElement) {\n//sampleStart\n    application(modules = listOf(Modules.HtmlElementViewModule)) {\n         MyApp(display = instance(), viewFactory = instance(), element = element)\n    }\n//sampleEnd\n}\n",x='package io.nacular.doodle.docs.apps\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.controls.buttons.PushButton\nimport io.nacular.doodle.controls.form.Always\nimport io.nacular.doodle.controls.form.Form\nimport io.nacular.doodle.controls.form.labeled\nimport io.nacular.doodle.controls.form.textField\nimport io.nacular.doodle.controls.form.verticalLayout\nimport io.nacular.doodle.controls.text.TextField\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.drawing.Font\nimport io.nacular.doodle.event.KeyCode.Companion.Enter\nimport io.nacular.doodle.event.KeyListener\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.theme.Theme\nimport io.nacular.doodle.theme.ThemeManager\nimport io.nacular.doodle.utils.Resizer\n\nclass EnterKeyInterceptApp(\n    display     : Display,\n    font        : Font,\n    themeManager: ThemeManager,\n    theme       : Theme\n): Application {\n    private lateinit var name    : TextField\n    private lateinit var password: TextField\n\n    private val submit = PushButton("Submit").apply {\n        this.font    = font\n        this.size    = Size(100, 32)\n        this.enabled = false\n\n        this.fired += {\n            name.text     = ""\n            password.text = ""\n        }\n    }\n\n    private val form = Form { this (\n        + labeled("Name",     showRequired = Always()) { textField(Regex(".{3,}")) { name     = textField } },\n        + labeled("Password", showRequired = Always()) { textField(Regex(".{3,}")) { password = textField } },\n        onInvalid = { submit.enabled = false },\n    ) { _,_ ->\n        submit.enabled = true\n    } }.apply {\n        this.font      = font\n        this.size      = Size(300, 100)\n        this.layout    = verticalLayout(this, spacing = 12.0, itemHeight = 32.0)\n        this.focusable = false\n        Resizer(this).apply { movable = false }\n    }\n\n    init {\n        themeManager.selected = theme\n\n//sampleStart\n        form.keyFilter += KeyListener.pressed {\n            if (it.code == Enter && submit.enabled) {\n                it.consume()\n                submit.click()\n            }\n        }\n//sampleEnd\n\n        display += listOf(form, submit)\n\n        display.layout = constrain(form, submit) { form_, submit_ ->\n            val spacing = 10\n\n            form_.center    eq parent.center - Point(y = (spacing + submit_.height.readOnly) / 2)\n            submit_.top     eq form_.bottom + spacing\n            submit_.centerX eq form_.centerX\n        }\n    }\n\n    override fun shutdown() {}\n}',j={hide_title:!0,title:"Whats new in Doodle"},M=void 0,A={id:"whatsnew",title:"Whats new in Doodle",description:"New in Doodle 0.10.0",source:"@site/docs/whatsnew.mdx",sourceDirName:".",slug:"/whatsnew",permalink:"/doodle/docs/whatsnew",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{hide_title:!0,title:"Whats new in Doodle"},sidebar:"tutorialSidebar",previous:{title:"Installation",permalink:"/doodle/docs/installation"},next:{title:"Applications",permalink:"/doodle/docs/applications"}},D={},k=[{value:"New in Doodle 0.10.0",id:"new-in-doodle-0100",level:2},{value:"Browser",id:"browser",level:2},{value:"Hosting arbitrary HTML elements",id:"hosting-arbitrary-html-elements",level:3},{value:"WASM JS",id:"wasm-js",level:3},{value:"Desktop",id:"desktop",level:2},{value:"Multi-window apps",id:"multi-window-apps",level:3},{value:"Native window menus",id:"native-window-menus",level:3},{value:"Native context menus",id:"native-context-menus",level:3},{value:"All Platforms",id:"all-platforms",level:2},{value:"Key event filters and bubbling",id:"key-event-filters-and-bubbling",level:3}];function T(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,i.M)(),...e.components};return w||L("api",!1),w.ViewKeyChanged||L("api.ViewKeyChanged",!0),w.ViewKeyFilter||L("api.ViewKeyFilter",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"new-in-doodle-0100",children:"New in Doodle 0.10.0"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://github.com/nacular/doodle/releases/tag/v0.10.0",children:"Released: February 20, 2024"})}),"\n",(0,o.jsx)(n.p,{children:"The latest version of Doodle brings lots of important updates, especially in terms of better platform support for both Browser and Desktop. Some of the key highlights include:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"New ability to host embed arbitrary HTML elements as Views on Web"}),"\n",(0,o.jsx)(n.li,{children:"WASM JS support"}),"\n",(0,o.jsx)(n.li,{children:"Multiple windows in Desktop apps"}),"\n",(0,o.jsx)(n.li,{children:"OS menu bars in Desktop"}),"\n",(0,o.jsx)(n.li,{children:"More native context menus in Desktop apps"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"browser",children:"Browser"}),"\n",(0,o.jsx)(n.h3,{id:"hosting-arbitrary-html-elements",children:"Hosting arbitrary HTML elements"}),"\n",(0,o.jsx)(n.p,{children:"You can now embed any HTML element into your app as a View. This means Doodle apps can now host React and other web components and interop with a much larger part of the Web ecosystem out of the box!"}),"\n",(0,o.jsx)(u,{functionName:"nestedApp",height:"400"}),"\n",(0,o.jsxs)(a.c,{children:[(0,o.jsx)(l.c,{value:"App",children:(0,o.jsx)(r.A,{children:g})}),(0,o.jsx)(l.c,{value:"Example Launcher",children:(0,o.jsx)(r.A,{children:v})})]}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["This app embeds a ",(0,o.jsx)(n.a,{href:"https://projects.wojtekmaj.pl/react-calendar/",children:"react-calendar"}),"."]})}),"\n",(0,o.jsx)(n.h3,{id:"wasm-js",children:"WASM JS"}),"\n",(0,o.jsxs)(n.p,{children:["Doodle now supports the ",(0,o.jsx)(n.a,{href:"/docs/installation",children:"WasmJS"})," build target. This means apps can also target WebAssembly for the Browser. The APIs/features for this new target are identical as those for the ",(0,o.jsx)(n.code,{children:"js"})," target; which means code can be shared between apps targeting both. The only difference is that the ",(0,o.jsx)(n.code,{children:"application"})," launchers need to be called from separate source sets (i.e. ",(0,o.jsx)(n.code,{children:"jsMain"})," vs ",(0,o.jsx)(n.code,{children:"wasmJsMain"}),")."]}),"\n",(0,o.jsx)(n.h2,{id:"desktop",children:"Desktop"}),"\n",(0,o.jsx)(n.h3,{id:"multi-window-apps",children:"Multi-window apps"}),"\n",(0,o.jsxs)(n.p,{children:["Apps for Desktop can now create/manage multiple windows using the new ",(0,o.jsx)(n.code,{children:"WindowGroup"})," interface. Simply inject it into your app to get started. The API provides access to an app's ",(0,o.jsx)(n.code,{children:"main"})," window as well as methods for creating new windows. Single window apps continue to work as they did before. That is, an app that injects the ",(0,o.jsx)(n.code,{children:"Display"})," will receive the ",(0,o.jsx)(n.code,{children:"main"})," window display and can manipulate it as before. But apps that want to manage their window(s) will need to inject this new type."]}),"\n",(0,o.jsx)(r.A,{children:y}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.p,{children:["There's no need to inject ",(0,o.jsx)(n.code,{children:"Display"})," if you already inject ",(0,o.jsx)(n.code,{children:"WindowGroup"}),". That's because the injected ",(0,o.jsx)(n.code,{children:"Display"})," is equivalent to ",(0,o.jsx)(n.code,{children:"windowGroup.main.display"})]})}),"\n",(0,o.jsx)(n.h3,{id:"native-window-menus",children:"Native window menus"}),"\n",(0,o.jsx)(n.p,{children:"Apps can now set up native menus for their windows. This looks a lot like working with the existing menu APIs, but it results in changes to the OS window decoration. These menus are just as interactive as the in-app ones as well, meaning they trigger events when the user interacts with them."}),"\n",(0,o.jsx)(r.A,{children:f}),"\n",(0,o.jsx)(n.h3,{id:"native-context-menus",children:"Native context menus"}),"\n",(0,o.jsx)(n.p,{children:"Apps can now set up native context/popup menus for their windows. The API is very similar to native menus."}),"\n",(0,o.jsx)(r.A,{children:b}),"\n",(0,o.jsx)(n.h2,{id:"all-platforms",children:"All Platforms"}),"\n",(0,o.jsx)(n.h3,{id:"key-event-filters-and-bubbling",children:"Key event filters and bubbling"}),"\n",(0,o.jsxs)(n.p,{children:['Key events now "sink" and "bubble" like pointer events. This means ancestor Views can intercept (and veto) them before they are delivered to their target (the focused View). They also bubble up to ancestors after being delivered to the target if they are not consumed. The notifications for the first phase happen via a new ',(0,o.jsx)(w.ViewKeyFilter,{})," property, while the bubbling phase is notified via the existing ",(0,o.jsx)(w.ViewKeyChanged,{})," property."]}),"\n",(0,o.jsxs)(n.p,{children:["This change makes it much easier to create Views like the following; which intercepts the ",(0,o.jsx)(n.code,{children:"ENTER"})," key to press the submit button."]}),"\n",(0,o.jsx)(s.u,{functionName:"enterKeyIntercept",height:"300"}),"\n",(0,o.jsx)(r.A,{children:x})]})}function S(e={}){const{wrapper:n}={...(0,i.M)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(T,{...e})}):T(e)}function L(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);