"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[9251],{8032:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>u,contentTitle:()=>h,default:()=>w,frontMatter:()=>r,metadata:()=>t,toc:()=>m});const t=JSON.parse('{"id":"applications","title":"Applications","description":"All Doodle apps run within an . It is the entry-point for your business logic, and often the first class you write. Doodle fully initializes your app at constructor time, so there is no additional run or start method to implement. You can provide custom tear-down logic via the shutdown method though.","source":"@site/docs/applications.mdx","sourceDirName":".","slug":"/applications","permalink":"/doodle/docs/applications","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"hide_title":true,"title":"Applications"},"sidebar":"tutorialSidebar","previous":{"title":"Installation","permalink":"/doodle/docs/installation"},"next":{"title":"Displays","permalink":"/doodle/docs/display"}}');var o=i(4848),a=i(8453),l=(i(5537),i(9329),i(4069)),p=(i(7269),i(9172));const s='import io.nacular.doodle.application.Application\n\n//sampleStart\nclass UsefulApp: Application {\n    init {\n        println("Hi!")\n    }\n\n    override fun shutdown() {}\n}\n//sampleEnd',d='package applications\n\nimport io.nacular.doodle.application.Modules.Companion.PointerModule\nimport io.nacular.doodle.application.application\nimport org.kodein.di.DI.Module\nimport org.kodein.di.instance\n\n//sampleStart\nfun main() {\n    application(modules = listOf(\n        PointerModule,\n        // ...,\n        Module(name = "A Custom Module") {\n            // custom Kodein bind statements\n        },\n        /*...*/)) {\n        MyApp(instance())\n    }\n}\n//sampleEnd',c="package usefulapp\n\nimport UsefulApp\nimport io.nacular.doodle.application.application\n\n//sampleStart\nfun main() {\n    // launch full-screen\n    application {\n        UsefulApp()\n    }\n}\n//sampleEnd",r={hide_title:!0,title:"Applications"},h="Applications",u={},m=[{value:"Launching an application",id:"launching-an-application",level:2},{value:"Top-level applications",id:"top-level-applications",level:2},{value:"Nested applications (Web)",id:"nested-applications-web",level:2},{value:"Modularity",id:"modularity",level:2}];function f(n){const e={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",strong:"strong",...(0,a.R)(),...n.components};return p.F||x("api",!1),p.F.Application||x("api.Application",!0),p.F.ApplicationLaunch||x("api.ApplicationLaunch",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"applications",children:"Applications"})}),"\n",(0,o.jsxs)(e.p,{children:["All Doodle apps run within an ",(0,o.jsx)(p.F.Application,{}),". It is the entry-point for your business logic, and often the first class you write. Doodle fully initializes your app at constructor time, so there is no additional ",(0,o.jsx)(e.em,{children:"run"})," or ",(0,o.jsx)(e.em,{children:"start"})," method to implement. You can provide custom tear-down logic via the ",(0,o.jsx)(e.code,{children:"shutdown"})," method though."]}),"\n",(0,o.jsx)(l.v,{children:s}),"\n",(0,o.jsx)(e.h2,{id:"launching-an-application",children:"Launching an application"}),"\n",(0,o.jsxs)(e.p,{children:["You can either launch an app ",(0,o.jsx)(e.strong,{children:"top-level"}),", or ",(0,o.jsx)(e.strong,{children:"nested"})," within another app (web). The Application class does not change regardless of the launch mode. That is because apps have no knowledge of the mode they will run in, making them independent of platform concepts by default."]}),"\n",(0,o.jsx)(e.admonition,{type:"tip",children:(0,o.jsx)(e.p,{children:"App launch is platform-specific, allowing customization of app setup."})}),"\n",(0,o.jsx)(e.h2,{id:"top-level-applications",children:"Top-level applications"}),"\n",(0,o.jsxs)(e.p,{children:["Most apps will run independent of others and exist purely within the context of a window. Use the ",(0,o.jsx)(p.F.ApplicationLaunch,{})," function to launch apps this way. The result is a full-screen experience, with the app taking up the entire window and controlling all aspects of it."]}),"\n",(0,o.jsx)(l.v,{children:c}),"\n",(0,o.jsx)(e.admonition,{type:"tip",children:(0,o.jsxs)(e.p,{children:["Web apps can also be ",(0,o.jsx)(e.a,{href:"platform_specific/web#host-apps-in-html-elements",children:"hosted in HTML elements"}),". And desktop apps can manage ",(0,o.jsx)(e.a,{href:"platform_specific/desktop#multi-window-apps",children:"multiple windows"}),"."]})}),"\n",(0,o.jsx)(e.h2,{id:"nested-applications-web",children:"Nested applications (Web)"}),"\n",(0,o.jsxs)(e.p,{children:["Doodle web apps can also be run ",(0,o.jsx)(e.a,{href:"platform_specific/web#nested-apps",children:"within other Doodle Web apps"}),"."]}),"\n",(0,o.jsx)(e.h2,{id:"modularity",children:"Modularity"}),"\n",(0,o.jsxs)(e.p,{children:["Doodle uses ",(0,o.jsx)(e.a,{href:"https://en.wikipedia.org/wiki/Dependency_injection",children:"dependency injection"})," when creating apps. The lambda provided when launching an app is actually a ",(0,o.jsx)(e.a,{href:"https://github.com/Kodein-Framework/Kodein-DI",children:"Kodein"})," binding context that lets you inject instances from Doodle modules, or your own."]}),"\n",(0,o.jsx)(l.v,{children:d})]})}function w(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(f,{...n})}):f(n)}function x(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);