"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[4748],{3080:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>L,contentTitle:()=>I,default:()=>V,frontMatter:()=>z,metadata:()=>a,toc:()=>O});const a=JSON.parse('{"id":"animations","title":"Animation","description":"Animations are key to making an app feel modern and interactive. Doodle helps you achieve this with a powerful yet simple set of APIs that let you animate a wide range of things into your app. Everything you need to build sophisticated animations is available via the  interface and its related components.","source":"@site/docs/animations.mdx","sourceDirName":".","slug":"/animations","permalink":"/doodle/docs/animations","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"hide_title":true,"title":"Animation"},"sidebar":"tutorialSidebar","previous":{"title":"Transforms","permalink":"/doodle/docs/transforms"},"next":{"title":"Drag \u2022 Drop","permalink":"/doodle/docs/dragdrop"}}');var o=i(4848),t=i(8453),r=i(5537),l=i(9329),s=i(8030),d=i(7269),m=i(4069),c=i(9172);const u='dependencies {\n    implementation ("io.nacular.doodle:animation:$doodleVersion")\n}',p='//sampleStart\ndependencies {\n    implementation "io.nacular.doodle:animation:$doodle_version"\n}\n//sampleEnd',h='package animation\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.AnimatorImpl\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.application.application\nimport io.nacular.doodle.core.Display\nimport org.kodein.di.DI.Module\nimport org.kodein.di.bindProvider\nimport org.kodein.di.instance\n\nclass MyApp(display: Display, animator: Animator): Application {\n    init {\n        // ..\n    }\n\n    override fun shutdown() {}\n}\n\n//sampleStart\nval AnimationModule = Module(name = "AnimationModule") {\n    bindProvider<Animator> { AnimatorImpl(timer = instance(), animationScheduler = instance()) }\n}\n\nfun main() {\n    application(modules = listOf(AnimationModule)) {\n        MyApp(display = instance(), animator = instance())\n    }\n}\n//sampleEnd',g="package animation\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.invoke\nimport io.nacular.doodle.animation.transition.linear\nimport io.nacular.doodle.animation.tweenFloat\nimport io.nacular.measured.units.Time.Companion.seconds\nimport io.nacular.measured.units.times\n\nfun singleValue(animate: Animator) {\n//sampleStart\n    animate(0f to 1f, using = tweenFloat(linear, 0.25 * seconds)) { value: Float ->\n        // ...\n    }\n//sampleEnd\n}",v="package animation\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.RepetitionType.Reverse\nimport io.nacular.doodle.animation.loop\nimport io.nacular.doodle.animation.transition.EasingFunction\nimport io.nacular.doodle.animation.tweenColor\nimport io.nacular.doodle.animation.tweenDouble\nimport io.nacular.doodle.animation.tweenSize\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.Color.Companion.Blue\nimport io.nacular.doodle.drawing.Color.Companion.Red\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.measured.units.Measure\nimport io.nacular.measured.units.Time\n\nfun groupedValues(animate: Animator, easing: EasingFunction, duration: Measure<Time>) {\n    val circle = view {}\n\n//sampleStart\n    animate {\n        Blue to Red using loop(tweenColor(easing, duration), type = Reverse).invoke {\n            circle.backgroundColor = it\n        }\n\n        200.0 to 100.0 using loop(tweenDouble(easing, duration), type = Reverse).invoke {\n            circle.suggestY(it)\n        }\n\n        Size(100) to Size(75) using loop(tweenSize(easing, duration), type = Reverse).invoke {\n            circle.suggestSize(it)\n        }\n    }\n//sampleEnd\n}",f="package animation\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.invoke\nimport io.nacular.doodle.animation.transition.linear\nimport io.nacular.doodle.animation.tweenFloat\nimport io.nacular.measured.units.Time.Companion.milliseconds\nimport io.nacular.measured.units.times\n\nfun numeric(animate: Animator) {\n//sampleStart\n    animate(0f to 1f, using = tweenFloat(linear, 250 * milliseconds)) {\n        println(it)\n    }\n//sampleEnd\n}",w="package animation\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.invoke\nimport io.nacular.doodle.animation.transition.EasingFunction\nimport io.nacular.doodle.animation.tweenPoint\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.Point.Companion.Origin\nimport io.nacular.measured.units.Measure\nimport io.nacular.measured.units.Time\n\nfun point(animate: Animator, easing: EasingFunction, duration: Measure<Time>) {\n//sampleStart\n    animate(Origin to Point(100, 200), using = tweenPoint(easing, duration)) {\n        // ...\n    }\n//sampleEnd\n}",y="package animation\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.invoke\nimport io.nacular.doodle.animation.transition.EasingFunction\nimport io.nacular.doodle.animation.tweenSize\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.measured.units.Measure\nimport io.nacular.measured.units.Time\n\nfun size(animate: Animator, easing: EasingFunction, duration: Measure<Time>) {\n//sampleStart\n    animate(Size(100) to Size(100, 200), using = tweenSize(easing, duration)) {\n        // ...\n    }\n//sampleEnd\n}",x="package animation\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.invoke\nimport io.nacular.doodle.animation.transition.EasingFunction\nimport io.nacular.doodle.animation.tweenRect\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.geometry.Rectangle.Companion.Empty\nimport io.nacular.measured.units.Measure\nimport io.nacular.measured.units.Time\n\nfun rect(animate: Animator, easing: EasingFunction, duration: Measure<Time>) {\n//sampleStart\n    animate(Empty to Rectangle(100, 200), using = tweenRect(easing, duration)) {\n        // ...\n    }\n//sampleEnd\n}",j="package animation\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.invoke\nimport io.nacular.doodle.animation.transition.EasingFunction\nimport io.nacular.doodle.animation.tweenColor\nimport io.nacular.doodle.drawing.Color.Companion.Green\nimport io.nacular.doodle.drawing.Color.Companion.Red\nimport io.nacular.measured.units.Measure\nimport io.nacular.measured.units.Time\n\nfun color(animate: Animator, easing: EasingFunction, duration: Measure<Time>) {\n//sampleStart\n    animate(Red to Green, using = tweenColor(easing, duration)) {\n        // ...\n    }\n//sampleEnd\n}",b="package animation\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.invoke\nimport io.nacular.doodle.animation.keyFramesDouble\nimport io.nacular.doodle.animation.transition.easeInElastic\nimport io.nacular.doodle.animation.transition.easeOutBack\nimport io.nacular.doodle.animation.transition.linear\nimport io.nacular.doodle.core.View\nimport io.nacular.measured.units.Time.Companion.seconds\nimport io.nacular.measured.units.times\n\nfun size(animate: Animator, graph: View) {\n//sampleStart\n    val duration = 1 * seconds\n\n    animate(0.0 to graph.height, keyFramesDouble(duration) {\n//  value           | at what time      | easing to next value\n//  --------------------------------------------------------------\n        0.0                at duration * 0   then easeInElastic\n        graph.height * 1/3 at duration * 1/3 then linear\n        graph.height * 2/3 at duration * 2/3 then easeOutBack\n    }) {\n        // ...\n    }\n//sampleEnd\n}",k="package animation\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.invoke\nimport io.nacular.doodle.animation.keyFramesPoint\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.Point.Companion.Origin\nimport io.nacular.measured.units.Measure\nimport io.nacular.measured.units.Time\n\nfun pointKeyframe(animate: Animator, duration: Measure<Time>) {\n//sampleStart\n    animate(Origin to Point(100, 200), using = keyFramesPoint(duration) {\n        // key frame definition\n    }) {\n        // animation block\n    }\n//sampleEnd\n}",F="package animation\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.invoke\nimport io.nacular.doodle.animation.keyFramesSize\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.measured.units.Measure\nimport io.nacular.measured.units.Time\n\nfun sizeKeyframe(animate: Animator, duration: Measure<Time>) {\n//sampleStart\n    animate(Size(100) to Size(100, 200), using = keyFramesSize(duration) {\n        // key frame definition\n    }) {\n        // animation block\n    }\n//sampleEnd\n}",A="package animation\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.invoke\nimport io.nacular.doodle.animation.keyFramesRect\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.geometry.Rectangle.Companion.Empty\nimport io.nacular.measured.units.Measure\nimport io.nacular.measured.units.Time\n\nfun rectKeyframe(animate: Animator, duration: Measure<Time>) {\n//sampleStart\n    animate(Empty to Rectangle(100, 200), using = keyFramesRect(duration) {\n        // key frame definition\n    }) {\n        // animation block\n    }\n//sampleEnd\n}",T="package animation\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.invoke\nimport io.nacular.doodle.animation.keyFramesColor\nimport io.nacular.doodle.drawing.Color.Companion.Green\nimport io.nacular.doodle.drawing.Color.Companion.Red\nimport io.nacular.measured.units.Measure\nimport io.nacular.measured.units.Time\n\nfun colorKeyframe(animate: Animator, duration: Measure<Time>) {\n//sampleStart\n    animate(Red to Green, using = keyFramesColor(duration) {\n        // key frame definition\n    }) {\n        // animation block\n    }\n//sampleEnd\n}",C="package animation\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.RepetitionType.Reverse\nimport io.nacular.doodle.animation.invoke\nimport io.nacular.doodle.animation.repeat\nimport io.nacular.doodle.animation.transition.EasingFunction\nimport io.nacular.doodle.animation.tweenFloat\nimport io.nacular.measured.units.Measure\nimport io.nacular.measured.units.Time\n\nfun repeat(animate: Animator, easing: EasingFunction, duration: Measure<Time>) {\n//sampleStart\n    animate(0f to 1f, repeat(tweenFloat(easing, duration), times = 2, type = Reverse)) {\n        // ...\n    }\n\n    animate {\n        0f to 1f using (repeat(tweenFloat(easing, duration), times = 2, type = Reverse)) {\n            // ...\n        }\n    }\n//sampleEnd\n}",S="package animation\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.RepetitionType.Reverse\nimport io.nacular.doodle.animation.invoke\nimport io.nacular.doodle.animation.loop\nimport io.nacular.doodle.animation.transition.EasingFunction\nimport io.nacular.doodle.animation.tweenFloat\nimport io.nacular.measured.units.Measure\nimport io.nacular.measured.units.Time\n\nfun loop(animate: Animator, easing: EasingFunction, duration: Measure<Time>) {\n//sampleStart\n    animate.invoke(0f to 1f, loop(tweenFloat(easing, duration), type = Reverse)) {\n        // ...\n    }\n\n    animate {\n        0f to 1f using (loop(tweenFloat(easing, duration), type = Reverse)) {\n            // ...\n        }\n    }\n//sampleEnd\n}",R="package animation\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.after\nimport io.nacular.doodle.animation.invoke\nimport io.nacular.doodle.animation.transition.EasingFunction\nimport io.nacular.doodle.animation.tweenFloat\nimport io.nacular.measured.units.Measure\nimport io.nacular.measured.units.Time\n\nfun delay(animate: Animator, easing: EasingFunction, duration: Measure<Time>, delay: Measure<Time>) {\n//sampleStart\n    animate(0f to 1f, after(delay, tweenFloat(easing, duration))) {\n        // ...\n    }\n\n    animate {\n        0f to 1f using (after(delay, tweenFloat(easing, duration))) {\n            // ...\n        }\n    }\n//sampleEnd\n}",D="package animation\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.invoke\nimport io.nacular.doodle.animation.transition.linear\nimport io.nacular.doodle.animation.tweenColor\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.drawing.Color.Companion.Red\nimport io.nacular.measured.units.Time.Companion.milliseconds\nimport io.nacular.measured.units.times\n\n//sampleStart\nclass MyView(animate: Animator): View() {\n    // ..\n\n    var color by animate(default = Red, tweenColor(linear, 250 * milliseconds)) { old, new ->\n        rerenderNow()\n    }\n\n    // ..\n}\n//sampleEnd",E="package animation\n\nimport io.nacular.doodle.animation.Animation\n\nfun lifeCycle(animation: Animation<*>) {\n//sampleStart\n    animation.completed += { /*...*/ }\n    animation.canceled  += { /*...*/ }\n//sampleEnd\n}",B="package animation\n\nimport io.nacular.doodle.animation.Animation\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.invoke\nimport io.nacular.doodle.animation.transition.easeInElastic\nimport io.nacular.doodle.animation.transition.linear\nimport io.nacular.doodle.animation.tweenFloat\nimport io.nacular.doodle.utils.autoCanceling\nimport io.nacular.measured.units.Time.Companion.seconds\nimport io.nacular.measured.units.times\n\nfun autoCancel(animate: Animator) {\n//sampleStart\n    // using autoCanceling ensures existing animation is canceled when a new one is assigned\n    var someAnimation: Animation<Float>? by autoCanceling()\n\n    someAnimation = animate.invoke(0f to 1f, using = tweenFloat(linear, 1 * seconds)) {\n        // ...\n    }\n\n    // ...\n\n    // Any ongoing animation is canceled with this assignment\n    someAnimation = animate.invoke(1f to 0f, using = tweenFloat(easeInElastic, 1 * seconds)) {\n        // ...\n    }\n\n//sampleEnd\n}",P='package animation\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.SingleDataConverter\nimport io.nacular.doodle.animation.invoke\nimport io.nacular.doodle.animation.transition.EasingFunction\nimport io.nacular.doodle.animation.tween\nimport io.nacular.measured.units.Measure\nimport io.nacular.measured.units.Time\n\nfun customData(animate: Animator, easing: EasingFunction, duration: Measure<Time>) {\n//sampleStart\n    data class Foo(val value: String)\n\n    val customDataConverter = object: SingleDataConverter<Foo> {\n        override val zero                      : Foo = Foo("")\n        override fun serialize  (value: Foo   ): Double = value.value.toDouble()\n        override fun deserialize(value: Double): Foo    = Foo("$value")\n    }\n\n    animate(Foo("1") to Foo("2"), tween(customDataConverter, easing, duration)) { value: Foo ->\n        // ...\n    }\n//sampleEnd\n}';var M=i(8968);const z={hide_title:!0,title:"Animation"},I="Animations",L={},O=[...s.RM,{value:"Requirements",id:"requirements",level:2},{value:"Animating a single value",id:"animating-a-single-value",level:2},{value:"Grouped animations",id:"grouped-animations",level:2},{value:"Chaining animations",id:"chaining-animations",level:2},{value:"Tweens",id:"tweens",level:2},{value:"Numeric data",id:"numeric-data",level:3},{value:"Colors, Sizes, ...",id:"colors-sizes-",level:3},{value:"Easing functions",id:"easing-functions",level:3},{value:"Key frames",id:"key-frames",level:2},{value:"Repetition",id:"repetition",level:2},{value:"Finite repeating",id:"finite-repeating",level:3},{value:"Loops",id:"loops",level:3},{value:"Delays",id:"delays",level:2},{value:"Animating properties",id:"animating-properties",level:2},{value:"Animation lifecycle",id:"animation-lifecycle",level:2},{value:"Animating custom data",id:"animating-custom-data",level:2},{value:"Numeric conversion",id:"numeric-conversion",level:3},{value:"Non-numeric data",id:"non-numeric-data",level:3}];function N(n){const e={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",mermaid:"mermaid",p:"p",pre:"pre",...(0,t.R)(),...n.components};return c.F||Y("api",!1),c.F.Animation||Y("api.Animation",!0),c.F.AnimationConverters||Y("api.AnimationConverters",!0),c.F.AnimationLibrary||Y("api.AnimationLibrary",!0),c.F.AnimationPlan||Y("api.AnimationPlan",!0),c.F.Animator||Y("api.Animator",!0),c.F.Behavior||Y("api.Behavior",!0),c.F.Color||Y("api.Color",!0),c.F.EasingFunction||Y("api.EasingFunction",!0),c.F.KeyFramesFloat||Y("api.KeyFramesFloat",!0),c.F.Linear||Y("api.Linear",!0),c.F.MultiDataConverter||Y("api.MultiDataConverter",!0),c.F.Point||Y("api.Point",!0),c.F.Rectangle||Y("api.Rectangle",!0),c.F.Repeat||Y("api.Repeat",!0),c.F.Restart||Y("api.Restart",!0),c.F.Reverse||Y("api.Reverse",!0),c.F.SingleDataConverter||Y("api.SingleDataConverter",!0),c.F.Size||Y("api.Size",!0),c.F.TweenDouble||Y("api.TweenDouble",!0),c.F.TweenInt||Y("api.TweenInt",!0),c.F.View||Y("api.View",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"animations",children:"Animations"})}),"\n",(0,o.jsxs)(e.p,{children:["Animations are key to making an app feel modern and interactive. Doodle helps you achieve this with a powerful yet simple set of APIs that let you animate a wide range of things into your app. Everything you need to build sophisticated animations is available via the ",(0,o.jsx)(c.F.Animator,{})," interface and its related components."]}),"\n",(0,o.jsx)(d.T,{functionName:"easingCurve",height:"400"}),"\n",(0,o.jsx)(s.Ay,{link:(0,o.jsx)(c.F.AnimationLibrary,{}),kotlin:u,groovy:p}),"\n",(0,o.jsx)(e.h2,{id:"requirements",children:"Requirements"}),"\n",(0,o.jsxs)(e.p,{children:["Then you will need to include the ",(0,o.jsx)(c.F.Animator,{})," in the list of Kodein modules your app launches with. You can do this by defining a new Module, or by including a binding for it in an existing Module you are already installing."]}),"\n",(0,o.jsx)(m.v,{children:h}),"\n",(0,o.jsx)(e.h2,{id:"animating-a-single-value",children:"Animating a single value"}),"\n",(0,o.jsx)(e.p,{children:"Doodle offers two main APIs to handle common animation use cases. The first allows you to animate a value from start to finish and handle each increment within a lambda. This is a very flexible API that can be used to accomplish most use cases."}),"\n",(0,o.jsxs)(e.p,{children:["These animations are of the following form. This examples animates a ",(0,o.jsx)(e.code,{children:"Float"})," value between ",(0,o.jsx)(e.code,{children:"0"})," and ",(0,o.jsx)(e.code,{children:"1"})," using a ",(0,o.jsx)(c.F.Linear,{})," easing that takes ",(0,o.jsx)(e.code,{children:"250 ms"}),"."]}),"\n",(0,o.jsx)(m.v,{children:g}),"\n",(0,o.jsxs)(e.p,{children:["The lambda provided to the ",(0,o.jsx)(c.F.Animator,{})," will be evaluated every time the animating value changes. This allows the app to take action in real time."]}),"\n",(0,o.jsxs)(e.p,{children:["Notice that this API does not make any references to ",(0,o.jsx)(c.F.View,{})," or any other Doodle concept. This allows animations like these to operate on any compatible data."]}),"\n",(0,o.jsx)(e.admonition,{type:"info",children:(0,o.jsx)(e.p,{children:"The animating ball example above uses this approach to change the ball's vertical position."})}),"\n",(0,o.jsx)(e.h2,{id:"grouped-animations",children:"Grouped animations"}),"\n",(0,o.jsxs)(e.p,{children:["You can also animate a series of properties under a single ",(0,o.jsx)(e.code,{children:"Animation"})," handle. This makes it easy to track and modify the behavior of several properties at once instead of having an animation for each."]}),"\n",(0,o.jsxs)(e.p,{children:["This code below shows how the ",(0,o.jsx)(e.a,{href:"#loops",children:"looping ball"})," example animates 3 different properties. The resulting ",(0,o.jsx)(e.code,{children:"animation"})," will manage all the underlying items as expected."]}),"\n",(0,o.jsx)(m.v,{children:v}),"\n",(0,o.jsx)(e.admonition,{type:"tip",children:(0,o.jsx)(e.p,{children:"There is no requirement that the animations define within the block have the same duration or are even of the same type."})}),"\n",(0,o.jsx)(e.h2,{id:"chaining-animations",children:"Chaining animations"}),"\n",(0,o.jsxs)(e.p,{children:["Animations within a block can be chained together to create new sequential animations that have nice cancellation properties. This is helpful for cases where you'd like to start a follow-up animation after a previous one completes, while keeping the ability to cancel the chain if needed. Manually doing this via ",(0,o.jsx)(e.code,{children:"onComplete"})," results in creating additional, independent animations, which requires more bookkeeping to cancel everything."]}),"\n",(0,o.jsx)(e.p,{children:"This app shows an example of animation chaining. The wheel bounces, then slides and rolls down the hill. The bounce animates first, then the slide and roll are done as a single chained block that begins when the bounce completes."}),"\n",(0,o.jsx)(d.T,{functionName:"animationChaining",height:"400"}),"\n",(0,o.jsx)(m.v,{children:M.A}),"\n",(0,o.jsx)(e.h2,{id:"tweens",children:"Tweens"}),"\n",(0,o.jsxs)(e.p,{children:["Tween animations let you interpolate data between two values using a curve (or easing function). These animations work with data that can be converted to numeric (",(0,o.jsx)(e.code,{children:"Double"}),") representation. Doodle has several ",(0,o.jsx)(e.code,{children:"tween*"})," functions, all with the form:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-kotlin",children:"tween*(\n    easing  : EasingFunction,\n    duration: Measure<Time>,\n    delay   : Measure<Time>\n)\n"})}),"\n",(0,o.jsx)(e.h3,{id:"numeric-data",children:"Numeric data"}),"\n",(0,o.jsxs)(e.p,{children:["Doodle supports tweens with any ",(0,o.jsx)(e.code,{children:"Number"})," type and includes APIs for working with ",(0,o.jsx)(e.code,{children:"Float"}),", ",(0,o.jsx)(e.code,{children:"Double"})," and ",(0,o.jsx)(e.code,{children:"Int"}),". This shows how you can animate a ",(0,o.jsx)(e.code,{children:"Float"})," from ",(0,o.jsx)(e.code,{children:"0"})," to ",(0,o.jsx)(e.code,{children:"100"})," using a ",(0,o.jsx)(c.F.Linear,{})," tween that lasts ",(0,o.jsx)(e.code,{children:"250 ms"}),", and starts immediately (no ",(0,o.jsx)(e.code,{children:"delay"}),")."]}),"\n",(0,o.jsx)(m.v,{children:f}),"\n",(0,o.jsx)(e.admonition,{type:"tip",children:(0,o.jsxs)(e.p,{children:["You can also use ",(0,o.jsx)(c.F.TweenDouble,{})," and ",(0,o.jsx)(c.F.TweenInt,{})," to work with other number types."]})}),"\n",(0,o.jsx)(e.h3,{id:"colors-sizes-",children:"Colors, Sizes, ..."}),"\n",(0,o.jsxs)(e.p,{children:["Doodle also allows you to tween non-numeric data, as long as it can be converted to a numeric representation. This works really well for things like ",(0,o.jsx)(c.F.Point,{}),", ",(0,o.jsx)(c.F.Size,{}),", ",(0,o.jsx)(c.F.Rectangle,{}),", and ",(0,o.jsx)(c.F.Color,{}),". All of these data types are supported by built-in tween variants. So you can do any of the following."]}),"\n",(0,o.jsx)(d.T,{functionName:"animatedProperties",args:'["size"]',height:"400"}),"\n",(0,o.jsxs)(r.A,{children:[(0,o.jsx)(l.A,{value:"Point",children:(0,o.jsx)(m.v,{children:w})}),(0,o.jsx)(l.A,{value:"Size",children:(0,o.jsx)(m.v,{children:y})}),(0,o.jsx)(l.A,{value:"Rect",children:(0,o.jsx)(m.v,{children:x})}),(0,o.jsx)(l.A,{value:"Color",children:(0,o.jsx)(m.v,{children:j})})]}),"\n",(0,o.jsxs)(e.p,{children:["This is an example of a ",(0,o.jsx)(e.a,{href:"ui_components/overview#switch",children:"Switch"})," with a custom ",(0,o.jsx)(c.F.Behavior,{})," that draws a heart and animates between selection state using an arbitrary easing function."]}),"\n",(0,o.jsx)(d.T,{functionName:"heartSwitch",height:"300"}),"\n",(0,o.jsxs)("div",{style:{fontSize:"10px",textAlign:"right",color:"gray"},children:["Inspired by ",(0,o.jsx)("a",{style:{color:"gray"},href:"https://dribbble.com/shots/8306407-I-heart-toggle",title:"I heart toggle",children:"Tore Bernhoft"})]}),"\n",(0,o.jsx)(e.h3,{id:"easing-functions",children:"Easing functions"}),"\n",(0,o.jsxs)(e.p,{children:["The ",(0,o.jsx)(e.code,{children:"tween*"})," functions work with one or more ",(0,o.jsx)(c.F.EasingFunction,{}),", a ",(0,o.jsx)(e.code,{children:"duration"})," of (",(0,o.jsx)(e.a,{href:"https://nacular.github.io/measured",children:(0,o.jsx)(e.code,{children:"Measure<Time>"})}),"), and an optional ",(0,o.jsx)(e.code,{children:"delay"})," (also a ",(0,o.jsx)(e.code,{children:"Measure<Time>"}),"). ",(0,o.jsx)(e.code,{children:"EasingFunction"})," is simply a function that takes a ",(0,o.jsx)(e.code,{children:"Float"})," between ",(0,o.jsx)(e.code,{children:"0"})," and ",(0,o.jsx)(e.code,{children:"1"})," and returns another ",(0,o.jsx)(e.code,{children:"Float"})," scaled to ",(0,o.jsx)(e.code,{children:"0"})," and ",(0,o.jsx)(e.code,{children:"1"}),". Doodle includes many common easing functions already."]}),"\n",(0,o.jsxs)(e.p,{children:["But it is just as simple to create a custom one as well. Simply provide a function of the following form that maps inputs between ",(0,o.jsx)(e.code,{children:"0"})," and ",(0,o.jsx)(e.code,{children:"1"})," to a normalized output in (or slightly outside) that range."]}),"\n",(0,o.jsx)(m.v,{children:"(Float) -> Float"}),"\n",(0,o.jsx)(e.h2,{id:"key-frames",children:"Key frames"}),"\n",(0,o.jsx)(e.p,{children:"Doodle also supports key-frame animations. These let you specify intermediate values the animated property will have at specific times, and the easing curves between these values. The following example animates the ball's y position so it takes 1/3 of the total duration to get from one level to the next. But it provides 3 separate curves to animate between each level."}),"\n",(0,o.jsx)(d.T,{functionName:"keyFrames",height:"400"}),"\n",(0,o.jsx)(m.v,{children:b}),"\n",(0,o.jsx)(e.admonition,{type:"tip",children:(0,o.jsxs)(e.p,{children:["The default ease from the ",(0,o.jsx)(e.code,{children:"start"})," to the first value in the key frames is ",(0,o.jsx)(c.F.Linear,{}),". The example above overrides this by specifying the first key frame as the ",(0,o.jsx)(e.code,{children:"start"}),", then it is able to specify how to ease from the beginning."]})}),"\n",(0,o.jsxs)(e.p,{children:["Key-frame animations are defined using the ",(0,o.jsx)(e.code,{children:"keyFrame*"})," (i.e. ",(0,o.jsx)(c.F.KeyFramesFloat,{}),") functions that work on data that can be mapped to numeric values like ",(0,o.jsx)(e.code,{children:"tween*"}),". Similarly, Doodle provides built-in support for the same set of data types here as it does for ",(0,o.jsx)(e.code,{children:"tween*"}),"."]}),"\n",(0,o.jsxs)(r.A,{children:[(0,o.jsx)(l.A,{value:"Point",children:(0,o.jsx)(m.v,{children:k})}),(0,o.jsx)(l.A,{value:"Size",children:(0,o.jsx)(m.v,{children:F})}),(0,o.jsx)(l.A,{value:"Rect",children:(0,o.jsx)(m.v,{children:A})}),(0,o.jsx)(l.A,{value:"Color",children:(0,o.jsx)(m.v,{children:T})})]}),"\n",(0,o.jsx)(e.h2,{id:"repetition",children:"Repetition"}),"\n",(0,o.jsx)(e.h3,{id:"finite-repeating",children:"Finite repeating"}),"\n",(0,o.jsxs)(e.p,{children:["You can repeat animations like ",(0,o.jsx)(e.code,{children:"tween*"})," or ",(0,o.jsx)(e.code,{children:"keyFrame*"})," using the ",(0,o.jsx)(c.F.Repeat,{})," wrapper. This wrapper takes an ",(0,o.jsx)(e.code,{children:"animationPlan"}),", the number of ",(0,o.jsx)(e.code,{children:"times"})," it should be repeated and the type of repetition (",(0,o.jsx)(c.F.Restart,{})," or ",(0,o.jsx)(c.F.Reverse,{}),")."]}),"\n",(0,o.jsx)(d.T,{functionName:"animationRepeating",height:"300"}),"\n",(0,o.jsxs)(e.p,{children:["For example, you can ",(0,o.jsx)(c.F.Repeat,{})," a ",(0,o.jsx)(c.F.Linear,{})," tween from ",(0,o.jsx)(e.code,{children:"0"})," to ",(0,o.jsx)(e.code,{children:"1"})," as follows."]}),"\n",(0,o.jsx)(m.v,{children:C}),"\n",(0,o.jsxs)(e.p,{children:["The ",(0,o.jsx)(e.code,{children:"type"})," determines what the animation will do at each repetition boundary. ",(0,o.jsx)(c.F.Restart,{})," will run the animation again as though it were just beginning. While ",(0,o.jsx)(c.F.Reverse,{})," will run the animation from its end to start."]}),"\n",(0,o.jsx)(e.h3,{id:"loops",children:"Loops"}),"\n",(0,o.jsxs)(e.p,{children:["Sometimes you'd like to run an animation that repeats indefinitely. The ",(0,o.jsx)(e.code,{children:"loop"})," function makes this easy. It is just like ",(0,o.jsx)(c.F.Repeat,{}),", except it takes no ",(0,o.jsx)(e.code,{children:"times"}),' value and continues "forever". The following app runs a looping animation (that reverses) to change the ball\'s ',(0,o.jsx)(e.code,{children:"y"}),", ",(0,o.jsx)(e.code,{children:"color"}),", and ",(0,o.jsx)(e.code,{children:"size"})," based on an easing."]}),"\n",(0,o.jsx)(d.T,{functionName:"animatedProperties",args:'["bounce"]',height:"350"}),"\n",(0,o.jsx)(m.v,{children:S}),"\n",(0,o.jsx)(e.h2,{id:"delays",children:"Delays"}),"\n",(0,o.jsxs)(e.p,{children:["All animations can be delayed using the ",(0,o.jsx)(e.code,{children:"after"})," function. It takes a time to delay and executes the given animation after that delay has passed."]}),"\n",(0,o.jsx)(d.T,{functionName:"delayedEasingCurve",height:"400"}),"\n",(0,o.jsx)(m.v,{children:R}),"\n",(0,o.jsx)(e.h2,{id:"animating-properties",children:"Animating properties"}),"\n",(0,o.jsxs)(e.p,{children:["An ",(0,o.jsx)(c.F.Animator,{})," can also be used to create animatable properties for a class. These properties will then animate from their current value to a new one whenever they are changed. This is done as follows:"]}),"\n",(0,o.jsx)(m.v,{children:D}),"\n",(0,o.jsx)(e.p,{children:"Doodle manages the animation lifecycle of these properties for you and optionally notifies you of changes throughout the animation. This makes it easy to react as the value changes. An existing animation will be canceled if a new value is set for the property, and the property will begin animating towards that new value."}),"\n",(0,o.jsx)(e.admonition,{type:"info",children:(0,o.jsxs)(e.p,{children:["An interruption in the animation will reset the elapsed time. So setting ",(0,o.jsx)(e.code,{children:"color"})," in the above example to something new while it was in the middle of animating would require 250 ms to get from the intermediate value to the new value specified."]})}),"\n",(0,o.jsx)(e.h2,{id:"animation-lifecycle",children:"Animation lifecycle"}),"\n",(0,o.jsxs)(e.p,{children:["All animations result in an ",(0,o.jsx)(c.F.Animation,{})," instance being created to track their lifecycle. This type implements ",(0,o.jsx)(e.code,{children:"Completable"}),", which means it notifies listeners when it is ",(0,o.jsx)(e.code,{children:"completed"})," or ",(0,o.jsx)(e.code,{children:"canceled"}),". You can register to be notified of these state changes as follows:"]}),"\n",(0,o.jsx)(m.v,{children:E}),"\n",(0,o.jsxs)(e.p,{children:["Doodle provides the ",(0,o.jsx)(e.code,{children:"autoCanceling"})," property delegate to automatically cancel ",(0,o.jsx)(e.code,{children:"Completable"})," instances when a new value is assigned to them. This is useful for animations as well."]}),"\n",(0,o.jsx)(m.v,{children:B}),"\n",(0,o.jsx)(e.h2,{id:"animating-custom-data",children:"Animating custom data"}),"\n",(0,o.jsx)(e.p,{children:"It is possible to animate custom data in addition to the built-in types that Doodle offers. The simplest case is when you have some data that can be represented numerically. These data types can be used directly in tween, keyFrame and other existing animation types as long as you provide logic to convert them to and from their numeric form."}),"\n",(0,o.jsx)(e.h3,{id:"numeric-conversion",children:"Numeric conversion"}),"\n",(0,o.jsxs)(e.p,{children:["You can animate data that is convertible to and from numbers using either ",(0,o.jsx)(c.F.SingleDataConverter,{})," or ",(0,o.jsx)(c.F.MultiDataConverter,{}),". These support single and multi-dimensional data respectively. These converters define how a type is mapped to and from a ",(0,o.jsx)(e.code,{children:"Double"})," or ",(0,o.jsx)(e.code,{children:"Array<Double>"}),"."]}),"\n",(0,o.jsx)(e.mermaid,{value:"sequenceDiagram\n    autonumber\n    participant a as App\n    participant f as Framework\n    participant c as *DataConverter\n\n    a->>f : animate(...)\n    loop\n        f->>c : serialize(...)\n        f->>f : animate numeric value\n        f->>c : deserialize(...)\n        f->>a : animation(...) { value -> ... }\n    end"}),"\n",(0,o.jsx)(e.p,{children:"Simply implement a custom converter and provide it to one of the generic animation builders as follows:"}),"\n",(0,o.jsx)(m.v,{children:P}),"\n",(0,o.jsx)(e.admonition,{type:"info",children:(0,o.jsxs)(e.p,{children:["Doodle has several built-in ",(0,o.jsx)(c.F.AnimationConverters,{})," that use this technique to animate several common data types."]})}),"\n",(0,o.jsx)(e.h3,{id:"non-numeric-data",children:"Non-numeric data"}),"\n",(0,o.jsxs)(e.p,{children:["The ",(0,o.jsx)(c.F.Animator,{})," interface actually works with a lower-level definition of an animation than those used for numeric data. This interface is the entry point for truly custom data that cannot be converted to numeric form. Doodle currently does not have any use cases like this, but the API is there in case applications have a need."]}),"\n",(0,o.jsxs)(e.p,{children:["See the ",(0,o.jsx)(c.F.AnimationPlan,{})," for more details."]})]})}function V(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(N,{...n})}):N(n)}function Y(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}},8030:(n,e,i)=>{i.d(e,{Ay:()=>m,RM:()=>s});var a=i(4848),o=i(8453),t=i(5537),r=i(9329),l=i(4069);const s=[];function d(n){const e={admonition:"admonition",p:"p",strong:"strong",...(0,o.R)(),...n.components};return(0,a.jsxs)(e.admonition,{title:"Library Required",type:"info",children:[(0,a.jsxs)("p",{children:["You will need to add the ",n.link," library to your app's dependencies."]}),(0,a.jsxs)(t.A,{groupId:"language",children:[(0,a.jsxs)(r.A,{value:"Kotlin",children:[(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"build.gradle.kts"})}),(0,a.jsx)(l.v,{children:n.kotlin})]}),(0,a.jsxs)(r.A,{value:"Groovy",children:[(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"build.gradle"})}),(0,a.jsx)(l.v,{children:n.groovy})]})]})]})}function m(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},8968:(n,e,i)=>{i.d(e,{A:()=>a});const a="package io.nacular.doodle.docs.apps\n\nimport io.nacular.doodle.animation.Animation\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.transition.easeOutBounce\nimport io.nacular.doodle.animation.tween\nimport io.nacular.doodle.animation.tweenDouble\nimport io.nacular.doodle.animation.tweenPoint\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.height\nimport io.nacular.doodle.core.renderProperty\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.core.width\nimport io.nacular.doodle.docs.utils.controlBackgroundColor\nimport io.nacular.doodle.drawing.AffineTransform.Companion.Identity\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.Color.Companion.Lightgray\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.drawing.opacity\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.event.PointerListener.Companion.on\nimport io.nacular.doodle.geometry.Circle\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.geometry.Vector3D\nimport io.nacular.doodle.geometry.circumference\nimport io.nacular.doodle.geometry.inset\nimport io.nacular.doodle.geometry.lineTo\nimport io.nacular.doodle.geometry.path\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.layout.constraints.fill\nimport io.nacular.doodle.utils.autoCanceling\nimport io.nacular.measured.units.Angle.Companion.acos\nimport io.nacular.measured.units.Angle.Companion.degrees\nimport io.nacular.measured.units.Time.Companion.seconds\nimport io.nacular.measured.units.times\nimport kotlin.math.PI\nimport kotlin.math.cos\nimport kotlin.math.sqrt\n\nclass AnimationChainingApp(private val display: Display, private val animate: Animator): Application {\n    private class Wheel: View() {\n        val radius        get() =  circle.radius + thickness / 2\n        val circumference get() =  2 * PI * radius\n        var bottom        get() = position + Point(radius, 2 * radius); set(new) {\n            suggestPosition(new - Point(radius, 2 * radius))\n        }\n        var rotation           by renderProperty(0 * degrees)\n\n        private val thickness        =  20.0\n        private val dashLength get() =  circle.circumference / 8\n        private val circle     get() = Circle(\n            center = Point(width, height) / 2.0,\n            radius = minOf(width/2, height/2) - thickness / 2\n        )\n\n        override fun contains(point: Point) = false\n\n        override fun render(canvas: Canvas) {\n            val c = circle\n            val d = dashLength\n\n            canvas.circle(c.inset(-thickness / 2 + 0.5), Stroke(Lightgray))\n            canvas.circle(c.inset( thickness / 2      ), Stroke(Lightgray))\n\n            canvas.rotate(around = Point(radius, radius), by = rotation) {\n            circle(\n                c,\n                Stroke(\n                    color     = Color.Blue,\n                    dashes    = doubleArrayOf(d, d),\n                    thickness = thickness,\n                )\n            )}\n        }\n    }\n\n    private var animation: Animation<*>? by autoCanceling()\n\n    private val wheel        = Wheel().apply { suggestSize(Size(100)) }\n    private var rampBounds   = calculateRampBounds()\n    private val rollBounce   = easeOutBounce(0.15f)\n    private val fallDuration = 1 * seconds\n    private val rollDuration = 3 * seconds\n\n    init {\n        display += view {\n            + wheel\n\n            render = {\n                outerShadow(\n                    color      = Black opacity 0.05f,\n                    vertical   = -10.0,\n                    blurRadius =  10.0\n                ) {\n                    path(\n                        path(0.0, rampBounds.y)\n                            .lineTo(rampBounds.position                )\n                            .lineTo(rampBounds.right, rampBounds.bottom)\n                            .lineTo(0.0,              rampBounds.bottom)\n                            .finish(),\n                        White.paint\n                    )\n                }\n            }\n\n            pointerChanged += on(\n                entered = { startAnimation() },\n                pressed = { startAnimation() }\n            )\n\n            wheel.boundsChanged += { _,old,new ->\n                if (old.size != new.size) {\n                    rampBounds = calculateRampBounds()\n                    animation?.cancel()\n                    resetWheel()\n                    rerender()\n                }\n            }\n        }\n\n        display.fill(controlBackgroundColor.paint)\n\n        display.layout       = constrain(display.first(), fill)\n        display.sizeChanged += { _,_,_ ->\n            rampBounds = calculateRampBounds()\n            animation?.cancel()\n            resetWheel()\n        }\n    }\n\n    private fun resetWheel() {\n        wheel.bottom    = Point(wheel.radius, 2 * wheel.radius)\n        wheel.rotation  = 0 * degrees\n        wheel.transform = Identity\n    }\n\n    private fun startAnimation() {\n        resetWheel()\n\n        animation = animate {\n            val wheelBottomStart        = Point(wheel.radius, 2 * wheel.radius)\n            val rampLength              = sqrt(rampBounds.width * rampBounds.width + rampBounds.height * rampBounds.height)\n            val radiusLengthRatio       = wheel.radius / rampLength\n            val bottomYOffsetFromCenter = rampBounds.width  * radiusLengthRatio\n            val bottomXOffsetFromCenter = rampBounds.height * radiusLengthRatio\n            val bottomXOffsetWall       = wheel.radius + bottomXOffsetFromCenter\n            val bottomYOffsetFloor      = bottomXOffsetWall * rampBounds.height / rampBounds.width\n            val tippingPoint            = Identity.rotate(\n                around = Point(wheel.radius, rampBounds.y),\n                by     = acos(rampBounds.width / rampLength)\n            )(Point(wheel.radius, rampBounds.y - wheel.radius))\n\n            val wheelBottomEnd          = Point(\n                rampBounds.right  - bottomXOffsetWall  + bottomXOffsetFromCenter,\n                rampBounds.bottom - bottomYOffsetFloor - bottomYOffsetFromCenter + wheel.radius\n            )\n            val rollLength              = wheelBottomEnd distanceFrom wheelBottomStart\n            val rotations               = rollLength / wheel.circumference\n\n//sampleStart\n            wheelBottomStart to Point(wheel.radius, rampBounds.y) using (tweenPoint(easeOutBounce, fallDuration)) {\n                // (1) Ball falls and bounces\n                wheel.bottom = it\n            } then {\n                // (2) Then it slides down the hill and bounces off the wall, by animating x and deriving y\n                wheel.bottom.x to rampBounds.width using (tweenDouble(rollBounce, rollDuration)) { x ->\n                    wheel.bottom = Point(x, wheelBottomY(x, tippingPoint))\n                }\n\n                // (2) While rolling at the same time\n                0 * degrees to 360 * degrees * rotations using (tween(degrees, rollBounce, rollDuration)) {\n                    wheel.rotation = it\n                }\n            }\n//sampleEnd\n        }\n    }\n\n    /**\n     * Calculate the ball's bottom position to keep it on the ramp as it moves horizontally.\n     *\n     * The first phase of the move is the portion where the ball is rolling over the edge.\n     * Then it transitions to normal linear motion.\n     */\n    private fun wheelBottomY(centerX: Double, tippingPoint: Vector3D) = when {\n        centerX < tippingPoint.x -> rampBounds.y - wheel.radius * cos((centerX - wheel.radius) / wheel.radius)\n        else                     -> tippingPoint.y + (centerX - tippingPoint.x) * rampBounds.height / rampBounds.width\n    } + wheel.radius\n\n    private fun calculateRampBounds() = Rectangle(\n        x      = wheel.radius,\n        y      = display.height / 2,\n        width  = display.width - wheel.radius,\n        height = display.height / 2\n    )\n\n    override fun shutdown() {\n        animation?.cancel()\n    }\n}"}}]);