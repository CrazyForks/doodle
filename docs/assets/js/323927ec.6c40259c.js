"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[921],{7034:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>p,default:()=>m,frontMatter:()=>s,metadata:()=>d,toc:()=>h});var i=n(7462),o=(n(7294),n(3905)),a=(n(8209),n(5488)),r=n(5162),l=n(4903);const s={title:"Overview"},p="Pointer Input",d={unversionedId:"pointer_input/overview",id:"pointer_input/overview",title:"Overview",description:"Pointer handling is easy with Doodle. The first thing you need to do is include the PointerModule",source:"@site/docs/pointer_input/overview.mdx",sourceDirName:"pointer_input",slug:"/pointer_input/overview",permalink:"/doodle/docs/pointer_input/overview",draft:!1,tags:[],version:"current",frontMatter:{title:"Overview"},sidebar:"tutorialSidebar",previous:{title:"Behaviors",permalink:"/doodle/docs/rendering/behaviors"},next:{title:"Pointer Motion Events",permalink:"/doodle/docs/pointer_input/pointermotion"}},c={},h=[{value:"Hit Detection",id:"hit-detection",level:2},{value:"Support For Transforms",id:"support-for-transforms",level:3},{value:"Pointer Listeners",id:"pointer-listeners",level:2},{value:"Pointer Event",id:"pointer-event",level:2},{value:"Event Bubbling",id:"event-bubbling",level:2},{value:"Event Filtering",id:"event-filtering",level:2}],u={toc:h};function m(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"pointer-input"},"Pointer Input"),(0,o.kt)("p",null,"Pointer handling is easy with Doodle. The first thing you need to do is include the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Browser/src/jsMain/kotlin/io/nacular/doodle/application/Modules.kt#L51"},(0,o.kt)("inlineCode",{parentName:"a"},"PointerModule")),"\nwhen launching your app. The underlying framework uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"PointerModule")," to produce pointer events."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Doodle uses opt-in modules like this to improve bundle size.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"class MyApp(display: Display): Application {\n    // pointer events will fire for this app when launched with\n    // the PointerModule\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'import io.nacular.doodle.application.Modules.Companion.PointerModule\n\nfun main () {\n    // "full screen" launch with pointer support\n    application(modules = listOf(PointerModule)) {\n        MyApp(display = instance())\n    }\n}\n')),(0,o.kt)("h2",{id:"hit-detection"},"Hit Detection"),(0,o.kt)("p",null,"The framework relies on the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Core/src/commonMain/kotlin/io/nacular/doodle/core/View.kt#L450"},(0,o.kt)("inlineCode",{parentName:"a"},"View.contains(Point)")),"\nmethod to determine when the pointer is within a View's boundaries."),(0,o.kt)("p",null,"The default implementation just checks the point against ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Core/src/commonMain/kotlin/io/nacular/doodle/core/View.kt#L108"},(0,o.kt)("inlineCode",{parentName:"a"},"bounds")),".\nHowever, more complex hit detection can be used to customize pointer handling."),(0,o.kt)(a.Z,{mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"demo",label:"Demo",mdxType:"TabItem"},(0,o.kt)(l.l,{functionName:"hitDetection",height:"250",mdxType:"DoodleApp"})),(0,o.kt)(r.Z,{value:"code",label:"Code",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"import io.nacular.doodle.geometry.Circle\n\nclass CircularView(val radius: Double): View() {\n    private val circle = Circle(radius)\n\n    override fun intersects(point: Point) = point - position in circle\n\n    override fun render(canvas: Canvas) {\n        canvas.circle(circle, Red.paint)\n    }\n}\n")),(0,o.kt)("p",null,"This view renders a circle and provides precise hit detection for it."))),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"The contains check passes a point within the View's parent coordinate system (or the ",(0,o.kt)("a",{parentName:"p",href:"/doodle/docs/display/overview#the-display-is-an-apps-root-container"},(0,o.kt)("strong",{parentName:"a"},"Display")),"'s for\ntop-level Views).")),(0,o.kt)("h3",{id:"support-for-transforms"},"Support For Transforms"),(0,o.kt)("p",null,"Doodle also accounts for transformations applied to the View's ancestors when delivering pointer events. This means the View will receive the right notification\nwhenever the pointer intersects its parent despite transformations. Hit detection logic in the View is then triggered as usual. The View still needs to take\nits own transformation into account though, since the given point used in hit detection is within the parent coordinate space. This is automatically handled if the\nView implements ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Core/src/commonMain/kotlin/io/nacular/doodle/core/View.kt#L824"},(0,o.kt)("inlineCode",{parentName:"a"},"intersects(Point)"))," or if\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Core/src/commonMain/kotlin/io/nacular/doodle/core/View.kt#L856"},(0,o.kt)("inlineCode",{parentName:"a"},"toLocal"))," is used when overriding ",(0,o.kt)("inlineCode",{parentName:"p"},"contains"),"."),(0,o.kt)(a.Z,{mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"demo",label:"Demo",mdxType:"TabItem"},(0,o.kt)(l.l,{functionName:"hitDetectionTransform",height:"500",mdxType:"DoodleApp"})),(0,o.kt)(r.Z,{value:"code",label:"Code",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"class TriangleView: View() {\n    private val outerPoly get() = ConvexPolygon(Point(width / 2, 0), Point(width, height), Point(0, height))\n    private val innerPoly get() = outerPoly.reversed().let {\n        Identity.scale(around = Point(width / 2, height * 2 / 3), x = 0.5, y = 0.5).invoke(it)\n    }\n\n    private var pointerOver by renderProperty(false)\n\n    init {\n        pointerChanged += entered { pointerOver = true  }\n        pointerChanged += exited  { pointerOver = false }\n    }\n\n    override fun intersects(point: Point) = (point - position).let {\n        it in outerPoly && it !in innerPoly\n    }\n\n    override fun render(canvas: Canvas) {\n        canvas.path(outerPoly.toPath() + innerPoly.toPath(), fill = if (pointerOver) Black.paint else White.paint)\n    }\n}\n")),(0,o.kt)("p",null,"This view renders a circle and provides precise hit detection for it."))),(0,o.kt)("h2",{id:"pointer-listeners"},"Pointer Listeners"),(0,o.kt)("p",null,"Views are able to receive pointer events once the ",(0,o.kt)("inlineCode",{parentName:"p"},"PointerModule")," is loaded, they are ",(0,o.kt)("inlineCode",{parentName:"p"},"visible")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"enabled"),". You can\nthen attach a ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Core/src/commonMain/kotlin/io/nacular/doodle/event/PointerListener.kt#L3"},(0,o.kt)("inlineCode",{parentName:"a"},"PointerListener")),"\nto any View and get notified."),(0,o.kt)("p",null,"Pointer listeners are notified whenever a pointer:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Enters")," a View"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Pressed")," within a View"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Released")," within a View"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Clicked")," (Pressed then Released) within a View"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Exits")," a View")),(0,o.kt)("p",null,"You get these notifications by registering with a View's ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Core/src/commonMain/kotlin/io/nacular/doodle/core/View.kt#L294"},(0,o.kt)("inlineCode",{parentName:"a"},"pointerChanged")),"\nproperty."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"view.pointerChanged += object: PointerListener {\n    override fun pressed(event: PointerEvent) {\n        // ..\n    }\n}\n")),(0,o.kt)("p",null,"There are also short-hand functions for cases where you only consume one of the events."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"view.pointerChanged += pressed { event ->\n    // ..\n}\n")),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Core/src/commonMain/kotlin/io/nacular/doodle/event/PointerListener.kt#L3"},(0,o.kt)("inlineCode",{parentName:"a"},"PointerListener")),"\nhas no-op defaults for each event, so you only need to implement the ones you need.")),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Notice that ",(0,o.kt)("inlineCode",{parentName:"p"},"pointerChanged"),"--like other observable properties--supports many observers and enables you to add/remove an observer any time.")),(0,o.kt)("h2",{id:"pointer-event"},"Pointer Event"),(0,o.kt)("p",null,"The event provided to ",(0,o.kt)("inlineCode",{parentName:"p"},"PointerListener"),"s carries information about the View it originated from (",(0,o.kt)("inlineCode",{parentName:"p"},"target"),"), the View it is sent to (",(0,o.kt)("inlineCode",{parentName:"p"},"source"),"),\nvarious attributes about the state of the pointers--like buttons pressed--and their locations relative to the target View."),(0,o.kt)("p",null,"Pointer events are ",(0,o.kt)("strong",{parentName:"p"},"consumable"),". This means any observer can call ",(0,o.kt)("inlineCode",{parentName:"p"},"consume()")," on an event and prevent subsequent\nlisteners from receiving it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"// ...\noverride fun pressed(event: PointerEvent) {\n    // ... take action based on event\n\n    event.consume() // indicate that no other listeners should be notified\n}\n// ..\n")),(0,o.kt)("h2",{id:"event-bubbling"},"Event Bubbling"),(0,o.kt)("p",null,'Pointer events "bubble" up to ancestors of a View. Events sent to a View will also be sent up to its parent and so on.\nThis means you can listen to all events that happen to the descendants of a View.'),(0,o.kt)("p",null,"The event sent to a parent is slightly different from the one sent to the View. These events continue to have the same ",(0,o.kt)("inlineCode",{parentName:"p"},"target"),"\n(descendant View where the event fired), but their ",(0,o.kt)("inlineCode",{parentName:"p"},"source")," changes to the recipient ancestor as they bubble."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Bubbling is canceled if any listener calls ",(0,o.kt)("inlineCode",{parentName:"p"},"consume"))),(0,o.kt)("h2",{id:"event-filtering"},"Event Filtering"),(0,o.kt)("p",null,'Pointer events also "sink" from ancestors down to their target. The first phase of pointer event handling is the "sink" phase. It runs ',(0,o.kt)("strong",{parentName:"p"},"before"),' the "bubbling" phase.\nThe root ancestor and all descendants toward the ',(0,o.kt)("inlineCode",{parentName:"p"},"target")," View are notified of the event before the target is."),(0,o.kt)("p",null,'The filter phase is like the "bubbling" phase in reverse. Like with bubbling, ',(0,o.kt)("inlineCode",{parentName:"p"},"PointerListener"),' is used to handle the event. Unlike\n"bubbling", registration happens via the ',(0,o.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Core/src/commonMain/kotlin/io/nacular/doodle/core/View.kt#L289"},(0,o.kt)("inlineCode",{parentName:"a"},"pointerFilter")),'\nproperty. This phase lets ancestors "veto" an event before it reaches the intended target.'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"view.pointerFilter += object: PointerListener {\n    // called whenever a pointer is pressed on this\n    // View or its children, before the target child\n    // is notified\n    override fun pressed(event: PointerEvent) {\n        // ..\n    }\n}\n")),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Calling ",(0,o.kt)("inlineCode",{parentName:"p"},"consume")," during filter will prevent descendants (and the target) from receiving the event")))}m.isMDXComponent=!0}}]);