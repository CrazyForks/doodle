"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[9952],{5400:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>x,contentTitle:()=>g,default:()=>v,frontMatter:()=>y,metadata:()=>f,toc:()=>A});var o=i(7624),a=i(2172),t=i(1268),l=i(5388),p=i(5720),s=i(7996),d=i(3148);const r="package io.nacular.doodle.docs.apps.nesting\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.controls.ColorPicker\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.docs.utils.doodleColor\nimport io.nacular.doodle.drawing.opacity\nimport io.nacular.doodle.layout.Insets\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.layout.constraints.fill\n\n//sampleStart\nclass InnerApp(display: Display): Application {\n    init {\n        // Shows a color picker\n        display += ColorPicker(doodleColor opacity 0.75f).apply {\n            changed += { _,_,new -> println(new) }\n        }\n\n        // The picker grows with the display, but is inset a little\n        display.layout = constrain(display.first(), fill(insets = Insets(2.0)))\n    }\n\n    override fun shutdown() {}\n}\n//sampleEnd",c="package io.nacular.doodle.docs.apps.nesting\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.application.ApplicationViewFactory\nimport io.nacular.doodle.application.Modules.Companion.PointerModule\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.center\nimport io.nacular.doodle.core.height\nimport io.nacular.doodle.core.width\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.geometry.centered\nimport io.nacular.doodle.utils.Resizer\nimport org.kodein.di.instance\nimport kotlin.math.min\n\n//sampleStart\nclass OuterApp(display: Display, appView: ApplicationViewFactory): Application {\n    init {\n        // NOTE: Any module needed by InnerApp MUST be provided to the factory.\n        // PointerModule used here to enable interaction with the color picker.\n        display += appView(modules = listOf(PointerModule)) {\n            InnerApp(display = instance()) // Init inner app\n        }.apply {\n            bounds = Rectangle(\n                min(400.0, display.width  - 20),\n                min(300.0, display.height - 20)\n            ).centered(at = display.center)\n\n            Resizer(this).apply { movable = false }\n        }\n\n        display.fill(White.paint)\n    }\n\n    override fun shutdown() {}\n}\n//sampleEnd",h="package outerapp\n\nimport io.nacular.doodle.application.ApplicationViewFactory.Companion.AppViewModule\nimport io.nacular.doodle.application.Modules.Companion.PointerModule\nimport io.nacular.doodle.application.application\nimport io.nacular.doodle.docs.apps.nesting.OuterApp\nimport org.kodein.di.instance\n\nfun main() {\n//sampleStart\n    // NOTE: Modules used by the outer app are not available to the inner one.\n    // The PointerModule is used here to allow resizing of the View that holds the inner app.\n    application(modules = listOf(AppViewModule, PointerModule)) {\n        OuterApp(display = instance(), appView = instance())\n    }\n//sampleEnd\n}\n",u='import io.nacular.doodle.application.Application\n\n//sampleStart\nclass UsefulApp: Application {\n    init {\n        println("Hi!")\n    }\n\n    override fun shutdown() {}\n}\n//sampleEnd',m='package applications\n\nimport io.nacular.doodle.application.Modules.Companion.PointerModule\nimport io.nacular.doodle.application.application\nimport org.kodein.di.DI.Module\nimport org.kodein.di.instance\n\n//sampleStart\nfun main() {\n    application(modules = listOf(\n        PointerModule,\n        // ...,\n        Module(name = "A Custom Module") {\n            // custom Kodein bind statements\n        },\n        /*...*/)) {\n        MyApp(instance())\n    }\n}\n//sampleEnd',w="package usefulapp\n\nimport UsefulApp\nimport io.nacular.doodle.application.application\n\n//sampleStart\nfun main() {\n    // launch full-screen\n    application {\n        UsefulApp()\n    }\n}\n//sampleEnd",y={hide_title:!0,title:"Applications"},g=void 0,f={id:"applications",title:"Applications",description:"Applications",source:"@site/docs/applications.mdx",sourceDirName:".",slug:"/applications",permalink:"/doodle/docs/applications",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{hide_title:!0,title:"Applications"},sidebar:"tutorialSidebar",previous:{title:"Whats new in Doodle",permalink:"/doodle/docs/whatsnew"},next:{title:"Views",permalink:"/doodle/docs/views"}},x={},A=[{value:"Applications",id:"applications",level:2},{value:"Launching an application",id:"launching-an-application",level:2},{value:"Top-level applications",id:"top-level-applications",level:2},{value:"Nested applications (Web)",id:"nested-applications-web",level:2},{value:"Modularity",id:"modularity",level:2}];function j(n){const e={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",p:"p",strong:"strong",...(0,a.M)(),...n.components};return d||b("api",!1),d.AppViewModule||b("api.AppViewModule",!0),d.Application||b("api.Application",!0),d.ApplicationLaunch||b("api.ApplicationLaunch",!0),d.ApplicationViewFactory||b("api.ApplicationViewFactory",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h2,{id:"applications",children:"Applications"}),"\n",(0,o.jsxs)(e.p,{children:["All Doodle apps run within an ",(0,o.jsx)(d.Application,{}),". It is the entry-point for your business logic, and often the first class you write. Doodle fully initializes your app at constructor time, so there is no additional ",(0,o.jsx)(e.em,{children:"run"})," or ",(0,o.jsx)(e.em,{children:"start"})," method to implement. You can provide custom tear-down logic via the ",(0,o.jsx)(e.code,{children:"shutdown"})," method though."]}),"\n",(0,o.jsx)(p.A,{children:u}),"\n",(0,o.jsx)(e.h2,{id:"launching-an-application",children:"Launching an application"}),"\n",(0,o.jsxs)(e.p,{children:["You can either launch an app ",(0,o.jsx)(e.strong,{children:"top-level"}),", or ",(0,o.jsx)(e.strong,{children:"nested"})," within another app. The Application class does not change regardless of the launch mode. That is because apps have no knowledge of the mode they will run in, making them independent of platform concepts by default."]}),"\n",(0,o.jsx)(e.admonition,{type:"tip",children:(0,o.jsx)(e.p,{children:"App launch is platform-specific, allowing apps to customize their setup based on this context."})}),"\n",(0,o.jsx)(e.h2,{id:"top-level-applications",children:"Top-level applications"}),"\n",(0,o.jsxs)(e.p,{children:["Most apps will run independent of others and exist purely within the context of a page, or element within it (for Web apps). Use the ",(0,o.jsx)(d.ApplicationLaunch,{})," function to launch apps this way. The result is a full-screen experience by default, with the app taking up the entire page and control all aspects of it. You can also provide an HTML element when launching a top-level Web app. This allows you to host Doodle apps in non-Doodle contexts. The apps in this documentation are top-level within specific elements."]}),"\n",(0,o.jsxs)(e.p,{children:["Closing the page cleans up any apps within it. Removing the element hosting an app or explicitly calling ",(0,o.jsx)(e.code,{children:"shutdown"})," has the same effect."]}),"\n",(0,o.jsx)(p.A,{children:w}),"\n",(0,o.jsx)(e.h2,{id:"nested-applications-web",children:"Nested applications (Web)"}),"\n",(0,o.jsxs)(e.p,{children:["Doodle Web apps can also be run within other Doodle Web apps. This is done by placing the nested app in a ",(0,o.jsx)(e.a,{href:"/doodle/docs/views",children:(0,o.jsx)(e.strong,{children:"View"})})," that the host app manages. An app launched this way has the same functionality as a top-level one. Its lifecycle however, is tied to the host View."]}),"\n",(0,o.jsxs)(e.p,{children:["You simply use an ",(0,o.jsx)(d.ApplicationViewFactory,{})," (available via the ",(0,o.jsx)(d.AppViewModule,{}),") to create nested apps."]}),"\n",(0,o.jsx)(s.u,{functionName:"nestedApp",height:"400"}),"\n",(0,o.jsxs)(t.c,{children:[(0,o.jsx)(l.c,{value:"Inner App",children:(0,o.jsx)(p.A,{children:r})}),(0,o.jsx)(l.c,{value:"Outer App",children:(0,o.jsx)(p.A,{children:c})}),(0,o.jsx)(l.c,{value:"Outer App Launcher",children:(0,o.jsx)(p.A,{children:h})})]}),"\n",(0,o.jsx)(e.admonition,{type:"tip",children:(0,o.jsxs)(e.p,{children:["Adding a nested app's View to the ",(0,o.jsx)(e.a,{href:"/doodle/docs/display",children:(0,o.jsx)(e.strong,{children:"Display"})})," triggers the app's initialization. Shutdown the app by removing the host View from the Display."]})}),"\n",(0,o.jsx)(e.h2,{id:"modularity",children:"Modularity"}),"\n",(0,o.jsxs)(e.p,{children:["Doodle uses ",(0,o.jsx)(e.a,{href:"https://en.wikipedia.org/wiki/Dependency_injection",children:"dependency injection"})," when creating apps. The lambda provided when launching an app is actually a ",(0,o.jsx)(e.a,{href:"https://github.com/Kodein-Framework/Kodein-DI",children:"Kodein"})," binding context that lets you inject instances from Doodle modules, or your own."]}),"\n",(0,o.jsx)(p.A,{children:m})]})}function v(n={}){const{wrapper:e}={...(0,a.M)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(j,{...n})}):j(n)}function b(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);