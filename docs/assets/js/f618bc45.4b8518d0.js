"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[615],{8203:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>k,contentTitle:()=>y,default:()=>v,frontMatter:()=>m,metadata:()=>g,toc:()=>w});var o=t(7462),i=(t(7294),t(3905)),a=(t(8209),t(4866)),l=t(5162),r=t(4903),s=t(1912),d=t(1166);const u="import io.nacular.doodle.core.container\nimport io.nacular.doodle.layout.HorizontalFlowLayout\n\nfun horizontalLayout() {\n//sampleStart\n    val container = container {}\n\n    container.layout = HorizontalFlowLayout() // Container exposes its layout\n//sampleEnd\n}",c="import io.nacular.doodle.core.Layout\nimport io.nacular.doodle.core.PositionableContainer\nimport io.nacular.doodle.geometry.Rectangle\n\n//sampleStart\nclass CustomLayout: Layout {\n    override fun layout(container: PositionableContainer) {\n        container.children.filter { it.visible }.forEach { child ->\n            child.bounds = Rectangle(/*...*/)\n        }\n    }\n}\n//sampleEnd",h="\nimport io.nacular.doodle.core.Layout.Companion.simpleLayout\nimport io.nacular.doodle.core.container\nimport io.nacular.doodle.docs.utils.BlueView\nimport io.nacular.doodle.drawing.Color.Companion.Lightgray\nimport io.nacular.doodle.drawing.lighter\nimport io.nacular.doodle.drawing.rect\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.utils.Resizer\n\nfun unresponsiveLayout() {\n//sampleStart\n    container {\n        repeat(2) {\n            this += BlueView().apply { size = Size(50) }\n        }\n\n        // This Layout does not override\n        // requiresLayout(\n        //     child: Positionable,\n        //     of   : PositionableContainer,\n        //     old  : SizePreferences,\n        //     new  : SizePreferences\n        // ): Boolean\n        // Which means it defaults to ignoring changes to child SizePreferences\n        layout = simpleLayout { container ->\n            var x = 0.0\n            container.children.forEach {\n                it.x = x\n                x += (it.idealSize?.width ?: it.width) + 1\n            }\n        }\n\n        size = Size(200)\n        render = {\n            rect(bounds.atOrigin, Lightgray.lighter())\n        }\n\n        Resizer(this)\n    }\n//sampleEnd\n}",p="import io.nacular.doodle.core.Layout\nimport io.nacular.doodle.core.Positionable\nimport io.nacular.doodle.core.PositionableContainer\nimport io.nacular.doodle.core.View.SizePreferences\nimport io.nacular.doodle.core.container\nimport io.nacular.doodle.docs.utils.BlueView\nimport io.nacular.doodle.drawing.Color.Companion.Lightgray\nimport io.nacular.doodle.drawing.lighter\nimport io.nacular.doodle.drawing.rect\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.utils.Resizer\n\nfun responsiveLayout(updateOnIdealChange: Boolean) {\n//sampleStart\n    container {\n        repeat(2) {\n            this += BlueView().apply { size = Size(50) }\n        }\n\n        layout = object: Layout {\n            // Request layout whenever a child's idealSize changes\n            // (and the updateOnIdealChange switch is tuned on)\n            override fun requiresLayout(\n                child: Positionable,\n                of   : PositionableContainer,\n                old  : SizePreferences,\n                new  : SizePreferences\n            ) = updateOnIdealChange && old.idealSize != new.idealSize\n\n            // This Layout is very unusual (b/c it is contrived) in that it does not depend\n            // on the container's size. So it ignores these changes.\n            override fun requiresLayout(container: PositionableContainer, old: Size, new: Size) = false\n\n            override fun layout(container: PositionableContainer) {\n                var x = 0.0\n                container.children.forEach {\n                    it.x = x\n                    x += (it.idealSize?.width ?: it.width) + 1\n                }\n            }\n        }\n\n        size   = Size(200)\n        render = {\n            rect(bounds.atOrigin, Lightgray.lighter())\n        }\n\n        Resizer(this)\n    }\n//sampleEnd\n}",m={hide_title:!0},y="Using Layouts",g={unversionedId:"layout/layouts",id:"layout/layouts",title:"Using Layouts",description:"A  keeps track of a View and its children and automatically arranges the children as sizes change. This happens (by default) whenever View's  changes, or one of its children has its  change.",source:"@site/docs/layout/layouts.mdx",sourceDirName:"layout",slug:"/layout/layouts",permalink:"/doodle/docs/layout/layouts",draft:!1,tags:[],version:"current",frontMatter:{hide_title:!0},sidebar:"tutorialSidebar",previous:{title:"Positioning",permalink:"/doodle/docs/layout/overview"},next:{title:"Constraints",permalink:"/doodle/docs/layout/constraints"}},k={},w=[{value:"Custom Layouts",id:"custom-layouts",level:2},{value:"Deciding When Layout Happens",id:"deciding-when-layout-happens",level:2}],f={toc:w},b="wrapper";function v(e){let{components:n,...t}=e;return(0,i.kt)(b,(0,o.Z)({},f,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"using-layouts"},"Using Layouts"),(0,i.kt)("p",null,"A ",(0,i.kt)(d.Ar2,null)," keeps track of a View and its children and automatically arranges the children as sizes change. This happens (by default) whenever View's ",(0,i.kt)(d.du0,null)," changes, or one of its children has its ",(0,i.kt)(d.fzW,null)," change."),(0,i.kt)("p",null,"The View class also ",(0,i.kt)("inlineCode",{parentName:"p"},"protects")," its ",(0,i.kt)(d.LJJ,null)," property from callers, but sub-classes are free to expose it."),(0,i.kt)(s.O,{mdxType:"KPlayground"},u),(0,i.kt)(r.l,{functionName:"flowLayout",height:"400",mdxType:"DoodleApp"}),(0,i.kt)("p",null,(0,i.kt)(d.MZO,null)," wraps a View's children from left to right within its bounds."),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Changes to a View's ",(0,i.kt)(d.X8Q,null)," will not trigger layout.")),(0,i.kt)("h2",{id:"custom-layouts"},"Custom Layouts"),(0,i.kt)("p",null,"Doodle comes with several useful layouts, including one based on constraints. You can also create custom Layouts very easily. Just implement the ",(0,i.kt)(d.Ar2,null)," interface:"),(0,i.kt)(s.O,{mdxType:"KPlayground"},c),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)(d.Ar2,null)," works with ",(0,i.kt)(d._UE,null)," instead of ",(0,i.kt)(d.G7x,null)," directly because the latter does not expose its children by design."),(0,i.kt)("h2",{id:"deciding-when-layout-happens"},"Deciding When Layout Happens"),(0,i.kt)("p",null,"Layouts are generally triggered whenever their container's size changes or a child of their container has a bounds change. But there are cases when this default behavior does not work as well. A good example is a ",(0,i.kt)("inlineCode",{parentName:"p"},"Layout")," that uses a child's ",(0,i.kt)(d.Q5B,null)," in positioning. Such a ",(0,i.kt)("inlineCode",{parentName:"p"},"Layout")," won't be invoked when a child's ",(0,i.kt)(d.Q5B,null)," changes, and will be out of date in some cases. The following demo shows this."),(0,i.kt)(a.Z,{mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,i.kt)(r.l,{functionName:"layoutIdealIssue",height:"400",mdxType:"DoodleApp"})),(0,i.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,i.kt)(s.O,{mdxType:"KPlayground"},h))),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Moving the slider changes the ideal width of the blue boxes. But the container isn't updated because the ",(0,i.kt)("inlineCode",{parentName:"p"},"Layout")," used does not indicate (via  ",(0,i.kt)(d.Ybd,null),") it needs an updated when a View's ",(0,i.kt)(d.Q0D,null)," change."),(0,i.kt)("p",{parentName:"admonition"},"You can see that it is out of date by resizing the container after moving the slider.")),(0,i.kt)("p",null,"This is why Doodle offers a ",(0,i.kt)(d.Ar2,null)," the chance to customize when they are invoked. In fact, Layouts are asked whether they want to respond to several potential triggers. These include ",(0,i.kt)(d.du0,null)," changes in the container, ",(0,i.kt)(d.fzW,null)," and ",(0,i.kt)(d.Q0D,null)," changes for children. The latter happens whenever ",(0,i.kt)("inlineCode",{parentName:"p"},"minimumSize")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"idealSize")," are updated for a child. This way, a ",(0,i.kt)("inlineCode",{parentName:"p"},"Layout")," can fine tune what triggers it."),(0,i.kt)("p",null,"The following shows how updating the ",(0,i.kt)("inlineCode",{parentName:"p"},"Layout")," so it replies to ",(0,i.kt)(d.Ybd,null)," for this scenario fixes the issue."),(0,i.kt)(a.Z,{mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,i.kt)(r.l,{functionName:"layoutIdealIssue",args:"[true]",height:"400",mdxType:"DoodleApp"})),(0,i.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,i.kt)(s.O,{mdxType:"KPlayground"},p))),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Notice that this ",(0,i.kt)("inlineCode",{parentName:"p"},"Layout")," will actually ignore changes to the container's ",(0,i.kt)("inlineCode",{parentName:"p"},"size"),"! Layouts are free to do that if the container's ",(0,i.kt)("inlineCode",{parentName:"p"},"size")," is irrelevant to the positioning of its children. This is very unlikely, but there might be cases where one dimension of ",(0,i.kt)("inlineCode",{parentName:"p"},"size"),", maybe ",(0,i.kt)("inlineCode",{parentName:"p"},"width")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"height")," is irrelevant. In which case the ",(0,i.kt)("inlineCode",{parentName:"p"},"Layout")," can ignore updates if only that component changes.")))}v.isMDXComponent=!0}}]);