"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[277],{999:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>d,metadata:()=>m,toc:()=>u});var n=o(7462),a=(o(7294),o(3905)),i=(o(8209),o(5488)),l=o(5162),r=o(4903);const d={hide_title:!0},s="Forms",m={unversionedId:"ui_components/form",id:"ui_components/form",title:"Forms",description:"Doodle forms make data collection simple, while still preserving flexibility to build just the right experience. They hide a lot of the",source:"@site/docs/ui_components/form.mdx",sourceDirName:"ui_components",slug:"/ui_components/form",permalink:"/doodle/docs/ui_components/form",draft:!1,tags:[],version:"current",frontMatter:{hide_title:!0},sidebar:"tutorialSidebar",previous:{title:"Catalog",permalink:"/doodle/docs/ui_components/overview"},next:{title:"Form Controls",permalink:"/doodle/docs/ui_components/form_controls"}},c={},u=[{value:"Like Constructors",id:"like-constructors",level:2},{value:"Creation",id:"creation",level:2},{value:"Fields",id:"fields",level:2},{value:"Field State",id:"field-state",level:3},{value:"Creating Fields",id:"creating-fields",level:3},{value:"Field Binding",id:"field-binding",level:3},{value:"Forms as Fields",id:"forms-as-fields",level:3},{value:"Layouts",id:"layouts",level:2}],p={toc:u};function h(e){let{components:t,...o}=e;return(0,a.kt)("wrapper",(0,n.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"forms"},"Forms"),(0,a.kt)("p",null,"Doodle forms make data collection simple, while still preserving flexibility to build just the right experience. They hide a lot of the\ncomplexity associated with mapping visual components to fields, state management, and validation. The result is an intuitive\nmetaphor modeled around the idea of a constructor."),(0,a.kt)("p",null,"Doodle also has a set of helpful forms controls that cover a reasonable range of data-types. These make its easy to create forms without\nmuch hassle. But there are bound to be cases where more customization is needed. This is why Doodle forms are also extensible, allowing\nyou to fully customize the data they bind to and how each fields is visualized."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"demo",label:"Demo",mdxType:"TabItem"},(0,a.kt)(r.l,{functionName:"form",height:"600",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"usage",label:"Usage",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'import io.nacular.doodle.controls.buttons.PushButton\nimport io.nacular.doodle.controls.form.Form\nimport io.nacular.doodle.controls.form.LabeledConfig\nimport io.nacular.doodle.controls.form.TextFieldConfig\nimport io.nacular.doodle.controls.form.form\nimport io.nacular.doodle.controls.form.labeled\nimport io.nacular.doodle.controls.form.map\nimport io.nacular.doodle.controls.form.radioList\nimport io.nacular.doodle.controls.form.textField\nimport io.nacular.doodle.controls.form.verticalLayout\n// ... other imports\n\nfun <T> LabeledConfig.textFieldConfig(placeHolder: String = "", errorText: StyledText? = null): TextFieldConfig<T>.() -> Unit = {\n    val initialHelperText  = help.styledText\n    help.font              = smallFont\n    textField.placeHolder  = placeHolder\n    onInvalid              = { if (!textField.hasFocus) help.styledText = errorText ?: it.message?.let { Red(it) } ?: help.styledText }\n    onValid                = { help.styledText = initialHelperText                                                                    }\n}\n\nval submit = PushButton("Submit").apply {\n    enabled = false\n    size    = Size(100, 32)\n}\n\nval twoDigitNumber = Regex("^1[0-5]\\\\d|^[1-9]\\\\d|^[1-9]")\n\nenum class Gender { Male, Female }\n\nval form = Form { this (\n    + labeled("Name", help = "3+ letters") {\n        textField(Regex(".{3,}"), config = textFieldConfig("Enter your name"))\n    },\n    + labeled("Age", help = "1 or 2 digit number") {\n        textField(twoDigitNumber, ToStringIntEncoder, config = textFieldConfig())\n    },\n    // Binding an initial value\n    Female to labeled("Gender") {\n        radioList(Male, Female) { spacing = 12.0 }\n    },\n    // Forms can be nested\n    + form<Pair<String, Int>> { this (\n        + labeled("Text [Sub-form]", help = "Can be blank") {\n            textField(Regex(".*"), config = textFieldConfig())\n        },\n        + labeled("Number [Sub-form]", help = "1 to 10") {\n            textField(twoDigitNumber, ToStringIntEncoder, validator = { it <= 10 }, config = textFieldConfig())\n        }\n    ) { first, second ->\n        first to second\n    }},\n    onInvalid = { submit.enabled = false },\n) { name, age, gender, pair ->\n    submit.enabled = true\n    println("[Form valid] Name: $name, Age: $age, Gender: $gender, Sub-form: $pair") // <---- check console for output\n}}.apply {\n    // configure the Form view itself\n    size      = Size(300, 100)\n    focusable = false\n    layout    = verticalLayout(this, spacing = 12.0, itemHeight = 32.0)\n}\n')))),(0,a.kt)("h2",{id:"like-constructors"},"Like Constructors"),(0,a.kt)("p",null,'Forms are very similar to constructors in that they have typed parameter lists (fields), and can only "create" instances when all their\ninputs are valid. Like any constructor, a Form can have optional fields, default values, and arbitrary types for its fields.'),(0,a.kt)("p",null,"While Forms behave like constructors in most ways, they do not actually create instances (only ",(0,a.kt)("a",{parentName:"p",href:"form#forms-as-fields"},"sub-forms")," do). This means they are not typed. Instead, they take\nfields and output a corresponding lists of strongly-typed data when all their fields are valid. This notification is intentionally general\nto allow forms to be used in a wide range of used cases."),(0,a.kt)("h2",{id:"creation"},"Creation"),(0,a.kt)("p",null,"Forms are created using the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Controls/src/commonMain/kotlin/io/nacular/doodle/controls/form/Form.kt#L244"},(0,a.kt)("inlineCode",{parentName:"a"},"Form")),' dsl function. This function ensures strong typing for fields and the form\'s "output".'),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"The Form returned from the builder does not expose anything about the data it produces. So all consumption logic goes in the\nbuilder block.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"\nval form = Form { this(\n    field1,\n    field2,\n    // ...\n    onInvalid = {\n        // called whenever any fields is updated with invalid data\n    }) { field1, field2, /*...*/ ->\n        // called each time all fields are updated with valid data\n    }\n}\n\n")),(0,a.kt)("h2",{id:"fields"},"Fields"),(0,a.kt)("p",null,"Each field defined in the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Controls/src/commonMain/kotlin/io/nacular/doodle/controls/form/Form.kt#L244"},(0,a.kt)("inlineCode",{parentName:"a"},"Form")),"\nwill be bounded to a single ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Core/src/commonMain/kotlin/io/nacular/doodle/core/View.kt#L63"},(0,a.kt)("inlineCode",{parentName:"a"},"View")),".\nThese views are defined during field binding using a ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Controls/src/commonMain/kotlin/io/nacular/doodle/controls/form/Form.kt#L18"},(0,a.kt)("inlineCode",{parentName:"a"},"FieldVisualizer")),".\nA visualizer is responsible for taking a ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Controls/src/commonMain/kotlin/io/nacular/doodle/controls/form/Form.kt#L99"},(0,a.kt)("inlineCode",{parentName:"a"},"Field")),"\nand its initial state and returning a View. The visualizer then acts as the bridge between the field's state and the View, mapping changes made\nin the View to the field (this includes validating that input)."),(0,a.kt)("h3",{id:"field-state"},"Field State"),(0,a.kt)("p",null,"Fields store their data as ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Controls/src/commonMain/kotlin/io/nacular/doodle/controls/form/Form.kt#L62"},(0,a.kt)("inlineCode",{parentName:"a"},"FieldState")),".\nThis is a strongly-typed value that can be ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Controls/src/commonMain/kotlin/io/nacular/doodle/controls/form/Form.kt#L83"},(0,a.kt)("inlineCode",{parentName:"a"},"Valid")),"\nor ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Controls/src/commonMain/kotlin/io/nacular/doodle/controls/form/Form.kt#L67"},(0,a.kt)("inlineCode",{parentName:"a"},"Invalid")),". Valid\nstate contains a value, while invalid state does not. A Form with any invalid fields is invalid itself, and will indicate this by calling\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Controls/src/commonMain/kotlin/io/nacular/doodle/controls/form/Form.kt#L247"},(0,a.kt)("inlineCode",{parentName:"a"},"onInvalid")),"."),(0,a.kt)("h3",{id:"creating-fields"},"Creating Fields"),(0,a.kt)("p",null,"Fields are created implicitly when FieldVisualizers are bound to a Form. These visualizers can be created using the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Controls/src/commonMain/kotlin/io/nacular/doodle/controls/form/Form.kt#L42"},(0,a.kt)("inlineCode",{parentName:"a"},"field")),"\ndsl, by implementing the interface, or by one of the existing form controls."),(0,a.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"dsl",label:"DSL",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"import io.nacular.doodle.controls.form.field\n\nfield<T> {\n    initial // initial state of the field\n    state   // mutable state of the field\n\n    view {} // view to display for the field\n}\n"))),(0,a.kt)(l.Z,{value:"interface",label:"Via Interface",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"import io.nacular.doodle.controls.form.FieldInfo\nimport io.nacular.doodle.controls.form.FieldVisualizer\n\nclass MyVisualizer<T>: FieldVisualizer<T> {\n    override fun invoke(fieldInfo: FieldInfo<T>): View {\n        fieldInfo.initial // initial state of the field\n        fieldInfo.state   // mutable state of the field\n\n        return view {}    // view to display for the field\n    }\n}\n")))),(0,a.kt)("h3",{id:"field-binding"},"Field Binding"),(0,a.kt)("p",null,"Fields all have an optional initial value. Therefore, each field can be bounded either with a value or without one. The result is 2 different\nways of adding a field to a Form."),(0,a.kt)("p",null,"The following shows how to bind fields that has no default value."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"import io.nacular.doodle.controls.form.Form\nimport io.nacular.doodle.controls.form.textField\nimport io.nacular.doodle.utils.ToStringIntEncoder\n\ndata class Person(val name: String, val age: Int)\n\nval form = Form { this(\n    + textField(),\n    + textField(encoder = ToStringIntEncoder),\n    + field<Person> { view {} },\n    // ...\n    onInvalid = {}) { text: String, number: Int, person: Person ->\n        // ...\n    }\n}\n")),(0,a.kt)("p",null,"This shows how to bind using initial values."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'import io.nacular.doodle.controls.form.Form\nimport io.nacular.doodle.controls.form.textField\nimport io.nacular.doodle.utils.ToStringIntEncoder\n\ndata class Person(val name: String, val age: Int)\n\nval form = Form { this(\n    "Hello"            to textField(),\n    4                  to textField(encoder = ToStringIntEncoder),\n    Person("Jack", 55) to field { view {} },\n    // ...\n    onInvalid = {}) { text: String, number: Int, person: Person ->\n        // ...\n    }\n}\n')),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"These examples bind fields that have no names. Doodle has a ",(0,a.kt)("a",{parentName:"p",href:"/doodle/docs/ui_components/form_controls#labeled"},(0,a.kt)("inlineCode",{parentName:"a"},"labeled")),"\nform control that wraps a control and assigns a name to it.")),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Note that a visualizer may set a field's state to some valid value at initialization time. This will give the same effect as that\nfield having had a initial value specified that the visualizer accepted.")),(0,a.kt)("h3",{id:"forms-as-fields"},"Forms as Fields"),(0,a.kt)("p",null,"Forms can also have nested forms within them. This is helpful when the field has complex data that can be presented to the user as a set\nof components. Such cases can be handled with custom visualizers, but many work well using a nested form."),(0,a.kt)("p",null,"Nested forms are created using the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Controls/src/commonMain/kotlin/io/nacular/doodle/controls/form/FormControls.kt#L1082"},(0,a.kt)("inlineCode",{parentName:"a"},"form")),"\ndsl. It works just like the top-level ",(0,a.kt)("inlineCode",{parentName:"p"},"Form")," dsl, but it actually ",(0,a.kt)("strong",{parentName:"p"},"creates an instance")," and has access to the initial value\nit is bound to (if any)."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"usage",label:"Demo",mdxType:"TabItem"},(0,a.kt)(r.l,{functionName:"nestedForm",height:"400",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"code",label:"Usage",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'import io.nacular.doodle.controls.form.form\nimport io.nacular.doodle.controls.form.Form\nimport io.nacular.doodle.controls.form.textField\nimport io.nacular.doodle.utils.ToStringIntEncoder\n\ndata class Person(val name: String, val age: Int)\n\nval form = Form { this(\n       + labeled("Text"  ) { textField() },\n       + labeled("Number") { textField(encoder = ToStringIntEncoder) },\n       Person("Jack", 55) to form { this(\n           initial.map { it.name } to labeled("Name") { textField() },\n           initial.map { it.age  } to labeled("Age" ) { textField(encoder = ToStringIntEncoder) },\n           onInvalid = {}\n       ) { name, age ->\n           Person(name, age) // construct person when valid\n       } },\n       // ...\n       onInvalid = {}) { text: String, number: Int, person: Person ->\n       // called each time all fields are updated with valid data\n   }\n}\n')))),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Nested forms can be used with or without initial values like any other field.")),(0,a.kt)("h2",{id:"layouts"},"Layouts"),(0,a.kt)("p",null,"Forms allow you to position their fields via a ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Core/src/commonMain/kotlin/io/nacular/doodle/core/Layout.kt#L80"},(0,a.kt)("inlineCode",{parentName:"a"},"Layout")),"\njust like other containers. This positionable items seen by the layout will correspond to the fields bound to the Form in the same order.\nAll the examples in this documentation use a vertical layout via the\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Controls/src/commonMain/kotlin/io/nacular/doodle/controls/form/FormControls.kt#L1215"},(0,a.kt)("inlineCode",{parentName:"a"},"verticalLayout")),"\nhelper found in the ",(0,a.kt)("inlineCode",{parentName:"p"},"io.nacular.doodle.controls.form")," package."))}h.isMDXComponent=!0}}]);