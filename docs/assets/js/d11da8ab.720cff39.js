"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[277],{2134:(e,t,n)=>{n.d(t,{ZP:()=>m});var o=n(7462),i=(n(7294),n(3905)),a=(n(8209),n(4866)),l=n(5162),r=n(1912);const d={toc:[]},s="wrapper";function m(e){let{components:t,...n}=e;return(0,i.kt)(s,(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("admonition",{title:"Library Required",type:"info"},(0,i.kt)("p",null,"You will need to add the ",(0,i.kt)("code",null,n.name)," library to your app's dependencies."),(0,i.kt)(a.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"Kotlin",mdxType:"TabItem"},(0,i.kt)("h4",{parentName:"admonition",id:"buildgradlekts"},"build.gradle.kts"),(0,i.kt)(r.O,{mdxType:"KPlayground"},n.kotlin)),(0,i.kt)(l.Z,{value:"Groovy",mdxType:"TabItem"},(0,i.kt)("h4",{parentName:"admonition",id:"buildgradle"},"build.gradle"),(0,i.kt)(r.O,{mdxType:"KPlayground"},n.groovy)))))}m.isMDXComponent=!0},3502:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>F,contentTitle:()=>T,default:()=>N,frontMatter:()=>b,metadata:()=>x,toc:()=>w});var o=n(7462),i=(n(7294),n(3905)),a=(n(8209),n(4866)),l=n(5162),r=n(4903),d=n(1912),s=n(1166),m=n(2134),u=n(9765),c=n(1453),p=n(4456);const f='package forms\n\nimport io.nacular.doodle.controls.form.Form\nimport io.nacular.doodle.controls.form.textField\nimport io.nacular.doodle.utils.ToStringIntEncoder\n\n//sampleStart\nval twoDigitNumber = Regex("^1[0-5]\\\\d|^[1-9]\\\\d|^[1-9]")\n\nval form = Form { this(\n    "Mary" to textField(),\n    35     to textField(twoDigitNumber, ToStringIntEncoder),\n    // ...\n    onInvalid = {\n        // called whenever any fields is updated with invalid data\n    }) { name: String, age: Int, /*...*/ ->\n        // called each time all fields are updated with valid data\n    }\n}\n//sampleEnd',h="package forms\n\nimport io.nacular.doodle.controls.form.field\nimport io.nacular.doodle.core.view\n\nfun <T> fieldDsl() {\n//sampleStart\n    field<T> {\n        initial // initial state of the field\n        state   // mutable state of the field\n\n        view {} // view to display for the field\n    }\n//sampleEnd\n}",g="package forms\n\nimport io.nacular.doodle.controls.form.FieldInfo\nimport io.nacular.doodle.controls.form.FieldVisualizer\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.view\n\n//sampleStart\nclass MyVisualizer<T>: FieldVisualizer<T> {\n    override fun invoke(fieldInfo: FieldInfo<T>): View {\n        fieldInfo.initial // initial state of the field\n        fieldInfo.state   // mutable state of the field\n\n        return view {}    // view to display for the field\n    }\n}\n//sampleEnd",v="package forms\n\nimport io.nacular.doodle.controls.form.Form\nimport io.nacular.doodle.controls.form.field\nimport io.nacular.doodle.controls.form.textField\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.utils.ToStringIntEncoder\n\nfun <T> noDefaults() {\n//sampleStart\n    data class Person(val name: String, val age: Int)\n\n    val form = Form { this(\n        + textField(),\n        + textField(encoder = ToStringIntEncoder),\n        + field<Person> { view {} },\n        // ...\n        onInvalid = {}\n    ) { text: String, number: Int, person: Person ->\n        // ...\n    } }\n//sampleEnd\n}",k='package forms\n\nimport io.nacular.doodle.controls.form.Form\nimport io.nacular.doodle.controls.form.field\nimport io.nacular.doodle.controls.form.textField\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.utils.ToStringIntEncoder\n\nfun <T> withDefaults() {\n//sampleStart\n    data class Person(val name: String, val age: Int)\n\n    val form = Form { this(\n        "Hello"            to textField(),\n        4                  to textField(encoder = ToStringIntEncoder),\n        Person("Jack", 55) to field { view {} },\n        // ...\n        onInvalid = {}\n    ) { text: String, number: Int, person: Person ->\n        // ...\n    } }\n//sampleEnd\n}',y='package forms\n\nimport io.nacular.doodle.controls.form.Form\nimport io.nacular.doodle.controls.form.form\nimport io.nacular.doodle.controls.form.labeled\nimport io.nacular.doodle.controls.form.map\nimport io.nacular.doodle.controls.form.textField\nimport io.nacular.doodle.utils.ToStringIntEncoder\n\nfun <T> formFields() {\n//sampleStart\n    data class Person(val name: String, val age: Int)\n\n    val form = Form { this(\n        + labeled("Text"  ) { textField()                             },\n        + labeled("Number") { textField(encoder = ToStringIntEncoder) },\n        Person("Jack", 55) to form { this(\n            initial.map { it.name } to labeled("Name") { textField() },\n            initial.map { it.age  } to labeled("Age" ) { textField(encoder = ToStringIntEncoder) },\n            onInvalid = {}\n        ) { name, age ->\n            Person(name, age) // construct person when valid\n        } },\n        // ...\n        onInvalid = {}\n    ) { text: String, number: Int, person: Person ->\n        // called each time all fields are updated with valid data\n    } }\n//sampleEnd\n}',b={hide_title:!0},T="Forms",x={unversionedId:"ui_components/form",id:"ui_components/form",title:"Forms",description:"Doodle forms make data collection simple, while still preserving flexibility to build just the right experience. They hide a lot of the complexity associated with mapping visual components to fields, state management, and validation. The result is an intuitive metaphor modeled around the idea of a constructor.",source:"@site/docs/ui_components/form.mdx",sourceDirName:"ui_components",slug:"/ui_components/form",permalink:"/doodle/docs/ui_components/form",draft:!1,tags:[],version:"current",frontMatter:{hide_title:!0},sidebar:"tutorialSidebar",previous:{title:"Catalog",permalink:"/doodle/docs/ui_components/overview"},next:{title:"Form Controls",permalink:"/doodle/docs/ui_components/form_controls"}},F={},w=[{value:"Like Constructors",id:"like-constructors",level:2},{value:"Creation",id:"creation",level:2},{value:"Fields",id:"fields",level:2},{value:"Field State",id:"field-state",level:3},{value:"Creating Fields",id:"creating-fields",level:3},{value:"Field Binding",id:"field-binding",level:3},{value:"Forms as Fields",id:"forms-as-fields",level:3},{value:"Layouts",id:"layouts",level:2}],I={toc:w},S="wrapper";function N(e){let{components:t,...n}=e;return(0,i.kt)(S,(0,o.Z)({},I,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"forms"},"Forms"),(0,i.kt)("p",null,"Doodle forms make data collection simple, while still preserving flexibility to build just the right experience. They hide a lot of the complexity associated with mapping visual components to fields, state management, and validation. The result is an intuitive metaphor modeled around the idea of a constructor."),(0,i.kt)(m.ZP,{name:"Controls",kotlin:u.Z,groovy:c.Z,mdxType:"LibraryRequired"}),(0,i.kt)("p",null,"Doodle also has a set of helpful forms controls that cover a reasonable range of data-types. These make its easy to create forms without much hassle. But there are bound to be cases where more customization is needed. This is why Doodle forms are also extensible, allowing you to fully customize the data they bind to and how each fields is visualized."),(0,i.kt)(a.Z,{mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,i.kt)(r.l,{functionName:"form",height:"600",mdxType:"DoodleApp"})),(0,i.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,i.kt)(d.O,{mdxType:"KPlayground"},p.Z))),(0,i.kt)("h2",{id:"like-constructors"},"Like Constructors"),(0,i.kt)("p",null,'Forms are very similar to constructors in that they have typed parameter lists (fields), and can only "create" instances when all their inputs are valid. Like any constructor, a Form can have optional fields, default values, and arbitrary types for its fields.'),(0,i.kt)("p",null,"While Forms behave like constructors in most ways, they do not actually create instances (only ",(0,i.kt)("a",{parentName:"p",href:"form#forms-as-fields"},"sub-forms")," do). This means they are not typed. Instead, they take fields and output a corresponding lists of strongly-typed data when all their fields are valid. This notification is intentionally general to allow forms to be used in a wide range of used cases."),(0,i.kt)("h2",{id:"creation"},"Creation"),(0,i.kt)("p",null,"Forms are created using the ",(0,i.kt)(s.PKs,null),' dsl function. This function ensures strong typing for fields and the form\'s "output".'),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The Form returned from the builder does not expose anything about the data it produces. So all consumption logic goes in the builder block.")),(0,i.kt)(d.O,{mdxType:"KPlayground"},f),(0,i.kt)("h2",{id:"fields"},"Fields"),(0,i.kt)("p",null,"Each field defined in the ",(0,i.kt)(s.l09,null)," will be bounded to a single ",(0,i.kt)(s.G7x,null),". These views are defined during field binding using a ",(0,i.kt)(s.Kox,null),". A visualizer is responsible for taking a ",(0,i.kt)(s.gNt,null)," and its initial state and returning a View. The visualizer then acts as the bridge between the field's state and the View, mapping changes made in the View to the field (this includes validating that input)."),(0,i.kt)("h3",{id:"field-state"},"Field State"),(0,i.kt)("p",null,"Fields store their data as ",(0,i.kt)(s.F6H,null),". This is a strongly-typed value that can be ",(0,i.kt)(s.AnA,null)," or ",(0,i.kt)(s.Q0U,null),". Valid state contains a value, while invalid state does not. A Form with any invalid fields is invalid itself, and will indicate this by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"onInvalid"),"."),(0,i.kt)("h3",{id:"creating-fields"},"Creating Fields"),(0,i.kt)("p",null,"Fields are created implicitly when FieldVisualizers are bound to a Form. These visualizers can be created using the ",(0,i.kt)(s.gNt,null)," dsl, by implementing the interface, or by one of the existing form controls."),(0,i.kt)(a.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"DSL",mdxType:"TabItem"},(0,i.kt)(d.O,{mdxType:"KPlayground"},h)),(0,i.kt)(l.Z,{value:"Interface",mdxType:"TabItem"},(0,i.kt)(d.O,{mdxType:"KPlayground"},g))),(0,i.kt)("h3",{id:"field-binding"},"Field Binding"),(0,i.kt)("p",null,"Fields all have an optional initial value. Therefore, each field can be bounded either with a value or without one. The result is 2 different ways of adding a field to a Form."),(0,i.kt)("p",null,"The following shows how to bind fields that has no default value."),(0,i.kt)(d.O,{mdxType:"KPlayground"},v),(0,i.kt)("p",null,"This shows how to bind using initial values."),(0,i.kt)(d.O,{mdxType:"KPlayground"},k),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"These examples bind fields that have no names. Doodle has a ",(0,i.kt)("a",{parentName:"p",href:"/doodle/docs/ui_components/form_controls#labeled"},(0,i.kt)("inlineCode",{parentName:"a"},"labeled"))," form control that wraps a control and assigns a name to it.")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Note that a visualizer may set a field's state to some valid value at initialization time. This will give the same effect as that field having had a initial value specified that the visualizer accepted.")),(0,i.kt)("h3",{id:"forms-as-fields"},"Forms as Fields"),(0,i.kt)("p",null,"Forms can also have nested forms within them. This is helpful when the field has complex data that can be presented to the user as a set of components. Such cases can be handled with custom visualizers, but many work well using a nested form."),(0,i.kt)("p",null,"Nested forms are created using the ",(0,i.kt)(s.PKs,null)," dsl. It works just like the top-level ",(0,i.kt)("inlineCode",{parentName:"p"},"Form")," dsl, but it actually ",(0,i.kt)("strong",{parentName:"p"},"creates an instance")," and has access to the initial value it is bound to (if any)."),(0,i.kt)(a.Z,{mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,i.kt)(r.l,{functionName:"nestedForm",height:"400",mdxType:"DoodleApp"})),(0,i.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,i.kt)(d.O,{mdxType:"KPlayground"},y))),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Nested forms can be used with or without initial values like any other field.")),(0,i.kt)("h2",{id:"layouts"},"Layouts"),(0,i.kt)("p",null,"Forms allow you to position their fields via a ",(0,i.kt)(s.Ar2,null)," just like other containers. This positionable items seen by the layout will correspond to the fields bound to the Form in the same order. All the examples in this documentation use a vertical layout via the ",(0,i.kt)(s.ZGh,null)," helper."))}N.isMDXComponent=!0},4456:(e,t,n)=>{n.d(t,{Z:()=>o});const o='package controls\n\nimport controls.Gender.Female\nimport controls.Gender.Male\nimport io.nacular.doodle.controls.buttons.PushButton\nimport io.nacular.doodle.controls.form.Form\nimport io.nacular.doodle.controls.form.LabeledConfig\nimport io.nacular.doodle.controls.form.TextFieldConfig\nimport io.nacular.doodle.controls.form.form\nimport io.nacular.doodle.controls.form.labeled\nimport io.nacular.doodle.controls.form.radioList\nimport io.nacular.doodle.controls.form.textField\nimport io.nacular.doodle.controls.form.verticalLayout\nimport io.nacular.doodle.drawing.Color.Companion.Red\nimport io.nacular.doodle.drawing.Font\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.text.StyledText\nimport io.nacular.doodle.text.invoke\nimport io.nacular.doodle.utils.ToStringIntEncoder\n\nenum class Gender { Male, Female }\n\nfun form(smallFont: Font) {\n    fun <T> LabeledConfig.textFieldConfig(placeHolder: String = "", errorText: StyledText? = null): TextFieldConfig<T>.() -> Unit = {\n        val initialHelperText = help.styledText\n\n        help.font             = smallFont\n        textField.placeHolder = placeHolder\n        onValid               = { help.styledText = initialHelperText }\n        onInvalid             = {\n            if (!textField.hasFocus) {\n                help.styledText = errorText ?: it.message?.let { Red(it) } ?: help.styledText\n            }\n        }\n    }\n\n    val submit = PushButton("Submit").apply {\n        enabled = false\n        size = Size(100, 32)\n    }\n\n    val twoDigitNumber = Regex("^1[0-5]\\\\d|^[1-9]\\\\d|^[1-9]")\n\n//sampleStart\n    val form = Form { this(\n        +labeled("Name", help = "3+ letters") {\n            textField(Regex(".{3,}"), config = textFieldConfig("Enter your name"))\n        },\n        +labeled("Age", help = "1 or 2 digit number") {\n            textField(twoDigitNumber, ToStringIntEncoder, config = textFieldConfig())\n        },\n        Female to labeled("Gender") { radioList(Male, Female) { spacing = 12.0 } },\n        +form { this(\n            +labeled("Text [Sub-form]", help = "Can be blank") {\n                textField(Regex(".*"), config = textFieldConfig())\n            },\n            +labeled("Number [Sub-form]", help = "1 to 10") {\n                textField(\n                    twoDigitNumber,\n                    ToStringIntEncoder,\n                    validator = { it <= 10 },\n                    config    = textFieldConfig()\n                )\n            }\n        ) { first, second ->\n            // nested Form creates a Pair<String, Int>\n            first to second\n        } },\n        onInvalid = { submit.enabled = false },\n    ) { name, age, gender, pair ->\n        submit.enabled = true\n        println("[Form valid] Name: $name, Age: $age, Gender: $gender, Sub-form: $pair") // <---- check console for output\n    } }.apply {\n        // configure the Form view itself\n        size      = Size(300, 100)\n        layout    = verticalLayout(this, spacing = 12.0, itemHeight = 32.0)\n        focusable = false\n    }\n//sampleEnd\n}'},1453:(e,t,n)=>{n.d(t,{Z:()=>o});const o="package animation\n\ndoodle_version = '0.9.1'\n\n//sampleStart\n// ...\n\ndependencies {\n    implementation \"io.nacular.doodle:controls:$doodle_version\"\n}\n\n// ...\n//sampleEnd"},9765:(e,t,n)=>{n.d(t,{Z:()=>o});const o='// ...\n\ndependencies {\n    implementation ("io.nacular.doodle:controls:$doodleVersion")\n}\n\n// ...'}}]);