"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[444],{2134:(e,n,t)=>{t.d(n,{ZP:()=>p});var o=t(7462),a=(t(7294),t(3905)),i=(t(8209),t(4866)),l=t(5162),r=t(1912);const d={toc:[]},s="wrapper";function p(e){let{components:n,...t}=e;return(0,a.kt)(s,(0,o.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("admonition",{title:"Library Required",type:"info"},(0,a.kt)("p",null,"You will need to add the ",(0,a.kt)("code",null,t.name)," library to your app's dependencies."),(0,a.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Kotlin",mdxType:"TabItem"},(0,a.kt)("h4",{parentName:"admonition",id:"buildgradlekts"},"build.gradle.kts"),(0,a.kt)(r.O,{mdxType:"KPlayground"},t.kotlin)),(0,a.kt)(l.Z,{value:"Groovy",mdxType:"TabItem"},(0,a.kt)("h4",{parentName:"admonition",id:"buildgradle"},"build.gradle"),(0,a.kt)(r.O,{mdxType:"KPlayground"},t.groovy)))))}p.isMDXComponent=!0},319:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>Kn,contentTitle:()=>Xn,default:()=>jn,frontMatter:()=>En,metadata:()=>_n,toc:()=>Wn});var o=t(7462),a=(t(7294),t(3905)),i=(t(8209),t(4866)),l=t(5162),r=t(2134),d=t(4903),s=t(1912),p=t(1166),m=t(1453),c=t(9765);const u='package label\n\nimport io.nacular.doodle.controls.text.Label\n\n//sampleStart\nval label = Label("Some Text")\n//sampleEnd',h='package label\n\nimport io.nacular.doodle.controls.text.Label\nimport io.nacular.doodle.drawing.Color.Companion.Red\nimport io.nacular.doodle.drawing.Color.Companion.Yellow\nimport io.nacular.doodle.drawing.Font\nimport io.nacular.doodle.text.Target.Background\nimport io.nacular.doodle.text.TextDecoration\nimport io.nacular.doodle.text.TextDecoration.Line.Under\nimport io.nacular.doodle.text.TextDecoration.Style.Wavy\nimport io.nacular.doodle.text.invoke\nimport io.nacular.doodle.utils.Dimension.Height\nimport io.nacular.doodle.utils.TextAlignment.Start\n\nfun example(bold: Font) {\n//sampleStart\n    val styledLabel = Label(\n        bold("Lorem Ipsum").." is simply "..Yellow("dummy text", Background)..\n        " of the printing and typesetting industry. It has been the industry\'s standard dummy text "..\n        TextDecoration(setOf(Under), Red, Wavy) ("ever since the 1500s")..\n        ", when an unknown printer took a galley of type and scrambled it to make a type specimen book."\n    ).apply {\n        width         = 250.0\n        fitText       = setOf(Height)\n        wrapsWords    = true\n        lineSpacing   = 1f\n        textAlignment = Start\n        letterSpacing = 0.0\n    }\n//sampleEnd\n}',y={toc:[]},g="wrapper";function k(e){let{components:n,...t}=e;return(0,a.kt)(g,(0,o.Z)({},y,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Holds and displays text with support for basic styling."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"label",height:"200",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},u),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Requires a ",(0,a.kt)(p.nsU,null)," to render. This example uses ",(0,a.kt)(p.e$b,null))))),(0,a.kt)("p",null,"Labels can also have ",(0,a.kt)(p.qYr,null),", word wrapping, vertical and horizontal alignment, and change how their letters and lines are spaced."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"styledLabel",height:"370",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},h),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Requires a ",(0,a.kt)(p.nsU,null)," to render. This example uses ",(0,a.kt)(p.e$b,null))))))}k.isMDXComponent=!0;const T="package textfield\n\nimport io.nacular.doodle.controls.text.TextField\nimport io.nacular.doodle.utils.Dimension.Height\nimport io.nacular.doodle.utils.Dimension.Width\n\n//sampleStart\nval textField = TextField().apply {\n    mask          = '*'\n    fitText       = setOf(Width, Height)\n    borderVisible = false\n}\n//sampleEnd",v="package io.nacular.doodle.docs.utils\n\nimport io.nacular.doodle.animation.Animation\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.invoke\nimport io.nacular.doodle.animation.transition.easeInOutCubic\nimport io.nacular.doodle.animation.tweenFloat\nimport io.nacular.doodle.controls.text.TextField\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.Color.Companion.Red\nimport io.nacular.doodle.drawing.Color.Companion.Transparent\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.drawing.lerp\nimport io.nacular.doodle.drawing.lighter\nimport io.nacular.doodle.drawing.opacity\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.theme.native.NativeTextFieldBehaviorModifier\nimport io.nacular.doodle.utils.autoCanceling\nimport io.nacular.doodle.utils.observable\nimport io.nacular.measured.units.Time.Companion.milliseconds\nimport io.nacular.measured.units.times\n\n//sampleStart\nclass CustomTextFieldBehavior(textField: TextField, animate: Animator): NativeTextFieldBehaviorModifier {\n    var valid by observable(true) { _, _ ->\n        textField.rerender()\n    }\n\n    private var animation: Animation<Float>? by autoCanceling()\n\n    private var animationProgress by observable(1f) { _, _ ->\n        textField.rerenderNow()\n    }\n\n    init {\n        textField.acceptsThemes   = false\n        textField.borderVisible   = false\n        textField.backgroundColor = Transparent\n        textField.focusChanged += { _,_,_ ->\n            animation = animate(0f to 1f, tweenFloat(easeInOutCubic, 250 * milliseconds)) { animationProgress = it }\n        }\n    }\n\n    override fun install(view: TextField) {\n        super.install(view)\n\n        view.enabledChanged += { _,_,_ ->\n            view.rerender()\n        }\n    }\n\n    override fun renderBackground(textField: TextField, canvas: Canvas) {\n        val startX     = if (textField.hasFocus) textField.width / 2 * (1 - animationProgress) else 0.0\n        val endX       = if (textField.hasFocus) textField.width / 2 * (1 + animationProgress) else textField.width\n        val color      = (if (valid) Black else Red).let { when {\n            !textField.enabled -> it.lighter()\n            else               -> it\n        } }\n        val thickColor = when {\n            !textField.hasFocus -> lerp(color, color opacity 0f, animationProgress)\n            else                -> color\n        }\n\n        canvas.line(start = Point(startX, textField.height - 2.0), end = Point(endX,            textField.height - 2.0), Stroke(thickness = 1.0, fill = thickColor.paint))\n        canvas.line(start = Point(0.0,    textField.height - 1.0), end = Point(textField.width, textField.height - 1.0), Stroke(thickness = 1.0, fill = color.paint     ))\n    }\n}\n//sampleEnd",x="package textfield\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.controls.text.TextField\nimport io.nacular.doodle.docs.utils.CustomTextFieldBehavior\nimport io.nacular.doodle.theme.native.NativeTextFieldStyler\n\nfun create(animate: Animator, textFieldStyler: NativeTextFieldStyler) {\n//sampleStart\n//  Animator              can be injected into app when Animator module is used\n//  NativeTextFieldStyler can be injected into app when nativeTextFieldBehavior module is used\n    val textField = TextField().apply {\n        acceptsThemes = false\n        behavior = textFieldStyler(this, CustomTextFieldBehavior(this, animate))\n    }\n//sampleEnd\n}",f={toc:[]},b="wrapper";function w(e){let{components:n,...t}=e;return(0,a.kt)(b,(0,o.Z)({},f,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Provides simple (un-styled) text input."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"textField",height:"200",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},T),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Requires a ",(0,a.kt)(p.JqZ,null),". The module ",(0,a.kt)("inlineCode",{parentName:"p"},"nativeTextFieldBehavior()")," provides one.")))),(0,a.kt)("p",null,"TextFields can also be customized using ",(0,a.kt)(p.sHo,null),". See the code sample for how this is achieved."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"styledTextField",height:"200",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},v),(0,a.kt)(s.O,{mdxType:"KPlayground"},x),(0,a.kt)("admonition",{type:"info"},(0,a.kt)(p.sIZ,null)," is available whenever the ",(0,a.kt)(p.nIj,null)," module is included.",(0,a.kt)("p",{parentName:"admonition"},"See ",(0,a.kt)("a",{parentName:"p",href:"/doodle/docs/animations"},"Animations")," for more details on how to incorporate them into your app.")))))}w.isMDXComponent=!0;const S='package controls\n\nimport io.nacular.doodle.controls.buttons.PushButton\n\n//sampleStart\nval button = PushButton("BUTTON").apply {\n    fired += {\n        println("Hey! That Hurt!")\n    }\n}\n//sampleEnd',C={toc:[]},P="wrapper";function D(e){let{components:n,...t}=e;return(0,a.kt)(P,(0,o.Z)({},C,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"A component that triggers an action when pressed; usually with the pointer or keyboard."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"button",height:"200",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},S),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"There are several types of buttons available, including ",(0,a.kt)(p.COr,null),", ",(0,a.kt)(p.JgP,null),", ",(0,a.kt)(p.EUY,null),", etc.. Rendering requires a ",(0,a.kt)(p.cgf,null),(0,a.kt)("inlineCode",{parentName:"p"},"<Button>"),". ",(0,a.kt)(p.MfS,null)," and ",(0,a.kt)(p.YUL,null)," provide versions.")))))}D.isMDXComponent=!0;const M='package controls\n\nimport io.nacular.doodle.controls.buttons.CheckBox\n\n//sampleStart\nval checkbox = CheckBox("CHECKBOX").apply {\n    selectedChanged += { _,_,new ->\n        println("Checkbox selected: $new, indeterminate: $indeterminate")\n    }\n}\n//sampleEnd',z={toc:[]},L="wrapper";function N(e){let{components:n,...t}=e;return(0,a.kt)(L,(0,o.Z)({},z,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"A toggle component that represents an on/off state and is triggered when pressed; usually with the pointer or keyboard."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"checkbox",height:"200",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},M),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"There are several types of buttons available, including ",(0,a.kt)(p.COr,null),", ",(0,a.kt)(p.JgP,null),", ",(0,a.kt)(p.EUY,null),", etc.. Rendering requires a ",(0,a.kt)(p.cgf,null),(0,a.kt)("inlineCode",{parentName:"p"},"<Button>"),". ",(0,a.kt)(p.MfS,null)," and ",(0,a.kt)(p.YUL,null)," provide versions.")))))}N.isMDXComponent=!0;const I='package controls\n\nimport io.nacular.doodle.controls.buttons.RadioButton\n\n//sampleStart\nval radioButton = RadioButton("RADIO BUTTON").apply {\n    selectedChanged += { _,_,new ->\n        println("Radio selected: $new")\n    }\n}\n//sampleEnd',Z={toc:[]},F="wrapper";function V(e){let{components:n,...t}=e;return(0,a.kt)(F,(0,o.Z)({},Z,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"A toggle component that represents an on/off state and is triggered when pressed; usually with the pointer or keyboard. RadioButtons are typically used in lists with ",(0,a.kt)(p.hE2,null)," to represent the selection of a single item from this list."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"radioButton",height:"200",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},I),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"There are several types of buttons available, including ",(0,a.kt)(p.COr,null),", ",(0,a.kt)(p.JgP,null),", ",(0,a.kt)(p.EUY,null),", etc.. Rendering requires a ",(0,a.kt)(p.cgf,null),(0,a.kt)("inlineCode",{parentName:"p"},"<Button>"),". ",(0,a.kt)(p.MfS,null)," and ",(0,a.kt)(p.YUL,null)," provide versions.")))))}V.isMDXComponent=!0;const B='package controls\n\nimport io.nacular.doodle.controls.buttons.Switch\nimport io.nacular.doodle.geometry.Size\n\n//sampleStart\nval switch = Switch().apply {\n    size             = Size(50, 30)\n    selectedChanged += { _,_,new ->\n        println("Switch selected: $new")\n    }\n}\n//sampleEnd',O={toc:[]},A="wrapper";function R(e){let{components:n,...t}=e;return(0,a.kt)(A,(0,o.Z)({},O,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"A toggle component that triggers an action when selected; usually with the pointer or keyboard."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"switchExample",height:"200",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},B),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Switches are just ",(0,a.kt)(p.COr,null),"s and can therefore be styled using any ",(0,a.kt)(p.cgf,null),(0,a.kt)("inlineCode",{parentName:"p"},"<Button>"),". ",(0,a.kt)(p.YUL,null)," provides one via ",(0,a.kt)(p.SQ$,null),".")))))}R.isMDXComponent=!0;const U='package controls\n\nimport io.nacular.doodle.controls.files.FileSelector\nimport io.nacular.doodle.geometry.Size\n\n//sampleStart\nval fileSelector = FileSelector().apply {\n    size         = Size(200, 40)\n    filesLoaded += { _,_,new ->\n        println("files loaded: $new")\n    }\n}\n//sampleEnd',E='package controls\n\nimport io.nacular.doodle.controls.files.FileSelector\nimport io.nacular.doodle.controls.files.FileSelectorBehavior\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.Color.Companion.Lightgray\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.drawing.TextMetrics\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.system.Cursor.Companion.Pointer\n\n//sampleStart\nclass CustomFileSelectorBehavior(textMetrics: TextMetrics): FileSelectorBehavior {\n    private val prompt          = "Choose File"\n    private val defaultFileText = "No file chosen"\n    private val textSize        = textMetrics.size(prompt)\n    private val inset           = 10\n    private val lineOffset      = textSize.width + 2 * inset\n\n    private val strokeColor     = Lightgray\n    private val strokeThickness = 2.0\n    private val stroke          = Stroke(strokeColor, strokeThickness)\n\n    override fun install(view: FileSelector) {\n        super.install(view)\n\n        view.cursor          = Pointer\n        view.filesLoaded    += { _,_,_ -> view.rerender() }\n        view.enabledChanged += { _,_,_ -> view.rerender() }\n    }\n\n    override fun render(view: FileSelector, canvas: Canvas) {\n        val textFill = if (view.enabled) Black.paint else strokeColor.paint\n\n        canvas.rect(view.bounds.atOrigin.inset(strokeThickness / 2), radius = 5.0, stroke)\n\n        if (view.width > lineOffset + strokeThickness) {\n            canvas.line(Point(lineOffset, strokeThickness), Point(lineOffset, view.height - strokeThickness), stroke)\n        }\n\n        val files = view.files.joinToString(", ") { it.name }.takeIf { it.isNotBlank() } ?: defaultFileText\n        val textY = (view.height - textSize.height) / 2\n\n        canvas.text(prompt, view.font, Point(inset,                                textY), textFill)\n        canvas.text(files,  view.font, Point(lineOffset + strokeThickness + inset, textY), textFill)\n    }\n}\n//sampleEnd',X="package controls\n\nimport io.nacular.doodle.controls.files.FileSelector\nimport io.nacular.doodle.controls.files.FileSelectorBehavior\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.Color.Companion.Lightgray\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.drawing.TextMetrics\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.system.Cursor.Companion.Pointer\nimport io.nacular.doodle.theme.native.NativeFileSelectorStyler\n\nfun usage(textMetrics: TextMetrics, fileSelectorStyler: NativeFileSelectorStyler) {\n//sampleStart\n    val fileSelector = FileSelector().apply {\n        acceptsThemes = false\n        behavior      = fileSelectorStyler(this, CustomFileSelectorBehavior(textMetrics))\n    }\n//sampleEnd\n}\n",_={toc:[]},K="wrapper";function W(e){let{components:n,...t}=e;return(0,a.kt)(K,(0,o.Z)({},_,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"A toggle component that triggers an action when selected; usually with the pointer or keyboard."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"fileSelector",height:"200",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},U),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"FileSelectors can be styled using any ",(0,a.kt)(p.cgf,null),(0,a.kt)("inlineCode",{parentName:"p"},"<FileSelector>"),". ",(0,a.kt)(p.MfS,null)," provides one via ",(0,a.kt)(p.IFo,null),".")))),(0,a.kt)("p",null,"FileSelectors can also be customized using ",(0,a.kt)(p.DbF,null),". See the code sample for how this is achieved."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"styledFileSelector",height:"200",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},E),(0,a.kt)(s.O,{mdxType:"KPlayground"},X),(0,a.kt)("admonition",{type:"info"},(0,a.kt)(p.DbF,null)," is available whenever the ",(0,a.kt)(p.IFo,null)," module is included."))))}W.isMDXComponent=!0;const q="package controls\n\nimport io.nacular.doodle.controls.Photo\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.image.Image\n\nfun usage(image: Image) {\n//sampleStart\n    val photo = Photo(image).apply {\n        size = Size(100, 200)\n    }\n//sampleEnd\n}",Y={toc:[]},j="wrapper";function H(e){let{components:n,...t}=e;return(0,a.kt)(j,(0,o.Z)({},Y,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Images in Doodle are not Views, they are more like text, in that you render them directly to a Canvas. The Photo component provides a simple wrapper around an Image."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"photo",height:"400",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},q))))}H.isMDXComponent=!0;const $="package controls\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.RepetitionType.Reverse\nimport io.nacular.doodle.animation.invoke\nimport io.nacular.doodle.animation.loop\nimport io.nacular.doodle.animation.transition.easeInOutCubic\nimport io.nacular.doodle.animation.tweenColor\nimport io.nacular.doodle.controls.LazyPhoto\nimport io.nacular.doodle.drawing.Color.Companion.Lightgray\nimport io.nacular.doodle.drawing.lighter\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.image.Image\nimport io.nacular.doodle.utils.observable\nimport io.nacular.measured.units.Time.Companion.seconds\nimport io.nacular.measured.units.times\nimport kotlinx.coroutines.Deferred\nimport kotlinx.coroutines.ExperimentalCoroutinesApi\n\n@OptIn(ExperimentalCoroutinesApi::class)\nclass LazyPhoto(image: Deferred<Image>, animate: Animator) {\n//sampleStart\n    val photo: LazyPhoto = LazyPhoto(\n        pendingImage = image,\n        initialized  = { animation.cancel() }\n    ) {\n        // custom rendering during load\n        rect(Rectangle(size = size), fill = color.paint)\n    }\n\n    val baseColor = Lightgray\n    var color       by observable(baseColor) { _,_ -> photo.rerenderNow() }\n    val animation = animate(\n        baseColor to baseColor.lighter(0.5f),\n        loop(tweenColor(easeInOutCubic, 1.5 * seconds), type = Reverse)\n    ) {\n        // Animate color used for loading state\n        color = it\n    }\n//sampleEnd\n}",G={toc:[]},J="wrapper";function Q(e){let{components:n,...t}=e;return(0,a.kt)(J,(0,o.Z)({},G,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("admonition",{title:"Experimental",type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"This control relies on experimental Coroutine features.")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"LazyPhoto")," is like ",(0,a.kt)("a",{parentName:"p",href:"#photo"},"Photo"),", except it takes a ",(0,a.kt)("a",{parentName:"p",href:"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/"},"Deferred"),(0,a.kt)("inlineCode",{parentName:"p"},"<Image>")," instead of an ",(0,a.kt)(p.Eep,null),". This allows apps to map loading images to Views even if those images are still pending. LazyPhoto also offers full customization of how it renders during the loading state. You provide a lambda that is called for all rendering while it is pending."),(0,a.kt)("p",null,"You can go a step further and animate the loading state using ",(0,a.kt)(p.LH7,null)," and re-rendering the ",(0,a.kt)("inlineCode",{parentName:"p"},"LazyPhoto")," when new frames are needed to be displayed. This app shows how you might achieve this."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"lazyPhoto",height:"400",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},$))))}Q.isMDXComponent=!0;const ee="package controls\n\nimport io.nacular.doodle.controls.ProgressBar\nimport io.nacular.doodle.utils.Orientation.Vertical\n\n//sampleStart\n// creates bars with ranges form 0 - 100\n\nval horizontal = ProgressBar(                      )\nval vertical   = ProgressBar(orientation = Vertical)\n//sampleEnd",ne='package controls\n\nimport io.nacular.doodle.controls.ProgressIndicator\nimport io.nacular.doodle.docs.utils.BlueColor\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.Color.Companion.Lightgray\nimport io.nacular.doodle.drawing.LinearGradientPaint\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.geometry.PathMetrics\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.Point.Companion.Origin\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.geometry.path\nimport io.nacular.doodle.theme.PathProgressIndicatorBehavior\n\nfun usage(pathMetrics: PathMetrics) {\n//sampleStart\n    val pathProgress = object: ProgressIndicator() {\n        init {\n            size = Size(200, 100)\n            progress = 0.25\n            behavior = PathProgressIndicatorBehavior(\n                pathMetrics,          // injected\n                path                = path("M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80")!!,\n                foreground          = LinearGradientPaint(Black, BlueColor, Origin, Point(width, 0.0)),\n                foregroundThickness = 5.0,\n                background          = Lightgray.paint,\n                backgroundThickness = 5.0\n            )\n        }\n    }\n//sampleEnd\n}',te='package controls\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.application.application\nimport io.nacular.doodle.controls.ProgressIndicator\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.docs.apps.CircularProgressApp\nimport io.nacular.doodle.docs.utils.BlueColor\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.theme.Theme\nimport io.nacular.doodle.theme.ThemeManager\nimport io.nacular.doodle.theme.basic.BasicTheme.Companion.basicCircularProgressIndicatorBehavior\nimport org.kodein.di.instance\n\n//sampleStart\nfun main() {\n    // include basicCircularProgressIndicatorBehavior\n    application(modules = listOf(\n        basicCircularProgressIndicatorBehavior(foreground = BlueColor.paint, thickness = 5.0)\n    )) {\n        CircularProgressApp(display = instance(), themeManager = instance(), theme = instance())\n    }\n}\n\nclass CircularProgressApp(display: Display, themeManager: ThemeManager, theme: Theme): Application {\n    init {\n        // Theme with basicCircularProgressIndicatorBehavior\n        themeManager.selected = theme\n\n        val circularProgressIndicator = object: ProgressIndicator() {\n            init {\n                size               = Size(100, 100)\n                progress           = 0.25\n                accessibilityLabel = "circular progress widget"\n            }\n        }\n\n        // ...\n    }\n\n    override fun shutdown() {}\n}\n//sampleEnd',oe={toc:[]},ae="wrapper";function ie(e){let{components:n,...t}=e;return(0,a.kt)(ae,(0,o.Z)({},oe,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Represents a value within a specified range that usually indicates progress toward some goal. It provides notifications when its value or range changes. Specify a range by passing a ",(0,a.kt)("inlineCode",{parentName:"p"},"ClosedRange")," or ",(0,a.kt)(p.YMB,null)," in the constructor."),(0,a.kt)("p",null,"ProgressBar is a specialization of ",(0,a.kt)(p.YFB,null),", which should be used for more generalized progress display (i.e. circular)"),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Horizontal",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"progress",height:"200",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Vertical",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"progress",args:'["vertical"]',height:"200",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},ee),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Rendering requires a ",(0,a.kt)(p.cgf,null),(0,a.kt)("inlineCode",{parentName:"p"},"<ProgressBar>"),". ",(0,a.kt)(p.YUL,null)," provides one.")))),(0,a.kt)("p",null,"ProgressIndicators can also take different shapes. Here's an example that uses ",(0,a.kt)(p.iQj,null),"."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"circularProgress",height:"200",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},te))),(0,a.kt)("p",null,"This one draws a path using ",(0,a.kt)(p.G7$,null),"."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"pathProgress",height:"200",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},ne))))}ie.isMDXComponent=!0;const le="package controls\n\nimport io.nacular.doodle.controls.range.Slider\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.utils.Orientation.Vertical\n\n//sampleStart\nval horizontalSlider = Slider(0.0 .. 1.0).apply {\n    size        = Size(200, 15)\n//  ticks       = 10\n//  snapToTicks = true\n}\n\nval verticalSlider = Slider(0 .. 100, orientation = Vertical).apply {\n    size = Size(15, 200)\n}\n//sampleEnd",re={toc:[]},de="wrapper";function se(e){let{components:n,...t}=e;return(0,a.kt)(de,(0,o.Z)({},re,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Sliders hold a strongly typed value within a specified range and allow the user to change the value. It provides notifications when\nits value or range changes. Specify a range by passing a ",(0,a.kt)("inlineCode",{parentName:"p"},"ClosedRange")," or ",(0,a.kt)(p.YMB,null)," in the constructor."),(0,a.kt)("p",null,"You can also confine the values to a predefined set within the range by specifying the ",(0,a.kt)("inlineCode",{parentName:"p"},"ticks")," count and setting\n",(0,a.kt)("inlineCode",{parentName:"p"},"snapToTicks")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),". This will pin the slider values to an evenly spaced set of points along its range."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Horizontal",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"slider",height:"250",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Vertical",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"slider",args:'["vertical"]',height:"250",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},le),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Rendering requires a ",(0,a.kt)("inlineCode",{parentName:"p"},"Behavior<Slider>"),". ",(0,a.kt)(p.YUL,null)," provides one.")))),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"All Sliders (including ",(0,a.kt)("a",{parentName:"p",href:"overview#circularslider"},"CircularSlider"),", ",(0,a.kt)("a",{parentName:"p",href:"overview#rangeslider"},"RangeSlider"),", and ",(0,a.kt)("a",{parentName:"p",href:"overview#circularrangeslider"},"CircularRangeSlider"),") are strongly typed. Which means you can create ",(0,a.kt)("inlineCode",{parentName:"p"},"Integer")," sliders that snap to each integer value. Therefore, it is not necessary to specify ",(0,a.kt)("inlineCode",{parentName:"p"},"ticks")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"snapToTicks")," to ensure they only land on whole numbers."),(0,a.kt)("p",{parentName:"admonition"},"It is possible to still restrict their range further using these properties however. Then, they will only take on integer values that match the tick count.")))}se.isMDXComponent=!0;const pe="package controls\n\nimport io.nacular.doodle.controls.range.CircularSlider\nimport io.nacular.doodle.geometry.Size\n\n//sampleStart\nval circularSlider = CircularSlider(1 .. 100).apply {\n    size = Size(100, 100)\n\n//  ticks       = 10\n//  snapToTicks = true\n}\n//sampleEnd",me={toc:[]},ce="wrapper";function ue(e){let{components:n,...t}=e;return(0,a.kt)(ce,(0,o.Z)({},me,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"CircularSlider behaves just like a regular ",(0,a.kt)("a",{parentName:"p",href:"#slider"},"Slider"),", except it is meant to be a ring. This means it provides notifications when its value or range changes and these can be specified by passing a ",(0,a.kt)("inlineCode",{parentName:"p"},"ClosedRange")," or ",(0,a.kt)(p.YMB,null)," in the constructor."),(0,a.kt)("p",null,"Like Slider, you can also confine the values to a predefined set within the range by specifying the ",(0,a.kt)("inlineCode",{parentName:"p"},"ticks")," count and setting\n",(0,a.kt)("inlineCode",{parentName:"p"},"snapToTicks")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),". This will pin the slider values to an evenly spaced set of points along its range."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"slider",args:'["circular"]',height:"200",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},pe),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Rendering requires a ",(0,a.kt)("inlineCode",{parentName:"p"},"Behavior<CircularSlider>"),". ",(0,a.kt)(p.YUL,null)," provides one.")))))}ue.isMDXComponent=!0;const he="package controls\n\nimport io.nacular.doodle.controls.range.RangeSlider\nimport io.nacular.doodle.geometry.Size\n\n//sampleStart\nval rangeSlider = RangeSlider(value = 10 .. 30, limits = 1 .. 100).apply {\n    size = Size(100, 100)\n\n//  ticks       = 10\n//  snapToTicks = true\n}\n//sampleEnd",ye={toc:[]},ge="wrapper";function ke(e){let{components:n,...t}=e;return(0,a.kt)(ge,(0,o.Z)({},ye,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Range sliders hold a strongly typed inner range within a specified outer range and allow the user to change these values. It provides notifications when its either changes. Specify the ranges by passing ",(0,a.kt)("inlineCode",{parentName:"p"},"ClosedRange"),"s or a ",(0,a.kt)(p.jMK,null)," in the constructor."),(0,a.kt)("p",null,"You can also confine the inner range using a ",(0,a.kt)("inlineCode",{parentName:"p"},"ticks")," count and setting ",(0,a.kt)("inlineCode",{parentName:"p"},"snapToTicks")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),", just like regular ranges. This will pin the values of the inner range to an evenly spaced set of points along its range."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"rangeSlider",height:"250",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Vertical",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"rangeSlider",args:'["vertical"]',height:"250",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},he),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Rendering requires a ",(0,a.kt)("inlineCode",{parentName:"p"},"Behavior<RangeSlider>"),". ",(0,a.kt)(p.YUL,null)," provides one.")))))}ke.isMDXComponent=!0;const Te="package controls\n\nimport io.nacular.doodle.controls.range.CircularRangeSlider\nimport io.nacular.doodle.geometry.Size\n\n//sampleStart\nval circularRangeSlider = CircularRangeSlider(value = 10 .. 30, range = 1 .. 100).apply {\n    size = Size(100, 100)\n\n//  ticks       = 10\n//  snapToTicks = true\n}\n//sampleEnd",ve={toc:[]},xe="wrapper";function fe(e){let{components:n,...t}=e;return(0,a.kt)(xe,(0,o.Z)({},ve,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"CircularRangeSlider")," behaves just like a regular ",(0,a.kt)("a",{parentName:"p",href:"#rangeslider"},"RangeSlider"),", except it is meant to be a ring."),(0,a.kt)("p",null,"Like ",(0,a.kt)("inlineCode",{parentName:"p"},"RangeSlider"),", you can also confine the values to a predefined set within the range by specifying the ",(0,a.kt)("inlineCode",{parentName:"p"},"ticks")," count and setting ",(0,a.kt)("inlineCode",{parentName:"p"},"snapToTicks")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),". This will pin the slider values to an evenly spaced set of points along its range."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"rangeSlider",args:'["circular"]',height:"200",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},Te),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Rendering requires a ",(0,a.kt)("inlineCode",{parentName:"p"},"Behavior<CircularRangeSlider>"),". ",(0,a.kt)(p.YUL,null)," provides one.")))))}fe.isMDXComponent=!0;const be='package controls\n\nimport io.nacular.doodle.controls.spinner.Spinner\n\n//sampleStart\nval spinner1 = Spinner(1..9 step 2)\nval spinner2 = Spinner(listOf("Monday", "Tuesday", "Wednesday"))\n//sampleEnd',we={toc:[]},Se="wrapper";function Ce(e){let{components:n,...t}=e;return(0,a.kt)(Se,(0,o.Z)({},we,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Spinner is a list data structure analog that lets you represent a list of items where only one is visible (selected) at a time. They work well when the list of options is relatively small, or the input is an incremental value: like the number of items to purchase."),(0,a.kt)("p",null,"Spinner takes a ",(0,a.kt)(p.ShA,null)," that works like an ",(0,a.kt)("inlineCode",{parentName:"p"},"Iterator"),". This allows them to represent an open-ended list of items that do not need to be loaded up front."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"spinner",height:"200",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},be),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Rendering requires a ",(0,a.kt)(p.ngm,null),". ",(0,a.kt)(p.YUL,null)," provides one.")))))}Ce.isMDXComponent=!0;const Pe='package controls\n\nimport io.nacular.doodle.controls.dropdown.Dropdown\n\n//sampleStart\nval dropdown1 = Dropdown(1..9 step 2)\nval dropdown2 = Dropdown(listOf("Left", "Center", "Right"))\n//sampleEnd',De={toc:[]},Me="wrapper";function ze(e){let{components:n,...t}=e;return(0,a.kt)(Me,(0,o.Z)({},De,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Dropdown is a list data structure similar to Spinner. It also lets you represent a list of choices where only one is visible (selected) at a time.But unlike a Spinner, the choices are shown in a list when the control is activated. They work well when the list of options is relatively small."),(0,a.kt)("p",null,"Dropdown takes a ",(0,a.kt)(p.BW6,null)," that works like an ",(0,a.kt)("inlineCode",{parentName:"p"},"Iterator"),". This allows them to represent an open-ended list of items that do not need to be loaded up front."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"dropdown",height:"200",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},Pe),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Rendering requires a ",(0,a.kt)(p.pH2,null),". ",(0,a.kt)(p.YUL,null)," provides one.")))))}ze.isMDXComponent=!0;const Le="package controls\n\nimport io.nacular.doodle.controls.StarRater\nimport io.nacular.doodle.geometry.Rectangle\n\n//sampleStart\nval stars = StarRater(displayRounded = 0f, max = 5).apply {\n    bounds           = Rectangle(200, 50)\n    minSpacing       = 15.0\n    innerRadiusRatio = 0.6f\n}\n//sampleEnd",Ne={toc:[]},Ie="wrapper";function Ze(e){let{components:n,...t}=e;return(0,a.kt)(Ie,(0,o.Z)({},Ne,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"A highly customizable control that displays a rating between ","[0, n]"," using stars. It also lets the user change the underlying value."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"starRater",height:"200",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},Le))))}Ze.isMDXComponent=!0;const Fe='package controls\n\nimport io.nacular.doodle.controls.MultiSelectionModel\nimport io.nacular.doodle.controls.SimpleMutableListModel\nimport io.nacular.doodle.controls.StringVisualizer\nimport io.nacular.doodle.controls.itemVisualizer\nimport io.nacular.doodle.controls.list.DynamicList\nimport io.nacular.doodle.docs.utils.Country\nimport io.nacular.doodle.docs.utils.CountryView\nimport io.nacular.doodle.image.ImageLoader\nimport io.nacular.doodle.layout.constraints.fill\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.launch\n\nfun example(scope: CoroutineScope, imageLoader: ImageLoader) {\n//sampleStart\n    val model = SimpleMutableListModel<Country>()\n\n    scope.launch {\n        listOf(\n            "United Kingdom" to "images/197374.svg",\n            "United States"  to "images/197484.svg",\n            "France"         to "images/197560.svg",\n            "Germany"        to "images/197571.svg",\n            "Spain"          to "images/197593.svg",\n            // ...\n        ).sortedBy { it.first }.map { (name, path) ->\n            imageLoader.load(path)?.let { image ->\n                model.add(Country(name, image))\n            }\n        }\n    }\n\n    val stringVisualizer = StringVisualizer()\n\n    val list = DynamicList(\n        model,\n        selectionModel = MultiSelectionModel(),\n        itemVisualizer = itemVisualizer { item, previous, context ->\n            when (previous) {\n                is CountryView -> previous.apply {\n                    update(\n                        index    = context.index,\n                        country  = item,\n                        selected = context.selected\n                    )\n                }\n                else           -> CountryView(\n                    stringVisualizer,\n                    index    = context.index,\n                    country  = item,\n                    selected = context.selected\n                )\n            }\n        }\n    ).apply {\n        cellAlignment = fill\n    }\n//sampleEnd\n}',Ve="package controls\n\nimport io.nacular.doodle.controls.DynamicListModel\nimport io.nacular.doodle.controls.IndexedItem\nimport io.nacular.doodle.controls.ItemVisualizer\nimport io.nacular.doodle.controls.MultiSelectionModel\nimport io.nacular.doodle.controls.itemVisualizer\nimport io.nacular.doodle.controls.list.VerticalDynamicList\nimport io.nacular.doodle.docs.utils.Country\nimport io.nacular.doodle.docs.utils.CountryView\nimport io.nacular.doodle.layout.constraints.fill\n\nfun verticalList(model: DynamicListModel<Country>, stringVisualizer: ItemVisualizer<String, IndexedItem>) {\n//sampleStart\n    val list = VerticalDynamicList(\n        model,\n        selectionModel = MultiSelectionModel(),\n        itemVisualizer = itemVisualizer { item, previous, context ->\n            when (previous) {\n                is CountryView -> previous.apply {\n                    update(\n                        index    = context.index,\n                        country  = item,\n                        selected = context.selected\n                    )\n                }\n                else           -> CountryView(\n                    stringVisualizer,\n                    index    = context.index,\n                    country  = item,\n                    selected = context.selected\n                )\n            }\n        }\n    ).apply {\n        cellAlignment = fill\n    }\n//sampleEnd\n}",Be="package controls\n\nimport io.nacular.doodle.controls.DynamicListModel\nimport io.nacular.doodle.controls.IndexedItem\nimport io.nacular.doodle.controls.ItemVisualizer\nimport io.nacular.doodle.controls.MultiSelectionModel\nimport io.nacular.doodle.controls.itemVisualizer\nimport io.nacular.doodle.controls.list.HorizontalDynamicList\nimport io.nacular.doodle.docs.utils.Country\nimport io.nacular.doodle.docs.utils.CountryView\nimport io.nacular.doodle.layout.constraints.fill\n\nfun horizontalList(model: DynamicListModel<Country>, stringVisualizer: ItemVisualizer<String, IndexedItem>) {\n//sampleStart\n    val list = HorizontalDynamicList(\n        model,\n        selectionModel = MultiSelectionModel(),\n        itemVisualizer = itemVisualizer { item, previous, context ->\n            when (previous) {\n                is CountryView -> previous.apply {\n                    update(\n                        index    = context.index,\n                        country  = item,\n                        selected = context.selected\n                    )\n                }\n                else           -> CountryView(\n                    stringVisualizer,\n                    index    = context.index,\n                    country  = item,\n                    selected = context.selected\n                )\n            }\n        }\n    ).apply {\n        cellAlignment = fill\n    }\n//sampleEnd\n}",Oe={toc:[]},Ae="wrapper";function Re(e){let{components:n,...t}=e;return(0,a.kt)(Ae,(0,o.Z)({},Oe,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"List")," control is a visual analog to the list data structure. It is a ",(0,a.kt)("strong",{parentName:"p"},"readonly"),", ordered, generic collection of items with random\naccess to its members."),(0,a.kt)("p",null,"You need 2 things to create a List: a ",(0,a.kt)(p.BW6,null),", and ",(0,a.kt)(p.yP2,null),"."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"You also need to provide a ",(0,a.kt)(p.mSC,null)," or use a ",(0,a.kt)(p.Q2A,null)," with one since List delegates rendering. The examples below use ",(0,a.kt)(p.wuN,null)," which is also available as a module within ",(0,a.kt)(p.YUL,null),".")),(0,a.kt)("p",null,"The model represents the data within the List, and the visualizer provides a way to translate each item to a ",(0,a.kt)("inlineCode",{parentName:"p"},"View")," that will be rendered within\nthe List."),(0,a.kt)("p",null,"Lists provide memory optimization by only rendering the contents within their viewport, recycling items to display new rows. The default setting caches 10 extra items; but this can be changed with the ",(0,a.kt)("inlineCode",{parentName:"p"},"scrollCache")," property when creating the List."),(0,a.kt)("p",null,"The following shows a ",(0,a.kt)(p.Aap,null)," of countries (a custom data class). These Lists are useful when the underlying model can change after creation. This demo loads images asynchronously and adds new countries to the model as they load. The demo also illustrates a custom visualizer that represents each country as a name label and flag image."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"list",height:"300",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},Fe))),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Columns",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"verticalList",height:"300",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},Ve))),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Columns",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"horizontalList",height:"300",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},Be))),(0,a.kt)("p",null,"This List displays a set of countries, with each having a name and flag image. A ",(0,a.kt)("inlineCode",{parentName:"p"},"DynamicList")," is used here because\nthe underlying ",(0,a.kt)("inlineCode",{parentName:"p"},"model")," changes as each country is added asynchronously when its image loads."),(0,a.kt)("div",{style:{fontSize:"10px",textAlign:"right",color:"gray"}},"Icons made by ",(0,a.kt)("a",{style:{color:"gray"},href:"https://www.flaticon.com/authors/freepik",title:"Freepik"},"Freepik")," from ",(0,a.kt)("a",{style:{color:"gray"},href:"https://www.flaticon.com/",title:"Flaticon"},"www.flaticon.com")),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)(p.Aap,null)," is readonly (though its models may change), while ",(0,a.kt)(p.gYf,null)," is read/write."))}Re.isMDXComponent=!0;const Ue='package controls\n\nimport io.nacular.doodle.controls.MultiSelectionModel\nimport io.nacular.doodle.controls.tree.SimpleTreeModel\nimport io.nacular.doodle.controls.tree.Tree\nimport io.nacular.doodle.controls.tree.rootNode\nimport io.nacular.doodle.docs.utils.HighlightingTextVisualizer\n\n//sampleStart\nval root = rootNode("") {\n    node("Applications")\n    node("Desktop"     )\n    node("Documents"   ) {\n        node("Image.jpg")\n        node("Todos.txt")\n    }\n    node("Downloads"    )\n    node("Movies"       )\n    node("Music"        ) {\n        node("Track1.mp3")\n        node("Track2.mp3")\n        node("Track3.mp3")\n        node("Track4.mp3")\n    }\n    node("Photos"        ) {\n        node("Capture1.jpg")\n        node("Capture2.jpg")\n        node("Capture3.jpg")\n        node("Capture4.jpg")\n    }\n}\n\nval tree = Tree(\n    model          = SimpleTreeModel(root),\n    itemVisualizer = HighlightingTextVisualizer(),\n    selectionModel = MultiSelectionModel()\n)\n//sampleEnd',Ee={toc:[]},Xe="wrapper";function _e(e){let{components:n,...t}=e;return(0,a.kt)(Xe,(0,o.Z)({},Ee,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The Tree control is a visual analog to the tree data structure. It is a ",(0,a.kt)("strong",{parentName:"p"},"readonly"),", hierarchical, generic collection of items that are accessible\nvia a numeric path."),(0,a.kt)("p",null,"You need 2 things to create a Tree: a ",(0,a.kt)(p.rv5,null),", and ",(0,a.kt)(p.yP2,null),"."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"You also need to provide a Behavior or use a Theme with one since Tree delegates rendering.")),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"tree",height:"300",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},Ue),(0,a.kt)("p",null,"This creates a Tree from the nodes defined. This demo also places the Tree in a resizable ScrollPanel; but that code is excluded for simplicity. Trees--like Lists--provide memory optimized rendering."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Trees require a ",(0,a.kt)(p.ZJC,null)," for rendering. ",(0,a.kt)("inlineCode",{parentName:"p"},"BasicTheme")," provides one.")))),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)(p.xrL,null)," is readonly (though its models may change), while ",(0,a.kt)(p.bmp,null)," is read/write."))}_e.isMDXComponent=!0;const Ke='package controls\n\nimport io.nacular.doodle.controls.MultiSelectionModel\nimport io.nacular.doodle.controls.table.TreeTable\nimport io.nacular.doodle.controls.text.Label\nimport io.nacular.doodle.controls.tree.SimpleTreeModel\nimport io.nacular.doodle.controls.tree.TreeNode\nimport io.nacular.doodle.docs.utils.HighlightingTextVisualizer\nimport io.nacular.measured.units.BinarySize\nimport io.nacular.measured.units.BinarySize.Companion.bytes\nimport io.nacular.measured.units.BinarySize.Companion.gigabytes\nimport io.nacular.measured.units.BinarySize.Companion.kilobytes\nimport io.nacular.measured.units.BinarySize.Companion.megabytes\nimport io.nacular.measured.units.Measure\nimport io.nacular.measured.units.times\nimport io.nacular.measured.units.toNearest\n\ninterface File {\n    val name: String              get() = ""\n    val size: Measure<BinarySize> get() = 0 * bytes\n\n    fun toNode(): TreeNode<File> {\n        return TreeNode(this)\n    }\n\n    companion object {\n        operator fun invoke(name: String, size: Measure<BinarySize> = 0 * bytes) = object: File {}\n    }\n}\n\ninterface Directory: File {\n    interface DirectoryBuilder\n\n    val children: List<File> get() = TODO("Not yet implemented")\n\n    override fun toNode(): TreeNode<File> {\n        return TreeNode(this, children.map { it.toNode() })\n    }\n\n    companion object {\n        operator fun invoke(name: String, children: DirectoryBuilder.() -> Unit) = object: Directory {}\n    }\n}\n\nprivate fun Measure<BinarySize>.toSmallestUnit(): Measure<BinarySize> {\n    listOf(bytes, kilobytes, megabytes, gigabytes).forEach {\n        if (this >=  1 * it) return (this `as` it).toNearest(0.1 * it)\n    }\n\n    return this\n}\n\nfun treeTable() {\n//sampleStart\n    val root = Directory("") {\n        File("Applications",     100 * gigabytes)\n        File("Desktop",           79 * bytes    )\n        Directory("Documents") {\n            File("Image.jpg",    256 * kilobytes)\n            File("Todos.txt",     10 * megabytes)\n        }\n        Directory("Downloads") {}\n        File("Movies",           1.8 * gigabytes)\n        Directory("Music") {\n            File("Track1.mp3",   3.6 * megabytes)\n            File("Track2.mp3",   867 * kilobytes)\n            File("Track3.mp3",     3 * megabytes)\n            File("Track4.mp3",    12 * megabytes)\n        }\n        Directory("Photos") {\n            File("Capture1.jpg",  105 * megabytes)\n            File("Capture2.jpg",   87 * megabytes)\n            File("Capture3.jpg", 1000 * kilobytes)\n            File("Capture4.jpg",  1.1 * gigabytes)\n        }\n    }\n\n    val treeTable = TreeTable(\n        model          = SimpleTreeModel(root.toNode()),\n        selectionModel = MultiSelectionModel()\n    ) {\n        val textVisualizer = HighlightingTextVisualizer()\n\n        column(Label("Name"), { name                       }, textVisualizer) { width = 150.0 }\n        column(Label("Size"), { "${size.toSmallestUnit()}" }, textVisualizer) {\n            width         = 150.0\n            cellAlignment = {\n                it.right eq parent.right - 10\n                it.width.preserve\n                it.centerY eq parent.centerY\n            }\n        }\n    }\n//sampleEnd\n}',We={toc:[]},qe="wrapper";function Ye(e){let{components:n,...t}=e;return(0,a.kt)(qe,(0,o.Z)({},We,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The Tree control is a visual analog to the tree data structure. It is a ",(0,a.kt)("strong",{parentName:"p"},"readonly"),", hierarchical, generic collection of items that are accessible via a numeric path."),(0,a.kt)("p",null,"You need 2 things to create a Tree: a ",(0,a.kt)(p.rv5,null),", and ",(0,a.kt)(p.yP2,null),"."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"You also need to provide a Behavior or use a Theme with one since Tree delegates rendering.")),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"treeTable",height:"300",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},Ke),(0,a.kt)("p",null,"This creates a Tree from the nodes defined. This demo also places the Tree in a resizable ScrollPanel; but that code is excluded for simplicity. Trees--like Lists--provide memory optimized rendering."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Trees require a ",(0,a.kt)(p.ZJC,null)," for rendering. ",(0,a.kt)("inlineCode",{parentName:"p"},"BasicTheme")," provides one.")))))}Ye.isMDXComponent=!0;const je='package controls\n\nimport io.nacular.doodle.controls.BooleanVisualizer\nimport io.nacular.doodle.controls.MultiSelectionModel\nimport io.nacular.doodle.controls.itemVisualizer\nimport io.nacular.doodle.controls.table.CellInfo\nimport io.nacular.doodle.controls.table.Table\nimport io.nacular.doodle.controls.text.Label\nimport io.nacular.doodle.controls.toString\nimport io.nacular.doodle.docs.utils.HighlightingTextVisualizer\nimport io.nacular.doodle.layout.constraints.center\n\nfun tableExample() {\n//sampleStart\n    data class Person(val name: String, val age: Int, val attending: Boolean)\n\n    val textVisualizer = HighlightingTextVisualizer()\n\n    // Generates a string for each row\'s index\n    val indexVisualizer = itemVisualizer<Unit, CellInfo<Person, Unit>> { _, previous, context ->\n        textVisualizer("${context.index + 1}", previous, context)\n    }\n\n    val data = listOf(\n        Person(name = "Alice", age = 53, attending = false),\n        Person(name = "Bob",   age = 35, attending = true ),\n        Person(name = "Jack",  age =  8, attending = true ),\n        Person(name = "Jill",  age =  5, attending = false)\n    )\n\n    val table = Table(data, MultiSelectionModel()) {\n        column(Label("#"        ),                indexVisualizer         ) { minWidth =  50.0; width =  50.0; maxWidth = 150.0; cellAlignment = center                                             }\n        column(Label("Name"     ), { name      }, textVisualizer          ) { minWidth = 100.0;                                  cellAlignment = { it.left eq 10 }                                  }\n        column(Label("Age"      ), { age       }, toString(textVisualizer)) { minWidth = 100.0; width = 100.0; maxWidth = 150.0; cellAlignment = { it.left eq 10 }; headerAlignment = cellAlignment }\n        column(Label("Attending"), { attending }, BooleanVisualizer()     ) { minWidth = 100.0; width = 100.0; maxWidth = 150.0; cellAlignment = center                                             }\n    }\n//sampleEnd\n}',He={toc:[]},$e="wrapper";function Ge(e){let{components:n,...t}=e;return(0,a.kt)($e,(0,o.Z)({},He,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Tables are very similar to ",(0,a.kt)("inlineCode",{parentName:"p"},"Lists")," (",(0,a.kt)("strong",{parentName:"p"},"readonly")," analog to the list data structure). They are like Lists that can display structured\ndata for each entry they hold."),(0,a.kt)("p",null,"Tables are strongly typed and homogeneous, like Lists. So each item is of some type ",(0,a.kt)("inlineCode",{parentName:"p"},"<T>"),". The values of each column are therefore\nderivable from each ",(0,a.kt)("inlineCode",{parentName:"p"},"<T>")," in the table. The Table below contains a list of ",(0,a.kt)("inlineCode",{parentName:"p"},"Person")," and has columns for the ",(0,a.kt)("inlineCode",{parentName:"p"},"name"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"age"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"attending")," (whether they are attending an event). Columns can also produce arbitrary values, which is done to show the index of each item."),(0,a.kt)("p",null,"Each column's ",(0,a.kt)(p.kzp,null)," ultimately controls what is displayed in it. The visualizer is given the value of each element in that column to produce a View. So the ",(0,a.kt)("strong",{parentName:"p"},"Name")," column gets a ",(0,a.kt)("inlineCode",{parentName:"p"},"String"),", while the ",(0,a.kt)("strong",{parentName:"p"},"Attending")," column gets a ",(0,a.kt)("inlineCode",{parentName:"p"},"Boolean"),". The first column has values of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Unit"),", and uses the ",(0,a.kt)("inlineCode",{parentName:"p"},"RowNumberGenerator")," to display the index of each item."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)(p.tMN,null)," supports changes to its model, and ",(0,a.kt)(p.yxz,null)," allows editing."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"table",height:"400",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},je),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Tables require a ",(0,a.kt)(p.c6S,null)," for rendering. ",(0,a.kt)("inlineCode",{parentName:"p"},"BasicTheme")," provides one.")))))}Ge.isMDXComponent=!0;const Je='package controls\n\nimport io.nacular.doodle.controls.BooleanVisualizer\nimport io.nacular.doodle.controls.MultiSelectionModel\nimport io.nacular.doodle.controls.itemVisualizer\nimport io.nacular.doodle.controls.mutableListModelOf\nimport io.nacular.doodle.controls.table.CellInfo\nimport io.nacular.doodle.controls.table.MutableTable\nimport io.nacular.doodle.controls.text.Label\nimport io.nacular.doodle.controls.toString\nimport io.nacular.doodle.docs.utils.HighlightingTextVisualizer\nimport io.nacular.doodle.layout.constraints.center\n\nfun mutableTableExample() {\n//sampleStart\n    data class Person(val name: String, val age: Int, val attending: Boolean)\n\n    val textVisualizer = HighlightingTextVisualizer()\n\n    // Generates a string for each row\'s index\n    val indexVisualizer = itemVisualizer<Unit, CellInfo<Person, Unit>> { _, previous, context ->\n        textVisualizer("${context.index + 1}", previous, context)\n    }\n\n    val data = mutableListModelOf(\n        Person(name = "Alice", age = 53, attending = false),\n        Person(name = "Bob",   age = 35, attending = true ),\n        Person(name = "Jack",  age =  8, attending = true ),\n        Person(name = "Jill",  age =  5, attending = false)\n    )\n\n    val table = MutableTable(data, MultiSelectionModel()) {\n        column(Label("#"        ),                indexVisualizer         ) { minWidth =  50.0; width =  50.0; maxWidth = 150.0; cellAlignment = center                                             }\n        column(Label("Name"     ), { name      }, textVisualizer          ) { minWidth = 100.0;                                  cellAlignment = { it.left eq 10 }                                  }\n        column(Label("Age"      ), { age       }, toString(textVisualizer)) { minWidth = 100.0; width = 100.0; maxWidth = 150.0; cellAlignment = { it.left eq 10 }; headerAlignment = cellAlignment }\n        column(Label("Attending"), { attending }, BooleanVisualizer()     ) { minWidth = 100.0; width = 100.0; maxWidth = 150.0; cellAlignment = center                                             }\n    }\n//sampleEnd\n}',Qe={toc:[]},en="wrapper";function nn(e){let{components:n,...t}=e;return(0,a.kt)(en,(0,o.Z)({},Qe,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This is a table that can modify its underlying ",(0,a.kt)("inlineCode",{parentName:"p"},"model"),". That means the table can do CRUD operations or sorting that will modify the model. This example shows sorting."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"mutableTable",height:"400",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},Je),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Tables require a ",(0,a.kt)(p.c6S,null)," for rendering. ",(0,a.kt)(p.YUL,null)," provides one.")))))}nn.isMDXComponent=!0;const tn='package controls\n\nimport io.nacular.doodle.controls.MultiSelectionModel\nimport io.nacular.doodle.controls.after\nimport io.nacular.doodle.controls.table.ColumnInfo\nimport io.nacular.doodle.controls.table.KeyValueTable\nimport io.nacular.doodle.controls.text.Label\nimport io.nacular.doodle.docs.utils.HighlightingTextVisualizer\nimport io.nacular.doodle.layout.constraints.Bounds\nimport io.nacular.doodle.layout.constraints.ConstraintDslContext\n\nfun keyValueTable(numberFormatter: (Int) -> String) {\n//sampleStart\n    val textVisualizer   = HighlightingTextVisualizer()\n    val numberVisualizer = textVisualizer.after { it: Int -> numberFormatter(it) }\n\n    val data = mapOf(\n        "New York City, NY" to 8_622_357,\n        "Los Angeles, CA"   to 4_085_014,\n        "Chicago, IL"       to 2_670_406,\n        "Houston, TX"       to 2_378_146,\n        "Phoenix, AZ"       to 1_743_469,\n        "Philadelphia, PA"  to 1_590_402,\n        "San Antonio, TX"   to 1_579_504,\n        "San Diego, CA"     to 1_469_490,\n        "Dallas, TX"        to 1_400_337,\n        "San Jose, CA"      to 1_036_242,\n    )\n\n    val alignment: ConstraintDslContext.(Bounds) -> Unit = {\n        it.left    eq 10\n        it.centerY eq parent.centerY\n    }\n\n    val table = KeyValueTable(\n        values         = data,\n        keyColumn      = ColumnInfo(Label("City"      ), textVisualizer  ) { headerAlignment = alignment; cellAlignment = alignment },\n        valueColumn    = ColumnInfo(Label("Population"), numberVisualizer) { headerAlignment = alignment; cellAlignment = alignment },\n        selectionModel = MultiSelectionModel(),\n    )\n//sampleEnd\n}',on={toc:[]},an="wrapper";function ln(e){let{components:n,...t}=e;return(0,a.kt)(an,(0,o.Z)({},on,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This is a table that represents a key-value map of data. The table only has two columns: one for the key and value in each pair."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"keyValueTable",height:"400",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},tn),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"KeyValueTables require a ",(0,a.kt)(p.c6S,null)," for rendering. ",(0,a.kt)("inlineCode",{parentName:"p"},"BasicTheme")," provides one.")))))}ln.isMDXComponent=!0;const rn="package controls\n\nimport io.nacular.doodle.controls.panels.GridPanel\nimport io.nacular.doodle.controls.panels.GridPanel.Companion.FitPanel\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.utils.Resizer\n\nfun gridPanel(\n    view1: View,\n    view2: View,\n    view3: View,\n    view4: View,\n    view5: View,\n    view6: View,\n    view7: View\n) {\n//sampleStart\n    val panel = GridPanel().apply {\n        rowSpacing         = { 10.0 }\n        columnSpacing      = { 10.0 }\n        rowSizingPolicy    = FitPanel // FitContent, or custom policy\n        columnSizingPolicy = FitPanel // FitContent, or custom policy\n\n        add(view1, columnSpan = 2     ) // defaults to row = 0, col = 0\n        add(view2, row = 1, column = 0)\n        add(view3, row = 1, column = 1)\n        add(view4, row = 2, column = 2)\n        add(view5, row = 0, column = 2, rowSpan = 2)\n        add(view6, row = 2, column = 0)\n        add(view7, row = 2, column = 1)\n\n        size = Size(200)\n\n        Resizer(this).apply { movable = false }\n    }\n//sampleEnd\n}",dn={toc:[]},sn="wrapper";function pn(e){let{components:n,...t}=e;return(0,a.kt)(sn,(0,o.Z)({},dn,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This control manages a generic list of ",(0,a.kt)("inlineCode",{parentName:"p"},"View"),"s and displays them within a grid layout. Items can be added to or removed from the panel. Each item added indicates the row/column it sits at and the number of rows / columns it spans. This, along with the ",(0,a.kt)("inlineCode",{parentName:"p"},"rowSizingPolicy")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"columnSizingPolicy")," control how the items are ultimately laid out."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"gridPanel",height:"400",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},rn))))}pn.isMDXComponent=!0;const mn="package controls\n\nimport io.nacular.doodle.controls.Photo\nimport io.nacular.doodle.controls.panels.ScrollPanel\nimport io.nacular.doodle.controls.panels.SplitPanel\nimport io.nacular.doodle.docs.utils.CircularView\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.image.Image\nimport io.nacular.doodle.layout.Insets\nimport io.nacular.doodle.utils.Orientation.Vertical\n\nfun splitPanel(image: Image) {\n//sampleStart\n    val panel = SplitPanel(orientation = Vertical /*| Horizontal*/).apply {\n        size      = Size(500, 300)\n        firstItem = ScrollPanel(CircularView(250.0))\n        lastItem  = Photo(image)\n        ratio     = 1f / 3\n        insets    = Insets(2.0)\n    }\n//sampleEnd\n}",cn='package controls\n\nimport io.nacular.doodle.controls.SingleItemSelectionModel\nimport io.nacular.doodle.controls.StringVisualizer\nimport io.nacular.doodle.controls.list.List\nimport io.nacular.doodle.controls.panels.ScrollPanel\nimport io.nacular.doodle.controls.panels.SplitPanel\nimport io.nacular.doodle.controls.toString\nimport io.nacular.doodle.docs.utils.panel\nimport io.nacular.doodle.drawing.TextMetrics\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.utils.Orientation.Horizontal\nimport io.nacular.doodle.utils.Resizer\n\nfun nestedSplitPanel(textMetrics: TextMetrics) {\n//sampleStart\n    val list = List(1..10, toString(StringVisualizer()), SingleItemSelectionModel(), fitContent = emptySet()).apply {\n        cellAlignment = { it.left eq 10 }\n    }\n    val main = panel(textMetrics, "1",    shadow = null, cornerRadius = 0.0)\n    val info = panel(textMetrics, "info", shadow = null, cornerRadius = 0.0)\n\n    val panel = SplitPanel(orientation = Horizontal).apply {\n        size      = Size(500, 300)\n        firstItem = SplitPanel().apply {\n            firstItem = ScrollPanel(list).apply {\n                contentWidthConstraints  = { it eq parent.width  }\n                contentHeightConstraints = { it eq max(list.idealSize?.height ?: list.height, parent.height) }\n            }\n            lastItem  = main\n            ratio     = 1f / 3\n        }\n\n        ratio    = 2f / 3\n        lastItem = info\n\n        Resizer(this).apply { movable = false }\n    }\n\n/**\n * Launched App using\n * -------------------------------------------\n * basicListBehavior(),\n * basicLabelBehavior(),\n * basicSplitPanelBehavior(showDivider = true),\n * nativeScrollPanelBehavior()\n */\n//sampleEnd\n}',un={toc:[]},hn="wrapper";function yn(e){let{components:n,...t}=e;return(0,a.kt)(hn,(0,o.Z)({},un,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This control divides a region into two areas, each occupied by a View. It also allows the user to change the portion of its viewport dedicated to either view."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"splitPanel",height:"400",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Horizontal",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"splitPanel",args:"[false]",height:"400",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},mn))),(0,a.kt)("p",null,"This shows how you might nest horizontal and vertical SplitPanels."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"multiSplitPanel",height:"400",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},cn))),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Requires a ",(0,a.kt)(p.Qcg,null)," for rendering. ",(0,a.kt)(p.YUL,null)," provides one.")))}yn.isMDXComponent=!0;const gn='package tabbedpanel\n\nimport io.nacular.doodle.controls.ScrollPanelVisualizer\nimport io.nacular.doodle.controls.StringVisualizer\nimport io.nacular.doodle.controls.invoke\nimport io.nacular.doodle.controls.itemVisualizer\nimport io.nacular.doodle.controls.panels.TabbedPanel\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.utils.Resizer\n\nfun example() {\n//sampleStart\n    val object1 = view {}\n    val object2 = view {}\n    val object3 = view {}\n    val object4 = view {}\n\n    val textVisualizer = StringVisualizer()\n\n    val mapping = mapOf(\n        object1 to "Circle",\n        object2 to "Second Tab",\n        object3 to "Cool Photo",\n        object4 to "Tab 4"\n    )\n\n    val panel = TabbedPanel(\n        visualizer    = ScrollPanelVisualizer(),                                                    // Each object is displayed within a ScrollPanel\n        tabVisualizer = itemVisualizer { item,_,_ -> textVisualizer(mapping[item] ?: "Unknown") },  // Each tab shows a hardcoded string from mapping\n        object1,\n        object2,\n        object3,\n        object4\n    ).apply {\n        size = Size(500, 300)\n\n        Resizer(this).apply { movable = false }\n    }\n//sampleEnd\n}',kn={toc:[]},Tn="wrapper";function vn(e){let{components:n,...t}=e;return(0,a.kt)(Tn,(0,o.Z)({},kn,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This control manages a generic list of items and displays them one at a time using an ",(0,a.kt)(p.yP2,null),'. Each item is generally\ntracked with a visual "tab" that allows selection of particular items in the list.'),(0,a.kt)("p",null,"The panel takes 2 visualizers; one to convert each item to a View that will be displayed as the tab, and another to convert each item to the main tab content. The View returned from the main visualizer will be scaled to fit the TabPanel when using ",(0,a.kt)(p.ILY,null),". In this example, we use a ",(0,a.kt)(p.DIO,null)," for the main content so it turns into a ScrollPanel with our view embedded. That works well for TabbedPanels that are meant to display arbitrary Views."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"tabbedPanel",height:"400",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},gn))),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"This control requires a ",(0,a.kt)(p.OJH,null)," for rendering. This demo uses the ",(0,a.kt)(p.ILY,null)," module which installs ",(0,a.kt)(p.nOU,null))))}vn.isMDXComponent=!0;const xn='package controls\n\nimport io.nacular.doodle.controls.ColorPicker\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.geometry.Size\n\nfun colorPicker() {\n//sampleStart\n    val picker = ColorPicker(Black).apply {\n        size = Size(300, 300)\n        // ...\n    }\n\n    println("Selected color is ${picker.color}")\n\n    picker.changed += { _, old, new ->\n        println("Color changed from: $old to $new")\n    }\n//sampleEnd\n}',fn={toc:[]},bn="wrapper";function wn(e){let{components:n,...t}=e;return(0,a.kt)(bn,(0,o.Z)({},fn,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This control allows a user to pick an RGB color by specifying a hue and opacity."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"colorPicker",height:"400",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},xn))))}wn.isMDXComponent=!0;const Sn="package controls\n\nimport io.nacular.doodle.controls.date.MonthPanel\nimport io.nacular.doodle.geometry.Size\nimport kotlinx.datetime.Clock\nimport kotlinx.datetime.TimeZone\nimport kotlinx.datetime.toLocalDateTime\n\n//sampleStart\nval today = Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault()).date\n\nval monthPanel = MonthPanel(today, /*itemVisualizer, selectionModel*/).apply {\n    size = Size(300)\n    // ...\n}\n//sampleEnd",Cn={toc:[]},Pn="wrapper";function Dn(e){let{components:n,...t}=e;return(0,a.kt)(Pn,(0,o.Z)({},Cn,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This control displays the days of a given month. It does not display a header with the day of the week though. This functionality is provided separately in the ",(0,a.kt)("a",{parentName:"p",href:"#daysoftheweekpanel"},"DaysOfTheWeekPanel"),". This simplifies reuse as a core component of calendars. Excluding the header means the ",(0,a.kt)("inlineCode",{parentName:"p"},"MonthPanel")," can be used in vertically scrolling calendars where the days are pinned to the top. Or in horizontal setups where the days are attached to it (within a container that has both panels)."),(0,a.kt)("p",null,"The panel can either show or hide days in the adjacent months using ",(0,a.kt)("inlineCode",{parentName:"p"},"showAdjacentMonths"),". It can also start at any day of the week via the ",(0,a.kt)("inlineCode",{parentName:"p"},"weekStart")," property."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"monthPanel",height:"400",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},Sn))))}Dn.isMDXComponent=!0;const Mn="package controls\n\nimport io.nacular.doodle.controls.date.DaysOfTheWeekPanel\nimport kotlinx.datetime.DayOfWeek\n\n//sampleStart\nval panel = DaysOfTheWeekPanel(weekStart = DayOfWeek.MONDAY).apply {\n    // ...\n}\n\n/*\nstyled using\n\nbasicDaysOfTheWeekPanelBehavior(defaultVisualizer = itemVisualizer { day, previous, _ ->\n    val text = StyledText(day.name.take(1))\n\n    when (previous) {\n        is Label -> previous.apply    { fitText = emptySet(); this.styledText = text }\n        else     -> Label(text).apply { fitText = emptySet()                         }\n    }\n})\n*/\n//sampleEnd",zn={toc:[]},Ln="wrapper";function Nn(e){let{components:n,...t}=e;return(0,a.kt)(Ln,(0,o.Z)({},zn,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This control is meant as a header for the ",(0,a.kt)("inlineCode",{parentName:"p"},"MonthPanel"),". It shows days of the week starting at the given ",(0,a.kt)("inlineCode",{parentName:"p"},"weekStart")," property."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"daysOfWeek",height:"200",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},Mn))))}Nn.isMDXComponent=!0;const In='package controls\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.controls.ItemVisualizer\nimport io.nacular.doodle.controls.ListModel\nimport io.nacular.doodle.controls.SelectionModel\nimport io.nacular.doodle.controls.SingleItemSelectionModel\nimport io.nacular.doodle.controls.date.DaysOfTheWeekPanel\nimport io.nacular.doodle.controls.date.MonthPanel\nimport io.nacular.doodle.controls.itemVisualizer\nimport io.nacular.doodle.controls.panels.ScrollPanel\nimport io.nacular.doodle.controls.text.Label\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.opacity\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.drawing.rect\nimport io.nacular.doodle.event.PointerEvent\nimport io.nacular.doodle.event.PointerListener\nimport io.nacular.doodle.geometry.Circle\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.layout.constraints.Strength\nimport io.nacular.doodle.layout.constraints.center\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.layout.constraints.fill\nimport io.nacular.doodle.system.SystemInputEvent\nimport io.nacular.doodle.text.invoke\nimport io.nacular.doodle.theme.Theme\nimport io.nacular.doodle.theme.ThemeManager\nimport io.nacular.doodle.theme.basic.list.basicVerticalListBehavior\nimport io.nacular.doodle.utils.Dimension\nimport io.nacular.doodle.utils.Resizer\nimport kotlinx.datetime.Clock\nimport kotlinx.datetime.DatePeriod\nimport kotlinx.datetime.LocalDate\nimport kotlinx.datetime.TimeZone\nimport kotlinx.datetime.minus\nimport kotlinx.datetime.monthsUntil\nimport kotlinx.datetime.plus\nimport kotlinx.datetime.toLocalDateTime\nimport kotlin.math.min\n\nprivate class CalendarDay(private val today: LocalDate, private var day: LocalDate, private val panel: MonthPanel): View() {\n    private val label = Label()\n\n    init {\n        styleChanged += { rerender() }\n\n        clipCanvasToBounds = false\n\n        children += label\n\n        layout = constrain(label) {\n            it.center eq parent.center\n        }\n\n        pointerChanged += object: PointerListener {\n            private var pressed     = false\n            private var pointerOver = false\n\n            override fun entered (event: PointerEvent) { pointerOver = true  }\n            override fun exited  (event: PointerEvent) { pointerOver = false }\n            override fun pressed (event: PointerEvent) { pressed     = true  }\n            override fun released(event: PointerEvent) {\n                if (pointerOver && pressed) {\n                    setOf(day).also {\n                        panel.apply {\n                            when {\n                                SystemInputEvent.Modifier.Ctrl in event.modifiers || SystemInputEvent.Modifier.Meta in event.modifiers -> toggleSelection(it)\n                                SystemInputEvent.Modifier.Shift in event.modifiers && lastSelection != null                            -> {\n                                    selectionAnchor?.let { anchor ->\n                                        val current = day\n                                        when {\n                                            current < anchor  -> setSelection((anchor downTo current))\n                                            anchor  < current -> setSelection((anchor  .. current).toSet())\n                                        }\n                                    }\n                                }\n                                else                                                                                                   -> setSelection(it)\n                            }\n                        }\n                    }\n                }\n                pressed = false\n            }\n        }\n\n        update(panel, day)\n    }\n\n    override fun render(canvas: Canvas) {\n        backgroundColor?.let {\n            val oneDay = DatePeriod(days = 1)\n            var left   = width / 2\n            var right  = left\n\n            if (panel.selected(day - oneDay)) {\n                left = 0.0\n            }\n            if (panel.selected(day + oneDay)) {\n                right = width\n            }\n\n            val radius = min(width, height) / 2\n\n            canvas.circle(Circle(radius = radius, center = Point(width/2, height/2)), fill = it.paint)\n\n            canvas.rect(Rectangle(left, height / 2 - radius, right - left + 1, 2 * radius), fill = it.paint)\n        }\n    }\n\n    private infix fun LocalDate.downTo(other: LocalDate): Set<LocalDate> {\n        var d = this\n        val result = mutableSetOf<LocalDate>()\n        while (d >= other) {\n            result += d\n            d -= DatePeriod(days = 1)\n        }\n\n        return result\n    }\n\n    private fun ClosedRange<LocalDate>.toSet(): Set<LocalDate> {\n        var d = start\n        val result = mutableSetOf<LocalDate>()\n\n        while (d <= endInclusive) {\n            result += d\n            d += DatePeriod(days = 1)\n        }\n\n        return result\n    }\n\n    fun update(panel: MonthPanel, day: LocalDate) {\n        this.day = day\n\n        val text = "${day.dayOfMonth}"\n\n        val styledText = when {\n            day == today && panel.startDate.month == day.month -> Color.Red     (text)\n            panel.selected(day)                                -> Color.Black   (text)\n            day.month != panel.startDate.month                 -> Color.Darkgray(text)\n            else                                               -> Color.White   (text)\n        }\n\n        backgroundColor = when {\n            panel.selected(day) -> Color.Lightgray\n            else                -> null\n        }\n\n        label.styledText = styledText\n    }\n}\n\nprivate class NamedMonthPanel(\n    date: LocalDate,\n    itemVisualizer: ItemVisualizer<LocalDate, MonthPanel> = itemVisualizer { day, previous, panel ->\n        val text = "${day.dayOfMonth}"\n\n        when (previous) {\n            is Label -> previous.apply { fitText = emptySet(); this.text = text }\n            else     -> Label(text).apply { fitText = emptySet() }\n        }.also {\n            it.enabled = day.month == panel.startDate.month\n        }\n    },\n    selectionModel: SelectionModel<LocalDate>? = null\n): View() {\n    private val header = Label()\n    val monthPanel = MonthPanel(date, itemVisualizer, selectionModel).apply {\n        monthChanged += {\n            updateHeader()\n        }\n\n        acceptsThemes = false\n    }\n\n    private fun updateHeader() {\n        header.styledText = Color.White("${monthPanel.startDate.month.name.lowercase().replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }} ${monthPanel.startDate.year}")\n    }\n\n    init {\n        updateHeader()\n\n        children += listOf(header, monthPanel)\n\n        layout = constrain(header, monthPanel) { h, m ->\n            h.top     eq  0\n            h.left    eq 10\n            h.height.preserve\n            m.top     eq h.bottom\n            m.width   eq parent.width\n            (m.bottom eq parent.bottom) .. Strength.Strong\n        }\n    }\n}\n\nprivate class MonthModel(private val dates: ClosedRange<LocalDate>): ListModel<LocalDate> {\n    private val LocalDate.firstDayOfMonth: LocalDate get() = LocalDate(year = year, month = month, dayOfMonth = 1)\n\n    override val size = dates.start.firstDayOfMonth.monthsUntil(dates.endInclusive.firstDayOfMonth) + 1\n\n    override fun contains(value: LocalDate) = value in dates\n\n    override fun get(index: Int): Result<LocalDate> {\n        if (index < 0 || index > size) return Result.failure(IndexOutOfBoundsException())\n\n        return Result.success(dates.start.firstDayOfMonth + DatePeriod(months = index))\n    }\n\n    override fun section(range: ClosedRange<Int>): List<LocalDate> {\n        TODO("Not yet implemented")\n    }\n\n    override fun iterator(): Iterator<LocalDate> = object: Iterator<LocalDate> {\n        private var index = 0\n\n        override fun hasNext() = index < size\n\n        override fun next() = this@MonthModel[index++].getOrThrow()\n    }\n}\n\n//sampleStart\nclass CalendarApp(display: Display, themeManager: ThemeManager, theme: Theme): Application {\n    private val offsetMonths = 20\n\n    private val monthList by lazy {\n        val today                = Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault()).date\n        val sharedSelectionModel = SingleItemSelectionModel<LocalDate>()\n\n        io.nacular.doodle.controls.list.List(\n            model = MonthModel(today - DatePeriod(months = offsetMonths)..today + DatePeriod(months = offsetMonths)),\n            itemVisualizer = itemVisualizer { item, previous, _ ->\n                when (previous) {\n                    is NamedMonthPanel -> previous.also { it.monthPanel.setDate(item) }\n                    else               -> NamedMonthPanel(\n                        item,\n                        itemVisualizer { day, previous, panel ->\n                            when (previous) {\n                                is CalendarDay -> previous.apply { update(panel, day) }\n                                else           -> CalendarDay(today, day, panel)\n                            }\n                        },\n                        selectionModel = sharedSelectionModel\n                    ).apply {\n                        monthPanel.showAdjacentMonths = true\n                    }\n                }\n            },\n            fitContent = setOf(Dimension.Height),\n        ).apply {\n            behavior      = basicVerticalListBehavior(itemHeight = 300.0, numColumns = 1, evenItemColor = Color.Transparent, oddItemColor = Color.Transparent)\n            cellAlignment = fill\n            acceptsThemes = false\n\n            displayChange += { _, _, _ ->\n                scrollTo(offsetMonths)\n            }\n        }\n    }\n\n    init {\n        themeManager.selected = theme\n\n        display += object: View() {\n            init {\n                clipCanvasToBounds = false\n\n                val scrollPanel = ScrollPanel(monthList).apply {\n                    size = Size(300, 300)\n                    contentWidthConstraints = { it eq width - verticalScrollBarWidth }\n                    scrollBarDimensionsChanged += {\n                        relayout()\n                    }\n                }\n\n                children += listOf(DaysOfTheWeekPanel(), scrollPanel)\n\n                layout = constrain(children[0], children[1]) { header, scroll ->\n                    header.top     eq 0\n                    header.width   eq parent.width - scrollPanel.verticalScrollBarWidth\n                    header.height  eq 50\n                    scroll.top     eq header.bottom\n                    scroll.width   eq parent.width\n                    (scroll.bottom eq parent.bottom) .. Strength.Strong\n                }\n\n                bounds = Rectangle(300, 350)\n                Resizer(this).apply {\n                    movable = false\n                }\n            }\n\n            override fun render(canvas: Canvas) {\n                canvas.outerShadow(vertical = 10.0, blurRadius = 10.0, color = Black.opacity(0.5f)) {\n                    rect(bounds.atOrigin, color = Color(0xccccccu).inverted)\n                }\n            }\n        }\n\n        display.layout = constrain(display.first(), center)\n    }\n\n    override fun shutdown() {}\n}\n//sampleEnd',Zn="package controls\n\nimport io.nacular.doodle.application.application\nimport io.nacular.doodle.controls.itemVisualizer\nimport io.nacular.doodle.controls.text.Label\nimport io.nacular.doodle.drawing.Color.Companion.Transparent\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.text.StyledText\nimport io.nacular.doodle.theme.basic.BasicTheme.Companion.basicDaysOfTheWeekPanelBehavior\nimport io.nacular.doodle.theme.basic.BasicTheme.Companion.basicLabelBehavior\nimport io.nacular.doodle.theme.basic.BasicTheme.Companion.basicMonthPanelBehavior\nimport io.nacular.doodle.theme.native.NativeTheme.Companion.nativeScrollPanelBehavior\nimport org.kodein.di.instance\n\n//sampleStart\nfun main() {\n    val appModules = listOf(\n        basicLabelBehavior(),\n        basicMonthPanelBehavior(),\n        nativeScrollPanelBehavior(),\n        basicDaysOfTheWeekPanelBehavior(\n            background        = Transparent.paint,\n            defaultVisualizer = itemVisualizer { day, previous, _ ->\n                val text = StyledText(day.name.take(1), foreground = White.paint)\n\n                when (previous) {\n                    is Label -> previous.apply { fitText = emptySet(); this.styledText = text }\n                    else     -> Label(text).apply { fitText = emptySet() }\n                }\n            }\n        )\n    )\n\n    application(modules = appModules) {\n        CalendarApp(\n            display      = instance(),\n            themeManager = instance(),\n            theme        = instance()\n        )\n    }\n}\n//sampleEnd",Fn={toc:[]},Vn="wrapper";function Bn(e){let{components:n,...t}=e;return(0,a.kt)(Vn,(0,o.Z)({},Fn,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This shows the ",(0,a.kt)("inlineCode",{parentName:"p"},"MonthPanel")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"DaysOfTheWeekPanel")," being used to create a simple vertical calendar with one column. This calendar uses a ",(0,a.kt)("inlineCode",{parentName:"p"},"List<LocalDate>"),"\nwith a model that contains the months of the current year. Each date in the list is visualized using a custom View that simply holds a label and\n",(0,a.kt)("inlineCode",{parentName:"p"},"MonthPanel"),". These are updated as the list scrolls and items are recycled."),(0,a.kt)("p",null,"The custom View provides a visualizer to the ",(0,a.kt)("inlineCode",{parentName:"p"},"MonthPanel")," that controls the colors for each day as well as the background selection rendering."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"calendar",height:"450",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Code",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},In),(0,a.kt)("p",null,"This app uses many UI controls that can be styled using various behavior modules. The following shows how it is configured."),(0,a.kt)(s.O,{mdxType:"KPlayground"},Zn))))}Bn.isMDXComponent=!0;var On=t(4456);const An={toc:[]},Rn="wrapper";function Un(e){let{components:n,...t}=e;return(0,a.kt)(Rn,(0,o.Z)({},An,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Forms provide a way of collecting structured data from a user. This is generally quite complex given the wide range of visual representations, data types, and validation steps usually involved. Doodle simplifies this entire flow with a single control that offers full customization and type safety."),(0,a.kt)("p",null,"This example shows the use of validating text inputs, a radio list, and a sub form to gather some data about a person."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"Demo",mdxType:"TabItem"},(0,a.kt)(d.l,{functionName:"form",height:"600",mdxType:"DoodleApp"})),(0,a.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,a.kt)(s.O,{mdxType:"KPlayground"},On.Z))),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Form fields can bind to any type and use any ","[View]"," for display. This is done using a ",(0,a.kt)(p.Kox,null)," or the ",(0,a.kt)(p.FZO,null)," dsl.")))}Un.isMDXComponent=!0;const En={title:"Catalog"},Xn="UI Components",_n={unversionedId:"ui_components/overview",id:"ui_components/overview",title:"Catalog",description:"Doodle has several UI components in the Controls library. Here are a few of the common ones. Access these by adding a dependency to",source:"@site/docs/ui_components/overview.mdx",sourceDirName:"ui_components",slug:"/ui_components/overview",permalink:"/doodle/docs/ui_components/overview",draft:!1,tags:[],version:"current",frontMatter:{title:"Catalog"},sidebar:"tutorialSidebar",previous:{title:"Drag \u2022 Drop",permalink:"/doodle/docs/dragdrop"},next:{title:"Forms",permalink:"/doodle/docs/ui_components/form"}},Kn={},Wn=[{value:"<api.Label>Label</api.Label>",id:"label",level:3},{value:"<api.TextField>TextField</api.TextField>",id:"textfield",level:3},{value:"<api.PushButton>PushButton</api.PushButton>",id:"pushbutton",level:3},{value:"<api.CheckBox>CheckBox</api.CheckBox>",id:"checkbox",level:3},{value:"<api.RadioButton>RadioButton</api.RadioButton>",id:"radiobutton",level:3},{value:"<api.Switch>Switch</api.Switch>",id:"switch",level:3},{value:"<api.FileSelector>FileSelector</api.FileSelector>",id:"fileselector",level:3},{value:"<api.Photo>Photo</api.Photo>",id:"photo",level:3},{value:"<api.LazyPhoto>LazyPhoto</api.LazyPhoto>",id:"lazyphoto",level:3},{value:"<api.ProgressBar>ProgressBar</api.ProgressBar>",id:"progressbar",level:3},{value:"<api.Slider>Slider</api.Slider>",id:"slider",level:3},{value:"<api.CircularSlider>CircularSlider</api.CircularSlider>",id:"circularslider",level:3},{value:"<api.RangeSlider>RangeSlider</api.RangeSlider>",id:"rangeslider",level:3},{value:"<api.CircularRangeSlider>CircularRangeSlider</api.CircularRangeSlider>",id:"circularrangeslider",level:3},{value:"<api.Spinner>Spinner</api.Spinner>",id:"spinner",level:3},{value:"<api.Dropdown>Dropdown</api.Dropdown>",id:"dropdown",level:3},{value:"<api.StarRater>StarRater</api.StarRater>",id:"starrater",level:3},{value:"<api.List>List</api.List>",id:"list",level:3},{value:"<api.Tree>Tree</api.Tree>",id:"tree",level:3},{value:"<api.TreeTable>TreeTable</api.TreeTable>",id:"treetable",level:3},{value:"<api.Table>Table</api.Table>",id:"table",level:3},{value:"<api.MutableTable>MutableTable</api.MutableTable>",id:"mutabletable",level:3},{value:"<api.KeyValueTable>KeyValueTable</api.KeyValueTable>",id:"keyvaluetable",level:3},{value:"<api.GridPanel>GridPanel</api.GridPanel>",id:"gridpanel",level:3},{value:"<api.SplitPanel>SplitPanel</api.SplitPanel>",id:"splitpanel",level:3},{value:"<api.TabbedPanel>TabbedPanel</api.TabbedPanel>",id:"tabbedpanel",level:3},{value:"<api.ColorPicker>ColorPicker</api.ColorPicker>",id:"colorpicker",level:3},{value:"<api.MonthPanel>MonthPanel</api.MonthPanel>",id:"monthpanel",level:3},{value:"<api.DaysOfTheWeekPanel>DaysOfTheWeekPanel</api.DaysOfTheWeekPanel>",id:"daysoftheweekpanel",level:3},{value:"Custom Calendar",id:"custom-calendar",level:3},{value:"<api.Form>Form</api.Form>",id:"form",level:3}],qn={toc:Wn},Yn="wrapper";function jn(e){let{components:n,...t}=e;return(0,a.kt)(Yn,(0,o.Z)({},qn,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"ui-components"},"UI Components"),(0,a.kt)("p",null,"Doodle has several UI components in the Controls library. Here are a few of the common ones. Access these by adding a dependency to\nthe ",(0,a.kt)("inlineCode",{parentName:"p"},"Controls")," library in your build file."),(0,a.kt)("p",null,"Most of these components rely entirely on their ",(0,a.kt)(p.cgf,null)," for rendering. Moreover, they do not have defaults for them to minimize bundle size. So you need to specify behaviors explicitly or use a ",(0,a.kt)("a",{parentName:"p",href:"/doodle/docs/themes"},(0,a.kt)("strong",{parentName:"a"},"Theme"))," that provides them for the controls you use."),(0,a.kt)(r.ZP,{name:"Controls",kotlin:c.Z,groovy:m.Z,mdxType:"LibraryRequired"}),(0,a.kt)("hr",null),(0,a.kt)("h3",{id:"label"},(0,a.kt)(p.__J,null,"Label")),(0,a.kt)(k,{mdxType:"Label"}),(0,a.kt)("h3",{id:"textfield"},(0,a.kt)(p.nvn,null,"TextField")),(0,a.kt)(w,{mdxType:"TextField"}),(0,a.kt)("h3",{id:"pushbutton"},(0,a.kt)(p.rih,null,"PushButton")),(0,a.kt)(D,{mdxType:"PushButton"}),(0,a.kt)("h3",{id:"checkbox"},(0,a.kt)(p.JgP,null,"CheckBox")),(0,a.kt)(N,{mdxType:"CheckBox"}),(0,a.kt)("h3",{id:"radiobutton"},(0,a.kt)(p.EUY,null,"RadioButton")),(0,a.kt)(V,{mdxType:"RadioButton"}),(0,a.kt)("h3",{id:"switch"},(0,a.kt)(p.rsf,null,"Switch")),(0,a.kt)(R,{mdxType:"Switch"}),(0,a.kt)("h3",{id:"fileselector"},(0,a.kt)(p.F5R,null,"FileSelector")),(0,a.kt)(W,{mdxType:"FileSelector"}),(0,a.kt)("h3",{id:"photo"},(0,a.kt)(p.PzI,null,"Photo")),(0,a.kt)(H,{mdxType:"Photo"}),(0,a.kt)("h3",{id:"lazyphoto"},(0,a.kt)(p.LDi,null,"LazyPhoto")),(0,a.kt)(Q,{mdxType:"LazyPhoto"}),(0,a.kt)("h3",{id:"progressbar"},(0,a.kt)(p.kod,null,"ProgressBar")),(0,a.kt)(ie,{mdxType:"ProgressBar"}),(0,a.kt)("h3",{id:"slider"},(0,a.kt)(p.iRW,null,"Slider")),(0,a.kt)(se,{mdxType:"Slider"}),(0,a.kt)("h3",{id:"circularslider"},(0,a.kt)(p.OFW,null,"CircularSlider")),(0,a.kt)(ue,{mdxType:"CircularSlider"}),(0,a.kt)("h3",{id:"rangeslider"},(0,a.kt)(p.U2U,null,"RangeSlider")),(0,a.kt)(ke,{mdxType:"RangeSlider"}),(0,a.kt)("h3",{id:"circularrangeslider"},(0,a.kt)(p.Ksw,null,"CircularRangeSlider")),(0,a.kt)(fe,{mdxType:"CircularRangeSlider"}),(0,a.kt)("h3",{id:"spinner"},(0,a.kt)(p.$jN,null,"Spinner")),(0,a.kt)(Ce,{mdxType:"Spinner"}),(0,a.kt)("h3",{id:"dropdown"},(0,a.kt)(p.Ltx,null,"Dropdown")),(0,a.kt)(ze,{mdxType:"DropDown"}),(0,a.kt)("h3",{id:"starrater"},(0,a.kt)(p.pA1,null,"StarRater")),(0,a.kt)(Ze,{mdxType:"StarRater"}),(0,a.kt)("h3",{id:"list"},(0,a.kt)(p.aVo,null,"List")),(0,a.kt)(Re,{mdxType:"List"}),(0,a.kt)("h3",{id:"tree"},(0,a.kt)(p.mpN,null,"Tree")),(0,a.kt)(_e,{mdxType:"Tree"}),(0,a.kt)("h3",{id:"treetable"},(0,a.kt)(p.iwC,null,"TreeTable")),(0,a.kt)(Ye,{mdxType:"TreeTable"}),(0,a.kt)("h3",{id:"table"},(0,a.kt)(p.iA_,null,"Table")),(0,a.kt)(Ge,{mdxType:"Table"}),(0,a.kt)("h3",{id:"mutabletable"},(0,a.kt)(p.yxz,null,"MutableTable")),(0,a.kt)(nn,{mdxType:"MutableTable"}),(0,a.kt)("h3",{id:"keyvaluetable"},(0,a.kt)(p.vud,null,"KeyValueTable")),(0,a.kt)(ln,{mdxType:"KeyValueTable"}),(0,a.kt)("h3",{id:"gridpanel"},(0,a.kt)(p.y0D,null,"GridPanel")),(0,a.kt)(pn,{mdxType:"GridPanel"}),(0,a.kt)("h3",{id:"splitpanel"},(0,a.kt)(p.yTY,null,"SplitPanel")),(0,a.kt)(yn,{mdxType:"SplitPanel"}),(0,a.kt)("h3",{id:"tabbedpanel"},(0,a.kt)(p.UiW,null,"TabbedPanel")),(0,a.kt)(vn,{mdxType:"TabbedPanel"}),(0,a.kt)("h3",{id:"colorpicker"},(0,a.kt)(p.zH8,null,"ColorPicker")),(0,a.kt)(wn,{mdxType:"ColorPicker"}),(0,a.kt)("h3",{id:"monthpanel"},(0,a.kt)(p.fxt,null,"MonthPanel")),(0,a.kt)(Dn,{mdxType:"MonthPanel"}),(0,a.kt)("h3",{id:"daysoftheweekpanel"},(0,a.kt)(p.qQx,null,"DaysOfTheWeekPanel")),(0,a.kt)(Nn,{mdxType:"DaysOfTheWeekPanel"}),(0,a.kt)("h3",{id:"custom-calendar"},"Custom Calendar"),(0,a.kt)(Bn,{mdxType:"CalendarDemo"}),(0,a.kt)("h3",{id:"form"},(0,a.kt)(p.l09,null,"Form")),(0,a.kt)(Un,{mdxType:"Form"}))}jn.isMDXComponent=!0},4456:(e,n,t)=>{t.d(n,{Z:()=>o});const o='package controls\n\nimport controls.Gender.Female\nimport controls.Gender.Male\nimport io.nacular.doodle.controls.buttons.PushButton\nimport io.nacular.doodle.controls.form.Form\nimport io.nacular.doodle.controls.form.LabeledConfig\nimport io.nacular.doodle.controls.form.TextFieldConfig\nimport io.nacular.doodle.controls.form.form\nimport io.nacular.doodle.controls.form.labeled\nimport io.nacular.doodle.controls.form.radioList\nimport io.nacular.doodle.controls.form.textField\nimport io.nacular.doodle.controls.form.verticalLayout\nimport io.nacular.doodle.drawing.Color.Companion.Red\nimport io.nacular.doodle.drawing.Font\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.text.StyledText\nimport io.nacular.doodle.text.invoke\nimport io.nacular.doodle.utils.ToStringIntEncoder\n\nenum class Gender { Male, Female }\n\nfun form(smallFont: Font) {\n    fun <T> LabeledConfig.textFieldConfig(placeHolder: String = "", errorText: StyledText? = null): TextFieldConfig<T>.() -> Unit = {\n        val initialHelperText = help.styledText\n\n        help.font             = smallFont\n        textField.placeHolder = placeHolder\n        onValid               = { help.styledText = initialHelperText }\n        onInvalid             = {\n            if (!textField.hasFocus) {\n                help.styledText = errorText ?: it.message?.let { Red(it) } ?: help.styledText\n            }\n        }\n    }\n\n    val submit = PushButton("Submit").apply {\n        enabled = false\n        size = Size(100, 32)\n    }\n\n    val twoDigitNumber = Regex("^1[0-5]\\\\d|^[1-9]\\\\d|^[1-9]")\n\n//sampleStart\n    val form = Form { this(\n        +labeled("Name", help = "3+ letters") {\n            textField(Regex(".{3,}"), config = textFieldConfig("Enter your name"))\n        },\n        +labeled("Age", help = "1 or 2 digit number") {\n            textField(twoDigitNumber, ToStringIntEncoder, config = textFieldConfig())\n        },\n        Female to labeled("Gender") { radioList(Male, Female) { spacing = 12.0 } },\n        +form { this(\n            +labeled("Text [Sub-form]", help = "Can be blank") {\n                textField(Regex(".*"), config = textFieldConfig())\n            },\n            +labeled("Number [Sub-form]", help = "1 to 10") {\n                textField(\n                    twoDigitNumber,\n                    ToStringIntEncoder,\n                    validator = { it <= 10 },\n                    config    = textFieldConfig()\n                )\n            }\n        ) { first, second ->\n            // nested Form creates a Pair<String, Int>\n            first to second\n        } },\n        onInvalid = { submit.enabled = false },\n    ) { name, age, gender, pair ->\n        submit.enabled = true\n        println("[Form valid] Name: $name, Age: $age, Gender: $gender, Sub-form: $pair") // <---- check console for output\n    } }.apply {\n        // configure the Form view itself\n        size      = Size(300, 100)\n        layout    = verticalLayout(this, spacing = 12.0, itemHeight = 32.0)\n        focusable = false\n    }\n//sampleEnd\n}'},1453:(e,n,t)=>{t.d(n,{Z:()=>o});const o="package animation\n\ndoodle_version = '0.9.1'\n\n//sampleStart\n// ...\n\ndependencies {\n    implementation \"io.nacular.doodle:controls:$doodle_version\"\n}\n\n// ...\n//sampleEnd"},9765:(e,n,t)=>{t.d(n,{Z:()=>o});const o='// ...\n\ndependencies {\n    implementation ("io.nacular.doodle:controls:$doodleVersion")\n}\n\n// ...'}}]);