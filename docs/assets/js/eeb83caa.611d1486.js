"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[2455],{3729:(n,e,o)=>{o.d(e,{Ay:()=>s,RM:()=>r});var i=o(4848),a=o(8453),t=(o(5537),o(9329),o(4069));const r=[];function l(n){const e={admonition:"admonition",p:"p",...(0,a.R)(),...n.components};return(0,i.jsxs)(e.admonition,{title:"Module Required",type:"info",children:[(0,i.jsxs)("p",{children:["You must include the ",n.link," in your application in order to use these features."]}),(0,i.jsx)(t.v,{children:n.module}),(0,i.jsx)(e.p,{children:"Doodle uses opt-in modules like this to improve bundle size."})]})}function s(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(l,{...n})}):l(n)}},8144:(n,e,o)=>{o.d(e,{A:()=>i});const i="package rendering\n\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.Color\nimport io.nacular.doodle.drawing.GradientPaint.Stop\nimport io.nacular.doodle.drawing.SweepGradientPaint\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.measured.units.Angle\nimport io.nacular.measured.units.Measure\n\n/**\n * Example showing how to use [SweepGradientPaint]s.\n */\nfun sweepGradientPaint(color1: Color, color2: Color, center: Point, rotation: Measure<Angle>) {\n//sampleStart\n    view {\n        render = {\n            // Simple version with 2 colors\n            rect(bounds.atOrigin, SweepGradientPaint(\n                color1,\n                color2,\n                center,\n                rotation\n            ))\n        }\n    }\n\n    view {\n        render = {\n            // Also able to use a list of color stops\n            rect(\n                bounds.atOrigin, SweepGradientPaint(\n                    listOf(\n                        Stop(color1, 0f),\n                        Stop(color1, 1f / 3),\n                        // ...\n                    ),\n                    center,\n                    rotation\n                )\n            )\n        }\n    }\n//sampleEnd\n}"},8893:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>$,contentTitle:()=>K,default:()=>nn,frontMatter:()=>X,metadata:()=>i,toc:()=>Q});const i=JSON.parse('{"id":"rendering","title":"Rendering","description":"Doodle automatically manages rendering of Views, and this covers almost all use-cases. Each  draws its content to a Canvas provided during calls to the  method. This either presents the View\'s contents on the screen for the first time or updates them on subsequent calls.","source":"@site/docs/rendering.mdx","sourceDirName":".","slug":"/rendering","permalink":"/doodle/docs/rendering","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"hide_title":true,"title":"Rendering"},"sidebar":"tutorialSidebar","previous":{"title":"Views","permalink":"/doodle/docs/views"},"next":{"title":"Layout","permalink":"/doodle/docs/layout"}}');var a=o(4848),t=o(8453),r=o(5537),l=o(9329),s=o(7269),d=o(4069),c=o(9172),p=o(3729);const m='package rendering\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.text\n\n//sampleStart\nclass MyView: View() {\n    override fun render(canvas: Canvas) {\n        canvas.flipHorizontally(around = width / 2) {\n            text("hello", color = Black)\n        }\n    }\n}\n//sampleEnd',u="import io.nacular.doodle.core.View\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color.Companion.Blue\nimport io.nacular.doodle.drawing.paint\n\n//sampleStart\nclass RectView: View() {\n    override fun render(canvas: Canvas) {\n        canvas.rect(bounds.atOrigin, Blue.paint)\n    }\n}\n//sampleEnd",h='package timerdsl\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.Color.Companion.Green\nimport io.nacular.doodle.drawing.Color.Companion.Red\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.drawing.rect\nimport io.nacular.doodle.drawing.text\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.scheduler.Scheduler\nimport io.nacular.doodle.time.Clock\nimport io.nacular.measured.units.Time.Companion.milliseconds\nimport io.nacular.measured.units.times\n\n//sampleStart\nclass Timer(display: Display, clock: Clock, scheduler: Scheduler): Application {\n    init {\n        display += view {\n            suggestSize(Size(200))\n\n            scheduler.every(1 * milliseconds) {\n                rerender()\n            }\n\n            render = {\n                rect(bounds.at(x = 0.0, y = 20.0), color = Green)\n                rect(bounds.atOrigin.inset(0.5), Stroke(Red))\n                text("${clock.epoch}", color = Black)\n            }\n        }\n    }\n\n    override fun shutdown() {}\n}\n//sampleEnd',g='package timerrenderprop\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.renderProperty\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.Color.Companion.Green\nimport io.nacular.doodle.drawing.Color.Companion.Red\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.drawing.rect\nimport io.nacular.doodle.drawing.text\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.scheduler.Scheduler\nimport io.nacular.doodle.time.Clock\nimport io.nacular.measured.units.Time.Companion.milliseconds\nimport io.nacular.measured.units.times\n\n//sampleStart\nclass Timer(display: Display, clock: Clock, scheduler: Scheduler): Application {\n    init {\n        display += object: View() {\n            var time by renderProperty(clock.epoch)\n\n            init {\n                suggestSize(Size(200))\n\n                scheduler.every(1 * milliseconds) {\n                    time = clock.epoch\n                }\n            }\n\n            override fun render(canvas: Canvas) {\n                canvas.rect(bounds.at(x = 0.0, y = 20.0), color = Green)\n                canvas.rect(bounds.atOrigin, Stroke(Red))\n                canvas.text("$time", color = Black)\n            }\n        }\n    }\n\n    override fun shutdown() {}\n}\n//sampleEnd',f="package rendering\n\nimport io.nacular.doodle.drawing.Color\nimport io.nacular.doodle.drawing.darker\nimport io.nacular.doodle.drawing.opacity\nimport io.nacular.doodle.drawing.paint\n\nfun colors() {\n//sampleStart\n    Color(0xff0000u                ) // create red\n    Color(0xffffffu, opacity = 0.5f) // white with 0.5 opacity\n    Color.Red                        // build-in red\n    Color.Blue opacity 0.5f          // blue with 0.5 opacity\n    Color.Blue.inverted              // inverse of blue\n    Color.Lightgray.darker(0.5f)     // darker gray\n    Color.Blue.paint                 // paint from a color\n//sampleEnd\n}",x="package rendering\n\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.Color\nimport io.nacular.doodle.drawing.paint\n\nfun colorPaint(color: Color) {\n//sampleStart\n    view {\n        render = {\n            rect(bounds.atOrigin, color.paint)\n        }\n    }\n//sampleEnd\n}",w="package rendering\n\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.Color\nimport io.nacular.doodle.drawing.GradientPaint.Stop\nimport io.nacular.doodle.drawing.LinearGradientPaint\nimport io.nacular.doodle.geometry.Point\n\n/**\n * Example showing how to use [LinearGradientPaint]s.\n */\nfun linearPaint(color1: Color, color2: Color, point1: Point, point2: Point) {\n//sampleStart\n    view {\n        render = {\n            // Simple version with 2 colors\n            rect(bounds.atOrigin, LinearGradientPaint(\n                color1,\n                color2,\n                point1,\n                point2\n            ))\n        }\n    }\n\n    view {\n        render = {\n            // Also able to use a list of color stops\n            rect(bounds.atOrigin, LinearGradientPaint(\n                listOf(\n                    Stop(color1, 0f  ),\n                    Stop(color1, 1f/3),\n                    // ...\n                ),\n                point1,\n                point2\n            ))\n        }\n    }\n//sampleEnd\n}",v="package rendering\n\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.Color\nimport io.nacular.doodle.drawing.GradientPaint.Stop\nimport io.nacular.doodle.drawing.RadialGradientPaint\nimport io.nacular.doodle.geometry.Circle\n\n/**\n * Example showing how to use [RadialGradientPaint]s.\n */\nfun radialPaint(color1: Color, color2: Color, circle1: Circle, circle2: Circle) {\n//sampleStart\n    view {\n        render = {\n            // Simple version with 2 colors\n            rect(bounds.atOrigin, RadialGradientPaint(\n                color1,\n                color2,\n                circle1,\n                circle2\n            ))\n        }\n    }\n\n    view {\n        render = {\n            // Also able to use a list of color stops\n            rect(bounds.atOrigin, RadialGradientPaint(\n                listOf(\n                    Stop(color1, 0f  ),\n                    Stop(color1, 1f/3),\n                    // ...\n                ),\n                circle1,\n                circle2\n            ))\n        }\n    }\n//sampleEnd\n}";var y=o(8144);const j="package rendering\n\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.drawing.FrostedGlassPaint\nimport io.nacular.doodle.drawing.opacity\n\n/**\n * Example showing how to use [FrostedGlassPaint]s.\n */\nfun frostedGlassPaint() {\n//sampleStart\n    view {\n        render = {\n            rect(bounds.atOrigin, FrostedGlassPaint(\n                color      = White opacity 0.5f,\n                blurRadius = 10.0\n            ))\n        }\n    }\n//sampleEnd\n}",C="package rendering\n\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.AffineTransform2D\nimport io.nacular.doodle.drawing.PatternPaint\nimport io.nacular.doodle.geometry.Size\n\nfun patternPaint(size: Size, transform: AffineTransform2D) {\n//sampleStart\n    view {\n        render = {\n            rect(bounds.atOrigin, PatternPaint(size, transform) {\n                // render onto canvas\n                // rect(..)\n            })\n        }\n    }\n//sampleEnd\n}",k="package rendering\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.renderProperty\nimport io.nacular.doodle.drawing.AffineTransform.Companion.Identity\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color.Companion.Red\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.drawing.stripedPaint\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.measured.units.Angle.Companion.degrees\nimport io.nacular.measured.units.times\n\n// Doodle's implementation of striped-paint looks something like this\n/*\nfun stripedPaint(\n    stripeWidth : Double,\n    evenRowColor: Color? = null,\n    oddRowColor : Color? = null,\n    transform   : AffineTransform2D = Identity\n): PatternPaint = PatternPaint(Size(if (evenRowColor.visible || oddRowColor.visible) stripeWidth else 0.0, 2 * stripeWidth), transform) {\n    evenRowColor?.let { rect(Rectangle(                  stripeWidth, stripeWidth), ColorPaint(it)) }\n    oddRowColor?.let  { rect(Rectangle(0.0, stripeWidth, stripeWidth, stripeWidth), ColorPaint(it)) }\n}\n*/\n\n//sampleStart\nclass SomeView: View() {\n    private val stripeWidth = 20.0\n    private var paintAngle by renderProperty(0 * degrees)\n\n    override fun render(canvas: Canvas) {\n        val paintCenter = Point(canvas.size.width / 2, canvas.size.height / 2)\n\n        canvas.rect(bounds.atOrigin, stripedPaint(\n            stripeWidth  = stripeWidth,\n            evenRowColor = Red,\n            oddRowColor  = White,\n            transform    = Identity.rotate(around = paintCenter, by = paintAngle)\n        ))\n    }\n}\n//sampleEnd",b="package rendering\n\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.ImagePaint\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.image.Image\n\nfun imagePaint(image: Image, size: Size, opacity: Float) {\n//sampleStart\n    view {\n        render = {\n            rect(bounds.atOrigin, ImagePaint(image, size, opacity))\n        }\n    }\n//sampleEnd\n}",P="package rendering\n\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.Paint\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.drawing.Stroke.LineCap.Round\nimport io.nacular.doodle.drawing.Stroke.LineJoint.Miter\n\nfun stroke(paint: Paint) {\n//sampleStart\n    view {\n        render = {\n            rect(bounds.atOrigin, stroke = Stroke(\n                fill      = paint,\n                dashes    = doubleArrayOf(10.0, 20.0),\n                thickness = 2.5,\n                lineCap   = Round,\n                lineJoint = Miter\n            ))\n        }\n    }\n//sampleEnd\n}",S="package rendering\n\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.Paint\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.geometry.Rectangle\n\nfun rect(rectangle: Rectangle, paint: Paint, stroke: Stroke) {\n//sampleStart\n    view {\n        render = {\n            rect(rectangle, fill = paint, stroke = stroke)\n        }\n    }\n//sampleEnd\n}",F="package rendering\n\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.Paint\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.geometry.Circle\nimport io.nacular.doodle.geometry.Polygon\nimport io.nacular.doodle.geometry.inscribed\nimport io.nacular.measured.units.Angle.Companion.degrees\nimport io.nacular.measured.units.times\n\nfun poly(polygon: Polygon, circle: Circle, paint: Paint, stroke: Stroke) {\n    // You can also create equilateral polygons by inscribing them\n    // within circles.\n    circle.inscribed(8, rotation = 45 * degrees)\n\n//sampleStart\n    view {\n        render = {\n            poly(polygon, fill = paint, stroke = stroke)\n        }\n    }\n//sampleEnd\n}",T="package rendering\n\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.Paint\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.geometry.Circle\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.geometry.inscribedCircle\n\nfun circle(circle: Circle, rectangle: Rectangle, paint: Paint, stroke: Stroke) {\n    // You can also create circles based on Rectangles\n    rectangle.inscribedCircle()\n\n//sampleStart\n    view {\n        render = {\n            circle(circle, fill = paint, stroke = stroke)\n        }\n    }\n//sampleEnd\n}",A="package rendering\n\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.Paint\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.geometry.Ellipse\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.geometry.inscribedEllipse\n\nfun ellipse(ellipse: Ellipse, rectangle: Rectangle, paint: Paint, stroke: Stroke) {\n    // You can also create ellipses based on Rectangles\n    rectangle.inscribedEllipse()\n\n//sampleStart\n    view {\n        render = {\n            ellipse(ellipse, fill = paint, stroke = stroke)\n        }\n    }\n//sampleEnd\n}",I="package rendering\n\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.Paint\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.measured.units.Angle.Companion.degrees\nimport io.nacular.measured.units.Angle.Companion.radians\nimport io.nacular.measured.units.times\nimport kotlin.math.PI\n\nfun arc(center: Point,  paint: Paint, stroke: Stroke) {\n//sampleStart\n    view {\n        render = {\n            arc(\n                center   = center,\n                radius   = 100.0,\n                fill     = paint,\n                stroke   = stroke,\n                sweep    = 270 * degrees,\n                rotation = PI * radians\n            )\n        }\n    }\n//sampleEnd\n}",L="package rendering\n\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.Paint\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.measured.units.Angle.Companion.degrees\nimport io.nacular.measured.units.Angle.Companion.radians\nimport io.nacular.measured.units.times\nimport kotlin.math.PI\n\nfun wedge(center: Point,  paint: Paint, stroke: Stroke) {\n//sampleStart\n    view {\n        render = {\n            wedge(\n                center   = center,\n                radius   = 100.0,\n                fill     = paint,\n                stroke   = stroke,\n                sweep    = 270 * degrees,\n                rotation = PI / 2 * radians\n            )\n        }\n    }\n//sampleEnd\n}",R='package rendering\n\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.Paint\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.geometry.Circle\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.inscribed\nimport io.nacular.doodle.geometry.path\nimport io.nacular.doodle.geometry.rounded\n\nfun path(paint: Paint, stroke: Stroke) {\n    // Path from SVG data\n    val heart = path("M50,25 C35,0,-14,25,20,60 L50,90 L80,60 C114,20,65,0,50,25")!!\n\n    // Star with rounded corners\n    val star = Circle(\n        radius = 100.0,\n        center = Point(100, 100)\n    ).inscribed(5)!!.rounded(radius = 10.0)\n\n//sampleStart\n    view {\n        render = {\n            // transform the Canvas to change path bounds, etc.\n            path(star, fill = paint, stroke = stroke)\n        }\n    }\n//sampleEnd\n}',M='package rendering\n\nimport io.nacular.doodle.geometry.Circle\nimport io.nacular.doodle.geometry.Path\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.geometry.map\nimport io.nacular.doodle.geometry.path\nimport io.nacular.doodle.geometry.toPath\n\nfun pathCreation(start: Point, end: Point, width: Double, height: Double) {\n//sampleStart\n    // Just convert most geometric shapes into them:\n\n    Circle().toPath()\n    Rectangle().toPath()\n    Rectangle().map { it * 2 }.toPath()\n\n    // Use the path builder function:\n\n    path(start)\n        .cubicTo(\n            Point(width / 2, height / 2),\n            Point(width / 3,   0),\n            Point(width / 2, -10)\n        )\n        .cubicTo(\n            end,\n            Point(width / 2, height + 10),\n            Point(width * 2/3, height)\n        ).finish() // or close\n\n    // Or use a raw String:\n\n    val path: Path? = path("...") // returns nullable since given string might be invalid\n    val imSure      = path("...")!!\n//sampleEnd\n}',z="package rendering\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.application.Modules.Companion.PathModule\nimport io.nacular.doodle.application.application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.geometry.PathMetrics\nimport org.kodein.di.instance\n\nclass PathApp(display: Display, pathMetrics: PathMetrics): Application {\n    override fun shutdown() {}\n}\n\nfun pathModule() {\n//sampleStart\n    application(modules = listOf(PathModule)) {\n        PathApp(display = instance(), pathMetrics = instance())\n    }\n//sampleEnd\n}",D="package io.nacular.doodle.docs.utils\n\nimport io.nacular.doodle.core.Camera\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.renderProperty\nimport io.nacular.doodle.drawing.AffineTransform\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.utils.ChangeObservers\nimport io.nacular.doodle.utils.ChangeObserversImpl\nimport io.nacular.measured.units.Angle\nimport io.nacular.measured.units.times\n\n//sampleStart\nclass Cube: View() {\n    private val side   = 100.0\n    private val rect   = Rectangle(size = Size(side))\n    private val stroke = Stroke(thickness = 2.0, fill = Color.Darkgray.paint)\n\n    var foldAngle       by renderProperty(-90 * Angle.degrees) { _,_ -> (changed as ChangeObserversImpl).invoke() }\n    var canvasCamera    by renderProperty(Camera(Point.Origin, 1000.0)) { _,_ -> (changed as ChangeObserversImpl).invoke() }\n    var canvasTransform by renderProperty(AffineTransform.Identity.translate(z = -side / 2)) { _,_ -> (changed as ChangeObserversImpl).invoke() }\n\n    val changed: ChangeObservers<Cube> = ChangeObserversImpl(this)\n\n    override fun render(canvas: Canvas) {\n        var transform    = canvasTransform\n        var faceLocation = Point((width - side) / 2, (height - side) / 2)\n\n        drawFace(canvas, faceLocation, transform) // Back\n\n        faceLocation += Point(x = side)\n        transform    *= AffineTransform.Identity.rotateY(around = faceLocation, foldAngle)\n\n        drawFace(canvas, faceLocation, transform) // Right\n\n        faceLocation -= Point(y = side)\n\n        drawFace(canvas, faceLocation, transform.rotateX(around = faceLocation + Point(y = side), foldAngle)) // Top\n\n        faceLocation += Point(y = 2 * side)\n        transform    *= AffineTransform.Identity.rotateX(around = faceLocation, -foldAngle)\n\n        drawFace(canvas, faceLocation, transform) // Bottom\n\n        faceLocation += Point(y = side)\n        transform    *= AffineTransform.Identity.rotateX(around = faceLocation, -foldAngle)\n\n        drawFace(canvas, faceLocation, transform) // Left\n\n        faceLocation += Point(x = side)\n        transform    *= AffineTransform.Identity.rotateY(around = faceLocation, foldAngle)\n\n        drawFace(canvas, faceLocation, transform) // Front\n    }\n\n    private fun drawFace(canvas: Canvas, location: Point, transform: AffineTransform) {\n        canvas.transform(transform, canvasCamera) { rect(rect.at(location), stroke) }\n    }\n}\n//sampleEnd",E='package rendering\n\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.text\nimport io.nacular.doodle.geometry.Point.Companion.Origin\n\nfun text() {\n    val textView = view {\n//sampleStart\n        render = {\n            text("hello", Origin, color = Black)\n        }\n//sampleEnd\n    }\n}',B='package rendering\n\nimport io.nacular.doodle.drawing.Font\nimport io.nacular.doodle.drawing.FontLoader\nimport kotlinx.coroutines.async\nimport kotlinx.coroutines.coroutineScope\n\nsuspend fun fontUrl(fonts: FontLoader) = coroutineScope {\n//sampleStart\n    async {\n        // Load this front from the file at "urlToFont"\n        val font: Font? = fonts("urlToFont") {\n            family = "Roboto"\n            size   = 14\n            weight = 400\n        }\n    }\n//sampleEnd\n}',O='package rendering\n\nimport io.nacular.doodle.drawing.Font\nimport io.nacular.doodle.drawing.FontLoader\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Deferred\nimport kotlinx.coroutines.async\nimport kotlinx.coroutines.coroutineScope\n\nsuspend fun systemFont(scope: CoroutineScope, fonts: FontLoader) = coroutineScope {\n//sampleStart\n    // launch a new coroutine for async font lookup\n    val font: Deferred<Font?> = async {\n        fonts {\n            family = "Roboto"\n            size   = 14\n            weight = 400\n        }\n    }\n\n    //...\n\n    font.await()\n//sampleEnd\n}',G="package rendering\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.application.Modules.Companion.FontModule\nimport io.nacular.doodle.application.application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.drawing.FontLoader\nimport org.kodein.di.instance\n\nclass FontLoaderApp(display: Display, fonts: FontLoader): Application {\n    override fun shutdown() {}\n}\n\nfun main() {\n//sampleStart\n    application(modules = listOf(FontModule)) {\n        FontLoaderApp(display = instance(), fonts = instance())\n    }\n//sampleEnd\n}",V='package io.nacular.doodle.docs.apps\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.docs.utils.DEFAULT_FONT_FAMILIES\nimport io.nacular.doodle.docs.utils.controlBackgroundColor\nimport io.nacular.doodle.drawing.Color.Companion.Red\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.drawing.Color.Companion.Yellow\nimport io.nacular.doodle.drawing.FontLoader\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.drawing.width\nimport io.nacular.doodle.geometry.Point.Companion.Origin\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.text.Target.Background\nimport io.nacular.doodle.text.TextDecoration\nimport io.nacular.doodle.text.TextDecoration.Line.Under\nimport io.nacular.doodle.text.TextDecoration.Style.Wavy\nimport io.nacular.doodle.text.TextDecoration.Thickness.Absolute\nimport io.nacular.doodle.text.TextSpacing\nimport io.nacular.doodle.text.invoke\nimport io.nacular.doodle.utils.Resizer\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.launch\n\nclass StyledTextApp(display: Display, fonts: FontLoader, appScope: CoroutineScope): Application {\n    init {\n        appScope.launch {\n            val bold = fonts {\n                families = DEFAULT_FONT_FAMILIES\n                weight   = 700\n            }\n\n            display += view {\n//sampleStart\n                val decoration = TextDecoration(\n                    lines     = setOf(Under),\n                    color     = Red,\n                    thickness = Absolute(1.0),\n                    style     = Wavy\n                )\n\n                val text = bold { "Lorem Ipsum" }.." is simply "..Yellow(Background) { "dummy text" }..\n                        " of the printing and typesetting industry. It has been the industry\'s standard dummy text "..\n                        decoration { "ever since the 1500s" }..\n                        ", when an unknown printer took a galley of type and scrambled it to make a type specimen book."\n\n                render = {\n                    rect(bounds.atOrigin, fill = White.paint)\n\n                    wrapped(\n                        text        = text,\n                        at          = Origin,\n                        width       = width,\n                        textSpacing = TextSpacing(wordSpacing = 5.0, letterSpacing = 1.0),\n                        lineSpacing = 1.2f\n                    )\n                }\n//sampleEnd\n            }.apply {\n                suggestSize(Size(400, 200))\n                Resizer(this, movable = false)\n            }\n\n            display.fill(controlBackgroundColor.paint)\n            display.layout = constrain(display.first()) {\n                it.width  lessEq parent.width - 20\n                it.center eq     parent.center\n            }\n        }\n    }\n\n    override fun shutdown() {}\n}',N='package rendering\n\nimport io.nacular.doodle.drawing.FontLoader\nimport io.nacular.doodle.scheduler.Scheduler\nimport io.nacular.measured.units.Time.Companion.seconds\nimport io.nacular.measured.units.times\nimport kotlinx.coroutines.coroutineScope\nimport kotlinx.coroutines.launch\n\nsuspend fun fontTimeout(fonts: FontLoader, scheduler: Scheduler) = coroutineScope {\n//sampleStart\n    // track loading job\n    val fontJob = launch {\n        // assigns the font when the job resolves\n        val font = fonts {\n            family = "Roboto"\n            size   = 14\n            weight = 400\n        }\n    }\n\n    // Cancel the job after 5 seconds\n    scheduler.after(5 * seconds) {\n        if (!fontJob.isCancelled) {\n            fontJob.cancel()\n        }\n    }\n//sampleEnd\n}',W='package rendering\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.application.application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.TextMetrics\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.geometry.Point\nimport org.kodein.di.instance\n\nclass MyApp(display: Display, textMetrics: TextMetrics): Application {\n    init {\n//sampleStart\n        display += view {\n            val hello    = "hello"\n            val textSize = textMetrics.size(hello) // cache text size\n\n            render = {\n                text(\n                    text = hello,\n                    at   = Point((width - textSize.width) / 2, (height - textSize.height) / 2),\n                    fill = Black.paint\n                )\n            }\n        }\n//sampleEnd\n    }\n    override fun shutdown() {}\n}\n\nfun launch() {\n    application {\n        // TextMetrics is available to inject by default\n        MyApp(display = instance(), textMetrics = instance())\n    }\n}',_='package io.nacular.doodle.docs.apps\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.docs.utils.controlBackgroundColor\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.drawing.width\nimport io.nacular.doodle.geometry.Point.Companion.Origin\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.text.TextSpacing\nimport io.nacular.doodle.utils.Resizer\n\nclass MultiLinedTextApp(display: Display): Application {\n    init {\n        display += view {\n//sampleStart\n            val text = "Lorem Ipsum is simply dummy text of the printing and typesetting industry. It has been the industry\'s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book."\n\n            render = {\n                rect(bounds.atOrigin, fill = White.paint)\n\n                wrapped(\n                    text        = text,\n                    at          = Origin,\n                    width       = this.width,\n                    fill        = Black.paint,\n                    textSpacing = TextSpacing(wordSpacing = 5.0, letterSpacing = 1.0),\n                    lineSpacing = 1.2f\n                )\n            }\n//sampleEnd\n\n        }.apply {\n            suggestSize(Size(400, 200))\n            Resizer(this, movable = false)\n        }\n\n        display.fill(controlBackgroundColor.paint)\n        display.layout = constrain(display.first()) {\n            it.width  lessEq parent.width - 20\n            it.center eq     parent.center\n        }\n    }\n\n    override fun shutdown() {}\n}',Y='package rendering\n\nimport io.nacular.doodle.image.Image\nimport io.nacular.doodle.image.ImageLoader\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.launch\n\nfun loadImage(imageLoader: ImageLoader, scope: CoroutineScope) {\n//sampleStart\n    scope.launch {\n        val image: Image? = imageLoader.load("some_image_path")\n\n        // won\'t get here until load resolves\n        image?.let {\n            // ...\n        }\n    }\n//sampleEnd\n}',q="package rendering\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.application.Modules.Companion.ImageModule\nimport io.nacular.doodle.application.application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.image.ImageLoader\nimport org.kodein.di.instance\n\nclass ImageLoaderApp(display: Display, images: ImageLoader): Application {\n    override fun shutdown() {}\n}\n\nfun imageLoader() {\n//sampleStart\n    application(modules = listOf(ImageModule)) {\n        ImageLoaderApp(display = instance(), images = instance())\n    }\n//sampleEnd\n}",J='package io.nacular.doodle.docs.apps\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.application.Modules.Companion.ImageModule\nimport io.nacular.doodle.application.Modules.Companion.PointerModule\nimport io.nacular.doodle.application.application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.center\nimport io.nacular.doodle.core.height\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.core.width\nimport io.nacular.doodle.docs.utils.controlBackgroundColor\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.geometry.centered\nimport io.nacular.doodle.image.ImageLoader\nimport io.nacular.doodle.utils.Resizer\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.launch\nimport org.kodein.di.instance\nimport org.w3c.dom.HTMLElement\nimport kotlin.math.min\n\nclass ImageApp(\n    display    : Display,\n    imageLoader: ImageLoader,\n    appScope   : CoroutineScope\n): Application {\n    init {\n        appScope.launch {\n//sampleStart\n            val image = imageLoader.load("/doodle/images/photo.jpg") ?: return@launch\n\n            display.children += view {\n                render = {\n                    image(image, destination = bounds.atOrigin)\n                }\n\n                Resizer(this)\n            }\n//sampleEnd\n\n            display.fill(controlBackgroundColor.paint)\n\n            when {\n                display.size.empty -> display.sizeChanged += { _,_,_ -> setInitialBounds(display, image.size) }\n                else               -> setInitialBounds(display, image.size)\n            }\n        }\n    }\n\n    private fun setInitialBounds(display: Display, imageSize: Size) {\n        with(display.first()) {\n            if (size.empty && !display.size.empty) {\n                var w = min(display.width / 2, display.height - 40)\n                var h = w * imageSize.height / imageSize.width\n\n                if (h > display.height - 40) {\n                    h = display.height - 40\n                    w = h * imageSize.width / imageSize.height\n                }\n\n                display.first().suggestBounds(Rectangle(w, h).centered(display.center))\n            }\n        }\n    }\n\n    override fun shutdown() {}\n\n    companion object {\n        private val appModules = listOf(PointerModule, ImageModule)\n\n        operator fun invoke(root: HTMLElement) = application(root, modules = appModules) {\n            ImageApp(instance(), instance(), CoroutineScope(SupervisorJob() + Dispatchers.Default))\n        }\n    }\n}',H='package io.nacular.doodle.docs.apps\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.application.Modules.Companion.ImageModule\nimport io.nacular.doodle.application.Modules.Companion.PointerModule\nimport io.nacular.doodle.application.application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.center\nimport io.nacular.doodle.core.height\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.core.width\nimport io.nacular.doodle.docs.utils.controlBackgroundColor\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.geometry.centered\nimport io.nacular.doodle.geometry.div\nimport io.nacular.doodle.image.ImageLoader\nimport io.nacular.doodle.utils.Resizer\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.launch\nimport org.kodein.di.instance\nimport org.w3c.dom.HTMLElement\nimport kotlin.math.min\n\nclass CroppedImageApp(\n    display    : Display,\n    imageLoader: ImageLoader,\n    appScope   : CoroutineScope\n): Application {\n    init {\n        appScope.launch {\n//sampleStart\n            val image = imageLoader.load("/doodle/images/photo.jpg") ?: return@launch\n\n            display.children += view {\n                render = {\n                    image(image, source = Rectangle(image.size / 2), destination = bounds.atOrigin)\n                }\n\n                Resizer(this)\n            }\n//sampleEnd\n\n            display.fill(controlBackgroundColor.paint)\n\n            when {\n                display.size.empty -> display.sizeChanged += { _,_,_ -> setInitialBounds(display) }\n                else               -> setInitialBounds(display)\n            }\n        }\n    }\n\n    private fun setInitialBounds(display: Display) {\n        with(display.first()) {\n            if (size.empty && !display.size.empty) {\n                display.first().suggestBounds(Rectangle(min(display.width / 2, display.height - 80)).centered(display.center))\n            }\n        }\n    }\n\n    override fun shutdown() {}\n\n    companion object {\n        private val appModules = listOf(PointerModule, ImageModule)\n\n        operator fun invoke(root: HTMLElement) = application(root, modules = appModules) {\n            CroppedImageApp(instance(), instance(), CoroutineScope(SupervisorJob() + Dispatchers.Default))\n        }\n    }\n}',U='package io.nacular.doodle.docs.apps\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.application.Modules.Companion.ImageModule\nimport io.nacular.doodle.application.Modules.Companion.PointerModule\nimport io.nacular.doodle.application.application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.center\nimport io.nacular.doodle.core.height\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.core.width\nimport io.nacular.doodle.docs.utils.controlBackgroundColor\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.drawing.opacity\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.geometry.centered\nimport io.nacular.doodle.geometry.div\nimport io.nacular.doodle.image.ImageLoader\nimport io.nacular.doodle.image.aspectRatio\nimport io.nacular.doodle.utils.Resizer\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.launch\nimport org.kodein.di.instance\nimport org.w3c.dom.HTMLElement\nimport kotlin.math.min\n\nclass AspectCroppedImageApp(\n    display    : Display,\n    imageLoader: ImageLoader,\n    appScope   : CoroutineScope\n): Application {\n    init {\n        appScope.launch {\n//sampleStart\n            val image = imageLoader.load("/doodle/images/photo.jpg") ?: return@launch\n\n            display.children += view {\n                val aspect = image.aspectRatio\n\n                render = {\n                    var h = height\n                    var w = h * aspect\n\n                    if (w > width) {\n                        w = width\n                        h = w / aspect\n                    }\n\n                    rect(bounds.atOrigin, fill = (White opacity 0.75f).paint)\n\n                    image(\n                        image       = image,\n                        source      = Rectangle(image.size / 2),\n                        destination = Rectangle(w, h).centered(Point(width / 2, height / 2))\n                    )\n                }\n\n                Resizer(this)\n            }\n//sampleEnd\n\n            display.fill(controlBackgroundColor.paint)\n\n            when {\n                display.size.empty -> display.sizeChanged += { _,_,_ -> setInitialBounds(display) }\n                else               -> setInitialBounds(display)\n            }\n        }\n    }\n\n    private fun setInitialBounds(display: Display) {\n        with(display.first()) {\n            if (size.empty && !display.size.empty) {\n                display.first().suggestBounds(Rectangle(min(display.width / 2, display.height - 40)).centered(display.center))\n            }\n        }\n    }\n\n    override fun shutdown() {}\n\n    companion object {\n        private val appModules = listOf(PointerModule, ImageModule)\n\n        operator fun invoke(root: HTMLElement) = application(root, modules = appModules) {\n            AspectCroppedImageApp(instance(), instance(), CoroutineScope(SupervisorJob() + Dispatchers.Default))\n        }\n    }\n}',X={hide_title:!0,title:"Rendering"},K="Rendering",$={},Q=[{value:"The Canvas",id:"the-canvas",level:2},{value:"Transformations",id:"transformations",level:3},{value:"3D rendering",id:"3d-rendering",level:3},{value:"Filling regions with Paints",id:"filling-regions-with-paints",level:2},{value:"Colors",id:"colors",level:3},{value:"Gradients",id:"gradients",level:3},{value:"Images",id:"images",level:3},{value:"Patterns",id:"patterns",level:3},{value:"Frosted Glass",id:"frosted-glass",level:3},{value:"Outlining shapes with Strokes",id:"outlining-shapes-with-strokes",level:2},{value:"Basic shapes",id:"basic-shapes",level:2},{value:"Paths",id:"paths",level:2},...p.RM,{value:"Text",id:"text",level:2},{value:"Styled text",id:"styled-text",level:3},{value:"Fonts",id:"fonts",level:3},...p.RM,{value:"Handling Timeouts",id:"handling-timeouts",level:4},{value:"Measuring Text",id:"measuring-text",level:3},{value:"Images",id:"images-1",level:2},...p.RM,{value:"Efficient rendering",id:"efficient-rendering",level:2}];function Z(n){const e={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",pre:"pre",...(0,t.R)(),...n.components};return c.F||en("api",!1),c.F.AffineTransform||en("api.AffineTransform",!0),c.F.AffineTransform2D||en("api.AffineTransform2D",!0),c.F.Blue||en("api.Blue",!0),c.F.Camera||en("api.Camera",!0),c.F.Canvas||en("api.Canvas",!0),c.F.CanvasText||en("api.CanvasText",!0),c.F.CanvasWrapped||en("api.CanvasWrapped",!0),c.F.Circle||en("api.Circle",!0),c.F.Color||en("api.Color",!0),c.F.ColorPaint||en("api.ColorPaint",!0),c.F.Color_Paint||en("api.Color_Paint",!0),c.F.EllipseInscribed||en("api.EllipseInscribed",!0),c.F.FontLoader||en("api.FontLoader",!0),c.F.FontModule||en("api.FontModule",!0),c.F.FrostedGlassPaint||en("api.FrostedGlassPaint",!0),c.F.Image||en("api.Image",!0),c.F.ImageLoader||en("api.ImageLoader",!0),c.F.ImageModule||en("api.ImageModule",!0),c.F.ImagePaint||en("api.ImagePaint",!0),c.F.InscribedCircle||en("api.InscribedCircle",!0),c.F.InscribedEllipse||en("api.InscribedEllipse",!0),c.F.LinearGradientPaint||en("api.LinearGradientPaint",!0),c.F.Paint||en("api.Paint",!0),c.F.PathMetrics||en("api.PathMetrics",!0),c.F.PathModule||en("api.PathModule",!0),c.F.PatternPaint||en("api.PatternPaint",!0),c.F.RadialGradientPaint||en("api.RadialGradientPaint",!0),c.F.Rectangle||en("api.Rectangle",!0),c.F.StripedPaint||en("api.StripedPaint",!0),c.F.Stroke||en("api.Stroke",!0),c.F.StyledText||en("api.StyledText",!0),c.F.SweepGradientPaint||en("api.SweepGradientPaint",!0),c.F.TextMetrics||en("api.TextMetrics",!0),c.F.View||en("api.View",!0),c.F.view||en("api.view",!1),c.F.view.clipCanvasToBounds||en("api.view.clipCanvasToBounds",!0),c.F.view.render||en("api.view.render",!0),c.F.view.rerender||en("api.view.rerender",!0),c.F.view.size||en("api.view.size",!0),c.F.view.visible||en("api.view.visible",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"rendering",children:"Rendering"})}),"\n",(0,a.jsxs)(e.p,{children:["Doodle automatically manages rendering of ",(0,a.jsx)(e.code,{children:"Views"}),", and this covers almost all use-cases. Each ",(0,a.jsx)(c.F.View,{})," draws its content to a ",(0,a.jsx)(e.a,{href:"#the-canvas",children:"Canvas"})," provided during calls to the ",(0,a.jsx)(c.F.view.render,{})," method. This either presents the View's contents on the screen for the first time or updates them on subsequent calls."]}),"\n",(0,a.jsxs)(e.p,{children:["Doodle calls ",(0,a.jsx)(e.code,{children:"render"})," whenever a ",(0,a.jsx)(e.code,{children:"View"})," needs a visual update, which includes changes to its ",(0,a.jsx)(c.F.view.size,{})," or it becoming ",(0,a.jsx)(c.F.view.visible,{}),". This means you do not need to call ",(0,a.jsx)(e.code,{children:"render"})," yourself. But there might be cases when you want to request that a View re-renders. You can do this by calling ",(0,a.jsx)(c.F.view.rerender,{}),"."]}),"\n",(0,a.jsxs)(e.p,{children:["This is an example of a simple ",(0,a.jsx)(e.code,{children:"View"})," that draws a rectangle filled with ",(0,a.jsx)(c.F.Blue,{})," ",(0,a.jsx)(c.F.ColorPaint,{})," that covers its bounds."]}),"\n",(0,a.jsx)(d.v,{children:u}),"\n",(0,a.jsx)(e.admonition,{type:"tip",children:(0,a.jsxs)(e.p,{children:[(0,a.jsx)(c.F.view.render,{})," is automatically called on ",(0,a.jsx)(c.F.view.size,{})," changes and ",(0,a.jsx)(c.F.view.visible,{})," changing to ",(0,a.jsx)(e.code,{children:"true"})]})}),"\n",(0,a.jsx)(e.h2,{id:"the-canvas",children:"The Canvas"}),"\n",(0,a.jsxs)(e.p,{children:["All drawing is done via the ",(0,a.jsx)(c.F.Canvas,{})," API, which offers a rich set of operations for geometric shapes, paths, images, and text. It also supports different ",(0,a.jsx)(c.F.Paint,{})," types (i.e. ",(0,a.jsx)(c.F.ColorPaint,{}),", ",(0,a.jsx)(c.F.LinearGradientPaint,{}),", ",(0,a.jsx)(e.a,{href:"rendering#patterns",children:"PatternPaint"}),", etc.) for filling regions."]}),"\n",(0,a.jsxs)(e.p,{children:["The ",(0,a.jsx)(e.code,{children:"Canvas"})," provided to a ",(0,a.jsx)(e.code,{children:"View"}),"'s ",(0,a.jsx)(c.F.view.render,{})," method has a coordinate system that anchors ",(0,a.jsx)(e.code,{children:"0,0"})," on the ",(0,a.jsx)(e.code,{children:"Canvas"})," to the ",(0,a.jsx)(e.code,{children:"View"}),"'s origin. The Canvas itself extends in all directions beyond the bounds of the View; but the contents drawn to it will be clipped to the view's bounds by default."]}),"\n",(0,a.jsx)(e.admonition,{type:"tip",children:(0,a.jsxs)(e.p,{children:["Sub-classes can disable clipping by setting ",(0,a.jsx)(c.F.view.clipCanvasToBounds,{})," = ",(0,a.jsx)(e.code,{children:"false"}),"."]})}),"\n",(0,a.jsxs)(e.p,{children:["Most Views require geometric regions on their Canvas to be filled with some color, gradient, texture, etc.. Therefore, many Canvas APIs take a ",(0,a.jsx)(c.F.Paint,{})," parameter that determines how the inner regions of these shapes are filled. There are several built-in ",(0,a.jsx)(e.code,{children:"Paint"})," types to choose from."]}),"\n",(0,a.jsx)(e.h3,{id:"transformations",children:"Transformations"}),"\n",(0,a.jsxs)(e.p,{children:["The ",(0,a.jsx)(e.code,{children:"Canvas"})," can also be transformed using any ",(0,a.jsx)(c.F.AffineTransform,{}),". These are linear transformation which encapsulate translation, scaling, and rotation in matrices. You can combine these transforms into more complex ones directly, or apply them to a ",(0,a.jsx)(e.code,{children:"Canvas"})," in a nested fashion to get similar results"]}),"\n",(0,a.jsxs)(e.p,{children:["This ",(0,a.jsx)(e.code,{children:"View"})," flips the Canvas horizontally around its mid-point and draws some text."]}),"\n",(0,a.jsx)(d.v,{children:m}),"\n",(0,a.jsx)(e.h3,{id:"3d-rendering",children:"3D rendering"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.a,{href:"rendering#the-canvas",children:"Canvas"})," offers basic 3D capabilities through the use of ",(0,a.jsx)(c.F.AffineTransform,{}),"s and ",(0,a.jsx)(c.F.Camera,{}),"s. This enables ",(0,a.jsx)(c.F.View,{}),"s to display content in a shared 3D space."]}),"\n",(0,a.jsx)(e.p,{children:"The following examples has a View that draws a 3D cube. The cube looks like a 3D object even though it is flat on the View's surface. The controls (which are overlaid on the View) let you change the starting transform applied to the cube's back face (which changes the cube's overall transform), the folding angle of each face, and the camera used to create the perspective."}),"\n",(0,a.jsxs)(r.A,{children:[(0,a.jsx)(l.A,{value:"Demo",children:(0,a.jsx)(s.T,{functionName:"cube",height:"500"})}),(0,a.jsx)(l.A,{value:"Cube.kt",children:(0,a.jsx)(d.v,{children:D})})]}),"\n",(0,a.jsx)(e.h2,{id:"filling-regions-with-paints",children:"Filling regions with Paints"}),"\n",(0,a.jsx)(e.h3,{id:"colors",children:"Colors"}),"\n",(0,a.jsxs)(e.p,{children:["Doodle supports RGBA colors (via the ",(0,a.jsx)(c.F.Color,{})," class), for rendering content to the ",(0,a.jsx)(e.code,{children:"Canvas"})," via paints like ",(0,a.jsx)(c.F.ColorPaint,{}),". Colors can be created explicitly using hex notation, or you can use any of the built-in values (i.e. ",(0,a.jsx)(e.code,{children:"Red"}),"). Colors can also be derived from others with one of the many utility functions like ",(0,a.jsx)(e.code,{children:"lighter"}),", ",(0,a.jsx)(e.code,{children:"darker"}),", or by changing ",(0,a.jsx)(e.code,{children:"opacity"}),"."]}),"\n",(0,a.jsx)(d.v,{children:f}),"\n",(0,a.jsxs)(e.admonition,{type:"info",children:[(0,a.jsx)(e.p,{children:"Sometimes it is more effective to work within other color spaces. Doodle has built-in utilities for HSL and HSV colors, though these colors cannot be used directly for rendering. That said, there are many utilities for easily transforming between them and RGBA."}),(0,a.jsxs)(e.p,{children:["The ",(0,a.jsx)(e.a,{href:"ui_components/overview#colorpicker",children:"ColorPicker"})," controls uses HSV internally for example."]})]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(c.F.ColorPaint,{})," is the simplest and most common way to fill a region. You can create one using the constructor, or via the ",(0,a.jsx)(c.F.Color_Paint,{})," extension on any ",(0,a.jsx)(c.F.Color,{}),"."]}),"\n",(0,a.jsx)(s.T,{functionName:"colorPaint",height:"300"}),"\n",(0,a.jsx)(d.v,{children:x}),"\n",(0,a.jsx)(e.h3,{id:"gradients",children:"Gradients"}),"\n",(0,a.jsxs)(e.p,{children:["You can fill regions with ",(0,a.jsx)(c.F.LinearGradientPaint,{}),"s, ",(0,a.jsx)(c.F.RadialGradientPaint,{}),"s and ",(0,a.jsx)(c.F.SweepGradientPaint,{}),"s paints as well. These take a series of ",(0,a.jsx)(c.F.Color,{}),"s and stop locations that are turned into a smoothly transitioning gradient across a shape."]}),"\n",(0,a.jsxs)(r.A,{children:[(0,a.jsxs)(l.A,{value:"Linear",children:[(0,a.jsx)(s.T,{functionName:"linearGradientPaint",height:"300"}),(0,a.jsx)(d.v,{children:w})]}),(0,a.jsxs)(l.A,{value:"Radial",children:[(0,a.jsx)(s.T,{functionName:"radialGradientPaint",height:"300"}),(0,a.jsx)(d.v,{children:v})]}),(0,a.jsxs)(l.A,{value:"Sweep",children:[(0,a.jsx)(s.T,{functionName:"sweepGradientPaint",height:"300"}),(0,a.jsx)(d.v,{children:y.A})]})]}),"\n",(0,a.jsx)(e.h3,{id:"images",children:"Images"}),"\n",(0,a.jsxs)(e.p,{children:["Images can be used to fill regions with a repeating pattern. This paint takes an ",(0,a.jsx)(c.F.Image,{})," along with a size and opacity that image should be rendered at. The result is a repeating pattern that tiles the shape being filled."]}),"\n",(0,a.jsxs)(r.A,{children:[(0,a.jsx)(l.A,{value:"Demo",children:(0,a.jsx)(s.T,{functionName:"imagePaint",height:"300"})}),(0,a.jsx)(l.A,{value:"Code",children:(0,a.jsx)(d.v,{children:b})})]}),"\n",(0,a.jsx)(e.admonition,{type:"info",children:(0,a.jsxs)(e.p,{children:[(0,a.jsx)(c.F.ImagePaint,{})," does not allow any cropping of the provided image. But you can use ",(0,a.jsx)(c.F.PatternPaint,{})," to do this."]})}),"\n",(0,a.jsx)(e.h3,{id:"patterns",children:"Patterns"}),"\n",(0,a.jsxs)(e.p,{children:["Sometimes you need to fill a region with a repeating pattern, like an image or some geometric shapes. This is easy to achieve with ",(0,a.jsx)(c.F.ImagePaint,{})," (when an image is all you need) or ",(0,a.jsx)(c.F.PatternPaint,{}),", when more sophisticated patterns are needed."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.code,{children:"PatternPaint"}),' has a "render" body that provides a powerful and familiar way of creating repeating patterns. You create one by specifying a ',(0,a.jsx)(e.code,{children:"size"})," and a ",(0,a.jsx)(e.code,{children:"paint"})," lambda, which has access to the full ",(0,a.jsx)(c.F.Canvas,{})," APIs."]}),"\n",(0,a.jsxs)(e.p,{children:["This app uses ",(0,a.jsx)(c.F.StripedPaint,{})," to show how a ",(0,a.jsx)(c.F.PatternPaint,{})," can be transformed using ",(0,a.jsx)(c.F.AffineTransform2D,{}),", like rotated around its center for example."]}),"\n",(0,a.jsxs)(r.A,{children:[(0,a.jsx)(l.A,{value:"Demo",children:(0,a.jsx)(s.T,{functionName:"patternPaint",height:"300"})}),(0,a.jsx)(l.A,{value:"Code",children:(0,a.jsx)(d.v,{children:k})})]}),"\n",(0,a.jsx)(d.v,{children:C}),"\n",(0,a.jsx)(e.h3,{id:"frosted-glass",children:"Frosted Glass"}),"\n",(0,a.jsxs)(e.p,{children:["The ",(0,a.jsx)(c.F.FrostedGlassPaint,{})," lets you emulate the look of glass that blurs the contents below it. The paint takes a ",(0,a.jsx)(e.code,{children:"blurRadius"})," and an optional ",(0,a.jsx)(c.F.Color,{}),"."]}),"\n",(0,a.jsx)(s.T,{functionName:"frostedGlassPaint",height:"300"}),"\n",(0,a.jsx)(d.v,{children:j}),"\n",(0,a.jsx)(e.h2,{id:"outlining-shapes-with-strokes",children:"Outlining shapes with Strokes"}),"\n",(0,a.jsxs)(e.p,{children:["Regions and curves can be stroked to give them an outline of some sort. The Canvas APIs also take ",(0,a.jsx)(c.F.Stroke,{})," parameters that determine how to outline the shape being rendered."]}),"\n",(0,a.jsxs)(e.p,{children:["A ",(0,a.jsx)(e.code,{children:"Stroke"})," combines the behavior of a ",(0,a.jsx)(e.a,{href:"rendering#filling-regions-with-paints",children:"Paint"})," (but for the outline only) and adds several properties that govern how the outline is created."]}),"\n",(0,a.jsx)(e.admonition,{type:"info",children:(0,a.jsxs)(e.p,{children:["Strokes are centered along the edge of the shape the outline. This means adding a stroke will expand the area needed to render the shape by ",(0,a.jsx)(e.code,{children:"stroke.thickness / 2"})," in the x and y direction. Keep this in mind, and shrink shapes accordingly to ensure outlines are not clipped and they appear where you want them to."]})}),"\n",(0,a.jsx)(s.T,{functionName:"strokes",height:"300"}),"\n",(0,a.jsx)(d.v,{children:P}),"\n",(0,a.jsx)(e.h2,{id:"basic-shapes",children:"Basic shapes"}),"\n",(0,a.jsxs)(e.p,{children:["The ",(0,a.jsx)(c.F.Canvas,{})," has APIs for drawing many basic shapes that foundation of most Views. Each shape can be filled with ",(0,a.jsx)(c.F.Paint,{})," and outlined with ",(0,a.jsx)(c.F.Stroke,{}),"s as well."]}),"\n",(0,a.jsxs)(r.A,{children:[(0,a.jsxs)(l.A,{value:"Rect",children:[(0,a.jsx)(s.T,{functionName:"shapes",args:'["rect"]',height:"300"}),(0,a.jsx)(d.v,{children:S}),(0,a.jsx)(e.admonition,{type:"tip",children:(0,a.jsxs)(e.p,{children:["A View's bounds is relative to its parent, so you need to do bring it into the View's coordinate space before drawing it to the Canvas. This is easy with ",(0,a.jsx)(e.code,{children:"bounds.atOrigin"}),"."]})})]}),(0,a.jsxs)(l.A,{value:"Poly",children:[(0,a.jsx)(s.T,{functionName:"shapes",args:'["poly"]',height:"300"}),(0,a.jsx)(d.v,{children:F}),(0,a.jsxs)(e.admonition,{type:"tip",children:[(0,a.jsxs)(e.p,{children:["You can also create equilateral polygons using the ",(0,a.jsx)(c.F.EllipseInscribed,{})," function on a ",(0,a.jsx)(c.F.Circle,{}),":"]}),(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-kotlin",children:"circle.inscribed(8, rotation = 45 * degrees)\n"})})]})]}),(0,a.jsxs)(l.A,{value:"Circle",children:[(0,a.jsx)(s.T,{functionName:"shapes",args:'["circle"]',height:"300"}),(0,a.jsx)(d.v,{children:T}),(0,a.jsxs)(e.admonition,{type:"tip",children:[(0,a.jsxs)(e.p,{children:["Circles can be created from ",(0,a.jsx)(c.F.Rectangle,{}),"s, using the ",(0,a.jsx)(c.F.InscribedCircle,{})," method:"]}),(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-kotlin",children:"rectangle.inscribedCircle()\n"})})]})]}),(0,a.jsxs)(l.A,{value:"Ellipse",children:[(0,a.jsx)(s.T,{functionName:"shapes",args:'["ellipse"]',height:"300"}),(0,a.jsx)(d.v,{children:A}),(0,a.jsxs)(e.admonition,{type:"tip",children:[(0,a.jsxs)(e.p,{children:["Ellipses can be created from ",(0,a.jsx)(c.F.Rectangle,{}),"s, using the ",(0,a.jsx)(c.F.InscribedEllipse,{})," method:"]}),(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-kotlin",children:"rectangle.inscribedEllipse()\n"})})]})]}),(0,a.jsxs)(l.A,{value:"Arc",children:[(0,a.jsx)(s.T,{functionName:"shapes",args:'["arc"]',height:"300"}),(0,a.jsx)(d.v,{children:I})]}),(0,a.jsxs)(l.A,{value:"Wedge",children:[(0,a.jsx)(s.T,{functionName:"shapes",args:'["wedge"]',height:"300"}),(0,a.jsx)(d.v,{children:L})]})]}),"\n",(0,a.jsx)(e.h2,{id:"paths",children:"Paths"}),"\n",(0,a.jsx)(e.p,{children:"Paths a really powerful primitives that let you create arbitrarily complex shapes that can be filled and stroked like those above. This flexibility comes from the fact that paths are fairly opaque components that behave almost like images."}),"\n",(0,a.jsxs)(e.p,{children:["A major difference with Paths is that they do not track their intrinsic size (though this can be obtained using a ",(0,a.jsx)(c.F.PathMetrics,{}),"). This is a tradeoff that allows them to be created in a very light weight way. Paths can be transformed when rendered to a ",(0,a.jsx)(c.F.Canvas,{})," to adjust their size, position, etc."]}),"\n",(0,a.jsx)(s.T,{functionName:"shapes",args:'["path"]',height:"300"}),"\n",(0,a.jsx)(d.v,{children:R}),"\n",(0,a.jsx)(p.Ay,{link:(0,a.jsx)(c.F.PathModule,{}),module:z}),"\n",(0,a.jsxs)(e.admonition,{type:"tip",children:[(0,a.jsx)(e.p,{children:"There are may ways to create Paths."}),(0,a.jsx)(d.v,{children:M})]}),"\n",(0,a.jsx)(e.h2,{id:"text",children:"Text"}),"\n",(0,a.jsx)(s.T,{functionName:"text",height:"300"}),"\n",(0,a.jsxs)(e.p,{children:["All text, whether single or multi-lined, is drawn directly to a ",(0,a.jsx)(e.a,{href:"rendering#the-canvas",children:"Canvas"})," using the ",(0,a.jsx)(c.F.CanvasText,{})," and ",(0,a.jsx)(c.F.CanvasWrapped,{})," methods. Text rendering is also explicit, with each API requiring a position within the ",(0,a.jsx)(e.code,{children:"Canvas"})," and the ",(0,a.jsx)(c.F.Paint,{})," used for filling (and/or ",(0,a.jsx)(c.F.Stroke,{}),' used for outlining). The following View draw\'s "hello" at ',(0,a.jsx)(e.code,{children:"0,0"})," using the default font. But it is possible to change the font, letter, word and line spacing (for multi-lined text) as well."]}),"\n",(0,a.jsx)(d.v,{children:E}),"\n",(0,a.jsxs)(e.p,{children:["You can draw wrapped text using ",(0,a.jsx)(c.F.CanvasWrapped,{}),", which takes information about the width you'd like the text to occupy. Wrapped text also allows you to specify the line spacing, otherwise, it shares the same inputs as regular text."]}),"\n",(0,a.jsx)(s.T,{functionName:"multiLineText",height:"300"}),"\n",(0,a.jsx)(d.v,{children:_}),"\n",(0,a.jsx)(e.h3,{id:"styled-text",children:"Styled text"}),"\n",(0,a.jsxs)(e.p,{children:["You can also draw text (single and multi-line) that is styled using the ",(0,a.jsx)(c.F.StyledText,{})," class and its DSLs."]}),"\n",(0,a.jsx)(s.T,{functionName:"styledText",height:"300"}),"\n",(0,a.jsx)(d.v,{children:V}),"\n",(0,a.jsx)(e.h3,{id:"fonts",children:"Fonts"}),"\n",(0,a.jsxs)(e.p,{children:["You can specify a font when drawing text or have Doodle fallback to the default. Fonts can be tricky, since they may not be present on the system at render time. This presents a race-condition for drawing text, since any text drawn with a Font that is simultaneously being loaded (or missing) can be shown in the wrong Font. This is what the ",(0,a.jsx)(c.F.FontLoader,{})," is designed to help with."]}),"\n",(0,a.jsx)(e.p,{children:"It presents an asynchronous API for fetching Fonts so the app is explicitly made to deal with this."}),"\n",(0,a.jsx)(p.Ay,{link:(0,a.jsx)(c.F.FontModule,{}),module:G}),"\n",(0,a.jsxs)(e.p,{children:["You can use ",(0,a.jsx)(c.F.FontLoader,{})," to check the system asynchronously for a given font. This allows you to check for OS fonts, or fonts that have been loaded previously."]}),"\n",(0,a.jsx)(d.v,{children:O}),"\n",(0,a.jsxs)(e.p,{children:["You can also load a font from a file or url using ",(0,a.jsx)(c.F.FontLoader,{}),". This is similar to finding a loaded font, but it takes a font file url."]}),"\n",(0,a.jsx)(d.v,{children:B}),"\n",(0,a.jsx)(e.h4,{id:"handling-timeouts",children:"Handling Timeouts"}),"\n",(0,a.jsxs)(e.p,{children:["The ",(0,a.jsx)(c.F.FontLoader,{})," uses Kotlin's ",(0,a.jsx)(e.code,{children:"suspend"})," functions for its async methods. ",(0,a.jsx)(e.a,{href:"https://kotlinlang.org/docs/reference/coroutines-overview.html",children:"Coroutines"})," are a flexible way of dealing with async/await semantics. You can support timeouts using ",(0,a.jsx)(e.code,{children:"launch"})," and canceling the resulting Job after some duration."]}),"\n",(0,a.jsx)(d.v,{children:N}),"\n",(0,a.jsx)(e.h3,{id:"measuring-text",children:"Measuring Text"}),"\n",(0,a.jsxs)(e.p,{children:["All text is positioned explicitly when rendered to a ",(0,a.jsx)(e.code,{children:"Canvas"}),". This means text alignments like centering etc., require knowledge of the text's size. You can get this via a ",(0,a.jsx)(c.F.TextMetrics,{}),", which is available by default for injection into all apps."]}),"\n",(0,a.jsxs)(e.p,{children:["This examples shows a ",(0,a.jsx)(e.code,{children:"View"})," that draws some centered text based on the calculated size of the text."]}),"\n",(0,a.jsx)(d.v,{children:W}),"\n",(0,a.jsx)(e.admonition,{type:"tip",children:(0,a.jsx)(e.p,{children:"The text location could be computed only when the View's size changes, since render can be called even more frequently than that."})}),"\n",(0,a.jsx)(e.h2,{id:"images-1",children:"Images"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(c.F.Image,{}),"s are treated like primitive elements of the rendering pipeline. They are rendered directly to a ",(0,a.jsx)(c.F.Canvas,{})," like other shapes and text. This means transformations and other rendering capabilities apply to images as well."]}),"\n",(0,a.jsxs)(e.p,{children:["You are able to define the rectangular region within an image that will be put onto the ",(0,a.jsx)(e.code,{children:"Canvas"}),", as well as where on the ",(0,a.jsx)(e.code,{children:"Canvas"})," that region will be placed. These two values allow you to zoom and scale images as you draw them."]}),"\n",(0,a.jsxs)(r.A,{children:[(0,a.jsxs)(l.A,{value:"Image",children:[(0,a.jsx)(s.T,{functionName:"images",height:"300"}),(0,a.jsx)(d.v,{children:J})]}),(0,a.jsxs)(l.A,{value:"Cropped",children:[(0,a.jsx)(s.T,{functionName:"croppedImage",height:"300"}),(0,a.jsx)(d.v,{children:H})]}),(0,a.jsxs)(l.A,{value:"Aspect Cropped",children:[(0,a.jsx)(s.T,{functionName:"aspectCroppedImage",height:"300"}),(0,a.jsx)(d.v,{children:U})]})]}),"\n",(0,a.jsx)(e.admonition,{type:"tip",children:(0,a.jsx)(e.p,{children:"You can also control the corner radius, and opacity of the image being drawn."})}),"\n",(0,a.jsxs)(e.p,{children:["You load ",(0,a.jsx)(c.F.Image,{}),"s into your app using the ",(0,a.jsx)(c.F.ImageLoader,{}),". This interface provides an async API for fetching images from different sources."]}),"\n",(0,a.jsx)(p.Ay,{link:(0,a.jsx)(c.F.ImageModule,{}),module:q}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(c.F.ImageLoader,{})," provides APIs for loading images from various sources, like urls, file-paths, and ",(0,a.jsx)(e.code,{children:"LocalFiles"})," that are obtained during ",(0,a.jsx)(e.a,{href:"dragdrop",children:"drag-drop"})," or via a ",(0,a.jsx)(e.a,{href:"ui_components/overview#fileselector",children:"FileSelector"}),"."]}),"\n",(0,a.jsxs)(e.p,{children:["The following examples shows how loading works. Notice that ",(0,a.jsx)(e.code,{children:"ImageLoader.load"})," returns ",(0,a.jsx)(e.code,{children:"Image?"}),", which is ",(0,a.jsx)(e.code,{children:"null"})," when the image fails to load for some reason. Fetching is also async, so it must be done from a ",(0,a.jsx)(e.code,{children:"suspend"})," method or a ",(0,a.jsx)(e.code,{children:"CoroutineScope"}),"."]}),"\n",(0,a.jsx)(d.v,{children:Y}),"\n",(0,a.jsx)(e.admonition,{type:"tip",children:(0,a.jsxs)(e.p,{children:["See here for an example of how you might handle ",(0,a.jsx)(e.a,{href:"rendering#handling-timeouts",children:"time-outs"}),"."]})}),"\n",(0,a.jsx)(e.h2,{id:"efficient-rendering",children:"Efficient rendering"}),"\n",(0,a.jsxs)(e.p,{children:["Doodle optimizes rendering to avoid re-applying operations when drawing the same content repeatedly. For example, the ",(0,a.jsx)(e.code,{children:"Timer"})," app below renders the epoch time every millisecond. However, Doodle only updates the changing regions (i.e. the DOM for Web apps), which is the text in this case. This reduces the amount of thrash in the DOM for Web apps."]}),"\n",(0,a.jsx)(s.T,{functionName:"timer",height:"280"}),"\n",(0,a.jsxs)(r.A,{children:[(0,a.jsx)(l.A,{value:"View DSL",children:(0,a.jsx)(d.v,{children:h})}),(0,a.jsx)(l.A,{value:"Render Property",children:(0,a.jsx)(d.v,{children:g})})]}),"\n",(0,a.jsx)(e.admonition,{type:"info",children:(0,a.jsxs)(e.p,{children:["Doodle uses ",(0,a.jsx)(e.a,{href:"https://nacular.github.io/measured/",children:"Measured"})," for time, angles etc."]})})]})}function nn(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(Z,{...n})}):Z(n)}function en(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);