"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[637],{7691:(e,n,t)=>{t.d(n,{ZP:()=>s});var o=t(7462),i=(t(7294),t(3905)),a=(t(8209),t(4866),t(5162),t(1912));const l={toc:[]},r="wrapper";function s(e){let{components:n,...t}=e;return(0,i.kt)(r,(0,o.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("admonition",{title:"Module Required",type:"info"},(0,i.kt)("p",null,"You must include the ",t.link," in your application in order to use these features."),(0,i.kt)(a.O,{mdxType:"KPlayground"},t.module),(0,i.kt)("p",{parentName:"admonition"},"Doodle uses opt-in modules like this to improve bundle size.")))}s.isMDXComponent=!0},3758:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>m,default:()=>b,frontMatter:()=>k,metadata:()=>v,toc:()=>f});var o=t(7462),i=(t(7294),t(3905)),a=(t(8209),t(1912)),l=t(1166),r=t(7691);const s="package keyboard\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.application.Modules.Companion.KeyboardModule\nimport io.nacular.doodle.application.application\nimport io.nacular.doodle.core.Display\nimport org.kodein.di.instance\nimport rendering.MyApp\n\n//sampleStart\nfun main() {\n    /** Include [KeyboardModule] when launching your app */\n    application(modules = listOf(KeyboardModule)) {\n        MyApp(instance())\n    }\n}\n\n/**\n * Key events will fire for this app when launched with [KeyboardModule]\n */\nclass MyApp(display: Display): Application {\n    override fun shutdown() {}\n}\n//sampleEnd",d="package focus\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.application.Modules.Companion.KeyboardModule\nimport io.nacular.doodle.application.application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.focus.FocusManager\nimport org.kodein.di.instance\n\n//sampleStart\nfun main() {\n    application(modules = listOf(KeyboardModule)) {\n        // FocusManager is available in the KeyboardModule\n        MyApp(display = instance(), focusManager = instance())\n    }\n}\n\nclass MyApp(display: Display, focusManager: FocusManager): Application {\n    init {\n        val view = view {}\n\n        display += view\n\n        // ...\n\n        focusManager.requestFocus(view)\n\n        // ...\n    }\n\n    override fun shutdown() {}\n}\n//sampleEnd",p="package keyboard\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.event.KeyEvent\nimport io.nacular.doodle.event.KeyListener\nimport io.nacular.doodle.event.KeyListener.Companion.on\nimport io.nacular.doodle.event.KeyListener.Companion.pressed\n\nfun example(view: View) {\n//sampleStart\n    // Listen to pressed/released via interface override\n    view.keyChanged += object: KeyListener {\n        override fun pressed(event: KeyEvent) {\n            // ..\n        }\n\n        override fun released(event: KeyEvent) {\n            // ..\n        }\n    }\n\n    // Listener to pressed via DSL\n    view.keyChanged += pressed { event -> /* .. */ }\n\n    // Listen to pressed/released via DSL\n    view.keyChanged += on(\n        pressed  = { event -> /* .. */ },\n        released = { event -> /* .. */ },\n    )\n//sampleEnd\n}",u="package keyboard\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.event.KeyListener.Companion.pressed\n\nfun consume(view: View) {\n//sampleStart\n    view.keyChanged += pressed { event ->\n        // ... take action based on event\n\n        event.consume() // indicate that no other listeners should be notified\n    }\n//sampleEnd\n}\n",c='package keyboard\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.event.KeyListener.Companion.pressed\nimport io.nacular.doodle.event.KeyText.Companion.Backspace\nimport io.nacular.doodle.event.KeyText.Companion.Enter\n\nfun virtualKeys(view: View) {\n//sampleStart\n    view.keyChanged += pressed { event ->\n        when (event.key) {\n            Enter     -> { /* ... */ }\n            Backspace -> { /* ... */ }\n            // ...\n        }\n    }\n\n    view.keyChanged += pressed { event ->\n        // this will be user-appropriate text when the key pressed is not\n        // one of the "named" keys (i.e. Tab, Shift, Enter, ...)\n        event.key.text\n    }\n//sampleEnd\n}\n',y="package keyboard\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.event.KeyCode.Companion.AltLeft\nimport io.nacular.doodle.event.KeyCode.Companion.AltRight\nimport io.nacular.doodle.event.KeyCode.Companion.Backspace\nimport io.nacular.doodle.event.KeyListener.Companion.pressed\n\nfun physicalKeys(view: View) {\n//sampleStart\n    view.keyChanged += pressed { event ->\n        when (event.code) {\n            AltLeft   -> { /* ... */ }\n            AltRight  -> { /* ... */ }\n            Backspace -> { /* ... */ }\n            // ...\n        }\n    }\n//sampleEnd\n}\n",k={hide_title:!0},m="Keyboard Input",v={unversionedId:"keyboard",id:"keyboard",title:"Keyboard Input",description:"Key handling is simple with Doodle; simply include the  when launching your app, and the underlying framework uses it to produce key events.",source:"@site/docs/keyboard.mdx",sourceDirName:".",slug:"/keyboard",permalink:"/doodle/docs/keyboard",draft:!1,tags:[],version:"current",frontMatter:{hide_title:!0},sidebar:"tutorialSidebar",previous:{title:"Multi-touch Support",permalink:"/doodle/docs/pointer_input/multitouch"},next:{title:"Animations",permalink:"/doodle/docs/animations"}},h={},f=[{value:"Only focused Views receive key events",id:"only-focused-views-receive-key-events",level:2},{value:"Key Listeners",id:"key-listeners",level:2},{value:"Key Event",id:"key-event",level:2},{value:"Identifying Keys",id:"identifying-keys",level:2},{value:"Virtual keys and text",id:"virtual-keys-and-text",level:3},{value:"Physical keys",id:"physical-keys",level:3}],w={toc:f},g="wrapper";function b(e){let{components:n,...t}=e;return(0,i.kt)(g,(0,o.Z)({},w,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"keyboard-input"},"Keyboard Input"),(0,i.kt)("p",null,"Key handling is simple with Doodle; simply include the ",(0,i.kt)(l.K3h,null)," when launching your app, and the underlying framework uses it to produce key events."),(0,i.kt)(r.ZP,{link:(0,i.kt)(l.K3h,null),module:s,mdxType:"ModuleRequired"}),(0,i.kt)("h2",{id:"only-focused-views-receive-key-events"},"Only focused Views receive key events"),(0,i.kt)("p",null,"A View must gain ",(0,i.kt)("inlineCode",{parentName:"p"},"focus")," in order to begin receiving key events. This ensures that only a single View can receive key events at any time within the app."),(0,i.kt)("p",null,"Use the ",(0,i.kt)(l.IKS,null)," to control focus. It is included in the ",(0,i.kt)(l.K3h,null),". Just inject it into your app to begin managing the focus."),(0,i.kt)(a.O,{mdxType:"KPlayground"},d),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Some controls (i.e. ",(0,i.kt)("a",{parentName:"p",href:"ui_components/overview#textfield"},"TextField"),") also manage their focus when styled in the native theme")),(0,i.kt)("h2",{id:"key-listeners"},"Key Listeners"),(0,i.kt)("p",null,"Views are able to receive key events once the ",(0,i.kt)(l.K3h,null)," is loaded and they have ",(0,i.kt)("inlineCode",{parentName:"p"},"focus"),". You can then attach a ",(0,i.kt)(l.v$U,null)," to any View and get notified whenever it has focus and a key is:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Pressed")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Released"))),(0,i.kt)("p",null,"You get these notifications by registering with a View's ",(0,i.kt)(l.a1o,null)," property."),(0,i.kt)(a.O,{mdxType:"KPlayground"},p),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)(l.v$U,null)," has no-op defaults for the 2 events, so you only need to implement the ones you need."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Notice that ",(0,i.kt)(l.a1o,null),"--like other observable properties--supports many observers and enables you to add/remove\nan observer any time.")),(0,i.kt)("h2",{id:"key-event"},"Key Event"),(0,i.kt)("p",null,"The event provided to key listeners carries information about the View it originated from (",(0,i.kt)(l.niG,null),"), and various attributes about the key that was pressed or released."),(0,i.kt)("p",null,"Key events are ",(0,i.kt)("strong",{parentName:"p"},"consumable"),". This means any observer can call ",(0,i.kt)(l.Lop,null)," on the event and prevent subsequent listeners from receiving it."),(0,i.kt)(a.O,{mdxType:"KPlayground"},u),(0,i.kt)("h2",{id:"identifying-keys"},"Identifying Keys"),(0,i.kt)("h3",{id:"virtual-keys-and-text"},"Virtual keys and text"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"KeyEvent")," ",(0,i.kt)(l.TTC,null),' is a layout independent identifier that tells you which "virtual key" was pressed or which text the key can be translated into. Most key handling use-cases should use this property to compare keys.'),(0,i.kt)(a.O,{mdxType:"KPlayground"},c),(0,i.kt)("h3",{id:"physical-keys"},"Physical keys"),(0,i.kt)("p",null,'Some applications will require the use of "physical" keys instead of virtual ones. This makes sense for games or other apps where the key position on a physical keyboard matters.'),(0,i.kt)("p",null,"This information comes from ",(0,i.kt)("inlineCode",{parentName:"p"},"KeyEvent")," ",(0,i.kt)(l.j7n,null),"."),(0,i.kt)(a.O,{mdxType:"KPlayground"},y),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Physical keys do not take keyboard differences and locale into account; so avoid them if possible")))}b.isMDXComponent=!0}}]);