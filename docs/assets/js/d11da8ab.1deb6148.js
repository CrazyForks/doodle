"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[4504],{148:(e,n,t)=>{t.d(n,{SI:()=>s,cp:()=>c});var o=t(7624),i=t(4552),l=t(7793),a=t(6236),r=t(7492);const s=[];function d(e){const n={admonition:"admonition",p:"p",strong:"strong",...(0,i.M)(),...e.components};return(0,o.jsxs)(n.admonition,{title:"Library Required",type:"info",children:[(0,o.jsxs)("p",{children:["You will need to add the ",e.link," library to your app's dependencies."]}),(0,o.jsxs)(l.c,{groupId:"language",children:[(0,o.jsxs)(a.c,{value:"Kotlin",children:[(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"build.gradle.kts"})}),(0,o.jsx)(r.A,{children:e.kotlin})]}),(0,o.jsxs)(a.c,{value:"Groovy",children:[(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"build.gradle"})}),(0,o.jsx)(r.A,{children:e.groovy})]})]})]})}function c(e={}){const{wrapper:n}={...(0,i.M)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},4420:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>S,contentTitle:()=>w,default:()=>E,frontMatter:()=>j,metadata:()=>T,toc:()=>I});var o=t(7624),i=t(4552),l=t(7793),a=t(6236),r=t(5272),s=t(7492),d=t(3220),c=t(148),m=t(7112),u=t(9504),p=t(5600);const h='package forms\n\nimport io.nacular.doodle.controls.form.Form\nimport io.nacular.doodle.controls.form.textField\nimport io.nacular.doodle.utils.ToStringIntEncoder\n\n//sampleStart\nval twoDigitNumber = Regex("^1[0-5]\\\\d|^[1-9]\\\\d|^[1-9]")\n\nval form = Form { this(\n    "Mary" to textField(),\n    35     to textField(twoDigitNumber, ToStringIntEncoder),\n    // ...\n    onInvalid = {\n        // called whenever any fields is updated with invalid data\n    }) { name: String, age: Int, /*...*/ ->\n        // called each time all fields are updated with valid data\n    }\n}\n//sampleEnd',f="package forms\n\nimport io.nacular.doodle.controls.form.field\nimport io.nacular.doodle.core.view\n\nfun <T> fieldDsl() {\n//sampleStart\n    field<T> {\n        initial // initial state of the field\n        state   // mutable state of the field\n\n        view {} // view to display for the field\n    }\n//sampleEnd\n}",g="package forms\n\nimport io.nacular.doodle.controls.form.FieldInfo\nimport io.nacular.doodle.controls.form.FieldVisualizer\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.view\n\n//sampleStart\nclass MyVisualizer<T>: FieldVisualizer<T> {\n    override fun invoke(fieldInfo: FieldInfo<T>): View {\n        fieldInfo.initial // initial state of the field\n        fieldInfo.state   // mutable state of the field\n\n        return view {}    // view to display for the field\n    }\n}\n//sampleEnd",x="package forms\n\nimport io.nacular.doodle.controls.form.Form\nimport io.nacular.doodle.controls.form.field\nimport io.nacular.doodle.controls.form.textField\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.utils.ToStringIntEncoder\n\nfun <T> noDefaults() {\n//sampleStart\n    data class Person(val name: String, val age: Int)\n\n    val form = Form { this(\n        + textField(),\n        + textField(encoder = ToStringIntEncoder),\n        + field<Person> { view {} },\n        // ...\n        onInvalid = {}\n    ) { text: String, number: Int, person: Person ->\n        // ...\n    } }\n//sampleEnd\n}",v='package forms\n\nimport io.nacular.doodle.controls.form.Form\nimport io.nacular.doodle.controls.form.field\nimport io.nacular.doodle.controls.form.textField\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.utils.ToStringIntEncoder\n\nfun <T> withDefaults() {\n//sampleStart\n    data class Person(val name: String, val age: Int)\n\n    val form = Form { this(\n        "Hello"            to textField(),\n        4                  to textField(encoder = ToStringIntEncoder),\n        Person("Jack", 55) to field { view {} },\n        // ...\n        onInvalid = {}\n    ) { text: String, number: Int, person: Person ->\n        // ...\n    } }\n//sampleEnd\n}',b='package forms\n\nimport io.nacular.doodle.controls.form.Form\nimport io.nacular.doodle.controls.form.form\nimport io.nacular.doodle.controls.form.labeled\nimport io.nacular.doodle.controls.form.map\nimport io.nacular.doodle.controls.form.textField\nimport io.nacular.doodle.controls.text.TextField.Purpose.Integer\nimport io.nacular.doodle.controls.text.TextField.Purpose.Telephone\nimport io.nacular.doodle.utils.ToStringIntEncoder\n\nfun <T> formFields() {\n//sampleStart\n    data class Person(val name: String, val age: Int)\n\n    val form = Form { this(\n        + labeled("Text"     ) { textField(                            )                                   },\n        + labeled("Telephone") { textField(encoder = ToStringIntEncoder) { textField.purpose = Telephone } },\n        Person("Jack", 55) to form { this(\n            initial.map { it.name } to labeled("Name") { textField(                            )                                 },\n            initial.map { it.age  } to labeled("Age" ) { textField(encoder = ToStringIntEncoder) { textField.purpose = Integer } },\n            onInvalid = {}\n        ) { name, age ->\n            Person(name, age) // construct person when valid\n        } },\n        // ...\n        onInvalid = {}\n    ) { text: String, number: Int, person: Person ->\n        // called each time all fields are updated with valid data\n    } }\n//sampleEnd\n}',F='package forms\n\nimport io.nacular.doodle.controls.form.Form\nimport io.nacular.doodle.controls.form.form\nimport io.nacular.doodle.controls.form.labeled\nimport io.nacular.doodle.controls.form.textField\nimport io.nacular.doodle.controls.text.TextField.Purpose.Telephone\n\nfun groupingFields() {\n    data class Address(\n        val number: String,\n        val street: String,\n        val city  : String,\n        val state : String,\n        val zip   : String\n    )\n\n    data class ContactInfo(\n        val telephone: String,\n        val address  : Address,\n    )\n\n    data class PersonalInfo(\n        val name   : String,\n        val contact: ContactInfo\n    )\n\n    val notEmpty = Regex(".+")\n\n//sampleStart\n    val form = Form { this(\n        + labeled("Name") { textField(notEmpty) },\n        + form { this(\n            + labeled("Telephone") { textField(notEmpty) { textField.purpose = Telephone } },\n            + form<Address> { this(\n                + labeled("Number") { textField(notEmpty) },\n                + labeled("Street") { textField(notEmpty) },\n                + labeled("City"  ) { textField(notEmpty) },\n                + labeled("State" ) { textField(notEmpty) },\n                + labeled("Zip"   ) { textField(notEmpty) },\n            ) { number, street, city, state, zip ->\n                Address(number, street, city, state, zip)\n            } },\n        ) { telephone, address ->\n            ContactInfo(telephone, address)\n        } },\n        onInvalid = {}\n    ) { name, contact ->\n        println("Personal Info: ${PersonalInfo(name, contact)}")\n    } }\n//sampleEnd\n}\n',y='package forms\n\nimport io.nacular.doodle.controls.form.Form\nimport io.nacular.doodle.controls.form.labeled\nimport io.nacular.doodle.controls.form.textField\nimport io.nacular.doodle.controls.text.TextField.Purpose.Telephone\n\nfun destructuring() {\n\n    data class PersonalInfo(\n        val name     : String,\n        val telephone: String,\n        val number   : String,\n        val street   : String,\n        val city     : String,\n        val state    : String,\n        val zip      : String\n    )\n\n    val notEmpty = Regex(".+")\n\n//sampleStart\n    operator fun <E> List<E>.component6() = this[5]\n    operator fun <E> List<E>.component7() = this[6]\n\n    val form = Form { this(\n        + labeled("Name"     ) { textField(notEmpty) },\n        + labeled("Telephone") { textField(notEmpty) { textField.purpose = Telephone } },\n        + labeled("Number"   ) { textField(notEmpty) },\n        + labeled("Street"   ) { textField(notEmpty) },\n        + labeled("City"     ) { textField(notEmpty) },\n        + labeled("State"    ) { textField(notEmpty) },\n        + labeled("Zip"      ) { textField(notEmpty) },\n        onInvalid = {},\n    ) { (name, telephone, number, street, city, state, zip) ->\n        println("Personal Info: ${PersonalInfo(\n            name      as String, // Cast required for all fields\n            telephone as String,\n            number    as String,\n            street    as String,\n            city      as String,\n            state     as String,\n            zip       as String\n        )}")\n    } }\n\n//sampleEnd\n}\n\n',j={hide_title:!0,title:"Forms"},w=void 0,T={id:"ui_components/form",title:"Forms",description:"Forms",source:"@site/docs/ui_components/form.mdx",sourceDirName:"ui_components",slug:"/ui_components/form",permalink:"/doodle/docs/ui_components/form",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{hide_title:!0,title:"Forms"},sidebar:"tutorialSidebar",previous:{title:"Catalog",permalink:"/doodle/docs/ui_components/overview"},next:{title:"Form Controls",permalink:"/doodle/docs/ui_components/form_controls"}},S={},I=[{value:"Forms",id:"forms",level:2},...c.SI,{value:"Like constructors",id:"like-constructors",level:2},{value:"Fields",id:"fields",level:2},{value:"Creating fields",id:"creating-fields",level:3},{value:"Field binding",id:"field-binding",level:3},{value:"Forms as fields",id:"forms-as-fields",level:3},{value:"Layouts",id:"layouts",level:2},{value:"More than 5 fields?",id:"more-than-5-fields",level:2},{value:"Group related fields into objects",id:"group-related-fields-into-objects",level:3},{value:"Use list destructuring + casting",id:"use-list-destructuring--casting",level:3}];function k(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",strong:"strong",...(0,i.M)(),...e.components};return d.m||L("api",!1),d.m.ControlsLibrary||L("api.ControlsLibrary",!0),d.m.Field||L("api.Field",!0),d.m.FieldState||L("api.FieldState",!0),d.m.FieldVisualizer||L("api.FieldVisualizer",!0),d.m.Form||L("api.Form",!0),d.m.FormFunc||L("api.FormFunc",!0),d.m.Invalid||L("api.Invalid",!0),d.m.Layout||L("api.Layout",!0),d.m.Valid||L("api.Valid",!0),d.m.VerticalLayout||L("api.VerticalLayout",!0),d.m.View||L("api.View",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"forms",children:"Forms"}),"\n",(0,o.jsx)(n.p,{children:"Doodle forms make data collection simple, while still preserving flexibility to build just the right experience. They hide a lot of the complexity associated with mapping visual components to fields, state management, and validation. The result is an intuitive metaphor modeled around the idea of a constructor."}),"\n",(0,o.jsx)(c.cp,{link:(0,o.jsx)(d.m.ControlsLibrary,{}),kotlin:m.c,groovy:u.c}),"\n",(0,o.jsx)(n.p,{children:"Doodle also has a set of helpful forms controls that cover a reasonable range of data-types. These make its easy to create forms without much hassle. But there are bound to be cases where more customization is needed. This is why Doodle forms are also extensible, allowing you to fully customize the data they bind to and how each fields is visualized."}),"\n",(0,o.jsxs)(l.c,{children:[(0,o.jsx)(a.c,{value:"Demo",children:(0,o.jsx)(r.u,{functionName:"form",height:"540"})}),(0,o.jsx)(a.c,{value:"Usage",children:(0,o.jsx)(s.A,{children:p.c})})]}),"\n",(0,o.jsx)(n.h2,{id:"like-constructors",children:"Like constructors"}),"\n",(0,o.jsx)(n.p,{children:'Forms are very similar to constructors in that they have typed parameter lists (fields), and can only "create" instances when all their inputs are valid. Like any constructor, a Form can have optional fields, default values, and arbitrary types for its fields.'}),"\n",(0,o.jsxs)(n.p,{children:["While Forms behave like constructors in most ways, they do not actually create instances (only ",(0,o.jsx)(n.a,{href:"form#forms-as-fields",children:"sub-forms"})," do). This means they are not typed. Instead, they take fields and output a corresponding lists of strongly-typed data when all their fields are valid. This notification is intentionally general to allow forms to be used in a wide range of used cases."]}),"\n",(0,o.jsxs)(n.p,{children:["Forms are created using the ",(0,o.jsx)(d.m.FormFunc,{}),' DSL function. This function ensures strong typing for fields and the form\'s "output".']}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsx)(n.p,{children:"The Form returned from the builder does not expose anything about the data it produces. So all consumption logic goes in the builder block."})}),"\n",(0,o.jsx)(s.A,{children:h}),"\n",(0,o.jsx)(n.h2,{id:"fields",children:"Fields"}),"\n",(0,o.jsxs)(n.p,{children:["Each field defined in the ",(0,o.jsx)(d.m.Form,{})," will be bounded to a single ",(0,o.jsx)(d.m.View,{}),". These views are defined during field binding using a ",(0,o.jsx)(d.m.FieldVisualizer,{}),". A visualizer is responsible for taking a ",(0,o.jsx)(d.m.Field,{})," and its initial state and returning a View. The visualizer then acts as the bridge between the field's state and the View, mapping changes made in the View to the field (this includes validating that input)."]}),"\n",(0,o.jsxs)(n.p,{children:["Fields store their data as ",(0,o.jsx)(d.m.FieldState,{}),". This is a strongly-typed value that can be ",(0,o.jsx)(d.m.Valid,{})," or ",(0,o.jsx)(d.m.Invalid,{}),". Valid state contains a value, while invalid state does not. A Form with any invalid fields is invalid itself, and will indicate this by calling ",(0,o.jsx)(n.code,{children:"onInvalid"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"creating-fields",children:"Creating fields"}),"\n",(0,o.jsxs)(n.p,{children:["Fields are created implicitly when FieldVisualizers are bound to a Form. These visualizers can be created using the ",(0,o.jsx)(d.m.Field,{})," DSL, by implementing the interface, or by one of the existing form controls."]}),"\n",(0,o.jsxs)(l.c,{groupId:"language",children:[(0,o.jsx)(a.c,{value:"DSL",children:(0,o.jsx)(s.A,{children:f})}),(0,o.jsx)(a.c,{value:"Interface",children:(0,o.jsx)(s.A,{children:g})})]}),"\n",(0,o.jsx)(n.h3,{id:"field-binding",children:"Field binding"}),"\n",(0,o.jsx)(n.p,{children:"Fields all have an optional initial value. Therefore, each field can be bounded either with a value or without one. The result is 2 different ways of adding a field to a Form."}),"\n",(0,o.jsx)(n.p,{children:"The following shows how to bind fields that has no default value."}),"\n",(0,o.jsx)(s.A,{children:x}),"\n",(0,o.jsx)(n.p,{children:"This shows how to bind using initial values."}),"\n",(0,o.jsx)(s.A,{children:v}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.p,{children:["These examples bind fields that have no names. Doodle has a ",(0,o.jsx)(n.a,{href:"/doodle/docs/ui_components/form_controls#labeled",children:(0,o.jsx)(n.code,{children:"labeled"})})," form control that wraps a control and assigns a name to it."]})}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsx)(n.p,{children:"Note that a visualizer may set a field's state to some valid value at initialization time. This will give the same effect as that field having had a initial value specified that the visualizer accepted."})}),"\n",(0,o.jsx)(n.h3,{id:"forms-as-fields",children:"Forms as fields"}),"\n",(0,o.jsx)(n.p,{children:"Forms can also have nested forms within them. This is helpful when the field has complex data that can be presented to the user as a set of components. Such cases can be handled with custom visualizers, but many work well using a nested form."}),"\n",(0,o.jsxs)(n.p,{children:["Nested forms are created using the ",(0,o.jsx)(d.m.FormFunc,{})," DSL. It works just like the top-level ",(0,o.jsx)(n.code,{children:"Form"})," DSL, but it actually ",(0,o.jsx)(n.strong,{children:"creates an instance"})," and has access to the initial value it is bound to (if any)."]}),"\n",(0,o.jsxs)(l.c,{children:[(0,o.jsx)(a.c,{value:"Demo",children:(0,o.jsx)(r.u,{functionName:"nestedForm",height:"400"})}),(0,o.jsx)(a.c,{value:"Usage",children:(0,o.jsx)(s.A,{children:b})})]}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsx)(n.p,{children:"Nested forms can be used with or without initial values like any other field."})}),"\n",(0,o.jsx)(n.h2,{id:"layouts",children:"Layouts"}),"\n",(0,o.jsxs)(n.p,{children:["Forms allow you to position their fields via a ",(0,o.jsx)(d.m.Layout,{})," just like other containers. This positionable items seen by the layout will correspond to the fields bound to the Form in the same order. All the examples in this documentation use a vertical layout via the ",(0,o.jsx)(d.m.VerticalLayout,{})," helper."]}),"\n",(0,o.jsx)(n.h2,{id:"more-than-5-fields",children:"More than 5 fields?"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(d.m.FormFunc,{})," DSLs have variants for up to 5 fields, as well as a version that takes an arbitrary number of fields, but does not provide strongly typed data back. This is by design. Forms are generally easier to use if they are shorter. Nonetheless, you can achieve this with a bit of extra work."]}),"\n",(0,o.jsx)(n.h3,{id:"group-related-fields-into-objects",children:"Group related fields into objects"}),"\n",(0,o.jsxs)(n.p,{children:["The recommended approach is to try and group related data together so you reduce the number of fields within your Forms. This is a good practice in general, since it defines the semantics of your data right when they are collected. It is also easy to achieve with nested ",(0,o.jsx)(n.code,{children:"form"})," fields."]}),"\n",(0,o.jsxs)(l.c,{children:[(0,o.jsx)(a.c,{value:"Demo",children:(0,o.jsx)(r.u,{functionName:"personalInfoForm",height:"600"})}),(0,o.jsx)(a.c,{value:"Usage",children:(0,o.jsx)(s.A,{children:F})})]}),"\n",(0,o.jsxs)(n.p,{children:["This app takes 2 top level fields for the user's name and contact info. Contact info this obtained using a sub ",(0,o.jsx)(n.code,{children:"form"})," that produces an object. That object in turn contains a telephone and address. The latter is itself a data object that is obtained using a nested form as well."]}),"\n",(0,o.jsx)(n.h3,{id:"use-list-destructuring--casting",children:"Use list destructuring + casting"}),"\n",(0,o.jsxs)(n.p,{children:["The other approach is using ",(0,o.jsx)(n.code,{children:"List"})," ",(0,o.jsx)(n.a,{href:"https://stackoverflow.com/questions/55890980/kotlin-destructuring-more-than-five-components",children:"destructuring"})," to pull out the results of the untyped version of the ",(0,o.jsx)(d.m.FormFunc,{})," DSL. The form above can also be achieved by defining the 6 and 7 component destructors and then casting each element to the correct type."]}),"\n",(0,o.jsx)(s.A,{children:y}),"\n",(0,o.jsx)(n.admonition,{type:"caution",children:(0,o.jsxs)(n.p,{children:["This approach is sometimes more concise than the sub form approach, but it is ",(0,o.jsx)(n.strong,{children:"discouraged"})," b/c it introduces brittleness due to the casting."]})})]})}function E(e={}){const{wrapper:n}={...(0,i.M)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(k,{...e})}):k(e)}function L(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},5600:(e,n,t)=>{t.d(n,{c:()=>o});const o='package controls\n\nimport controls.Gender.Female\nimport controls.Gender.Male\nimport io.nacular.doodle.controls.buttons.PushButton\nimport io.nacular.doodle.controls.form.Form\nimport io.nacular.doodle.controls.form.LabeledConfig\nimport io.nacular.doodle.controls.form.TextFieldConfig\nimport io.nacular.doodle.controls.form.form\nimport io.nacular.doodle.controls.form.labeled\nimport io.nacular.doodle.controls.form.radioList\nimport io.nacular.doodle.controls.form.textField\nimport io.nacular.doodle.controls.form.verticalLayout\nimport io.nacular.doodle.controls.text.TextField.Purpose\nimport io.nacular.doodle.controls.text.TextField.Purpose.Integer\nimport io.nacular.doodle.controls.text.TextField.Purpose.Text\nimport io.nacular.doodle.drawing.Color.Companion.Red\nimport io.nacular.doodle.drawing.Font\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.text.StyledText\nimport io.nacular.doodle.text.invoke\nimport io.nacular.doodle.utils.ToStringIntEncoder\n\nenum class Gender { Male, Female }\n\nfun form(smallFont: Font) {\n    fun <T> LabeledConfig.textFieldConfig(\n        placeHolder: String      = "",\n        purpose    : Purpose     = Text,\n        errorText  : StyledText? = null\n    ): TextFieldConfig<T>.() -> Unit = {\n        val initialHelperText = help.styledText\n\n        help.font             = smallFont\n        textField.placeHolder = placeHolder\n        textField.purpose     = purpose\n        onValid               = { help.styledText = initialHelperText }\n        onInvalid             = {\n            if (!textField.hasFocus) {\n                help.styledText = errorText ?: it.message?.let { Red(it) } ?: help.styledText\n            }\n        }\n    }\n\n    val submit = PushButton("Submit").apply {\n        enabled = false\n        size = Size(100, 32)\n    }\n\n    val twoDigitNumber = Regex("^1[0-5]\\\\d|^[1-9]\\\\d|^[1-9]")\n\n//sampleStart\n    val form = Form { this(\n        +labeled("Name", help = "3+ letters") {\n            textField(Regex(".{3,}"), config = textFieldConfig("Enter your name"))\n        },\n        +labeled("Age", help = "1 or 2 digit number") {\n            textField(twoDigitNumber, ToStringIntEncoder, config = textFieldConfig(purpose = Integer))\n        },\n        Female to labeled("Gender") { radioList(Male, Female) { spacing = 12.0 } },\n        +form { this(\n            +labeled("Text [Sub-form]", help = "Can be blank") {\n                textField(Regex(".*"), config = textFieldConfig())\n            },\n            +labeled("Number [Sub-form]", help = "1 to 10") {\n                textField(\n                    twoDigitNumber,\n                    ToStringIntEncoder,\n                    validator = { it <= 10 },\n                    config    = textFieldConfig(purpose = Integer)\n                )\n            }\n        ) { first, second ->\n            // nested Form creates a Pair<String, Int>\n            first to second\n        } },\n        onInvalid = { submit.enabled = false },\n    ) { name, age, gender, pair ->\n        submit.enabled = true\n        println("[Form valid] Name: $name, Age: $age, Gender: $gender, Sub-form: $pair") // <---- check console for output\n    } }.apply {\n        // configure the Form view itself\n        size      = Size(300, 100)\n        layout    = verticalLayout(this, spacing = 12.0, itemHeight = 32.0)\n        focusable = false\n    }\n//sampleEnd\n}'},9504:(e,n,t)=>{t.d(n,{c:()=>o});const o='//sampleStart\ndependencies {\n    implementation "io.nacular.doodle:controls:$doodle_version"\n}\n//sampleEnd'},7112:(e,n,t)=>{t.d(n,{c:()=>o});const o='dependencies {\n    implementation ("io.nacular.doodle:controls:$doodleVersion")\n}'}}]);