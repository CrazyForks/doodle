"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[1696],{7272:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>u,contentTitle:()=>p,default:()=>g,frontMatter:()=>c,metadata:()=>v,toc:()=>m});var o=i(7624),a=i(2172),r=i(5720),t=i(3148);const l="package rendering\n\nimport io.nacular.doodle.controls.text.TextField\nimport io.nacular.doodle.drawing.Color.Companion.Darkgray\nimport io.nacular.doodle.drawing.Color.Companion.White\n\nfun example() {\n//sampleStart\n    val textField = TextField().apply {\n        backgroundColor = Darkgray\n        foregroundColor = White\n        borderVisible   = false\n    }\n//sampleEnd\n}",s="package rendering\n\nimport io.nacular.doodle.controls.buttons.Button\nimport io.nacular.doodle.core.Behavior\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.geometry.Point\n\n//sampleStart\nclass MyBehavior: Behavior<Button> {\n    override fun install              (view: Button                ) {}\n    override fun render               (view: Button, canvas: Canvas) {}\n    override fun contains             (view: Button, point : Point ) = point in view.bounds\n    override fun clipCanvasToBounds   (view: Button                ) = true\n    override fun mirrorWhenRightToLeft(view: Button                ) = view.mirrorWhenRightLeft\n    override fun uninstall            (view: Button                ) {}\n}\n//sampleEnd",d="package rendering\n\nimport io.nacular.doodle.core.Behavior\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.behavior\n\n//sampleStart\nclass AView: View() {\n    // ...\n    var behavior: Behavior<AView>? by behavior()\n}\n//sampleEnd",h="package rendering\n\nimport io.nacular.doodle.controls.panels.TabbedPanel\nimport io.nacular.doodle.controls.panels.TabbedPanelBehavior\nimport io.nacular.doodle.core.Layout.Companion.simpleLayout\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.utils.diff.Differences\n\n//sampleStart\nclass MyTabbedPanelBehavior: TabbedPanelBehavior<Any>() {\n    override fun install(view: TabbedPanel<Any>) {\n        // children and layout accessible to TabbedPanelBehavior subclasses\n        view        += view {}\n        view.layout  = simpleLayout {\n            // ...\n        }\n    }\n\n    override fun uninstall(view: TabbedPanel<Any>) {\n        view.children.clear()\n        view.layout = null\n    }\n\n    override fun itemsChanged(panel: TabbedPanel<Any>, differences: Differences<Any>) {\n        // ...\n    }\n\n    override fun selectionChanged(panel: TabbedPanel<Any>, new: Any?, newIndex: Int?, old: Any?, oldIndex: Int?) {\n        // ...\n    }\n}\n\nfun usage(tabbedPanel: TabbedPanel<Any>) {\n    tabbedPanel.behavior = MyTabbedPanelBehavior()\n}\n//sampleEnd",c={title:"Behaviors",hide_title:!0},p=void 0,v={id:"rendering/behaviors",title:"Behaviors",description:"Behaviors",source:"@site/docs/rendering/behaviors.mdx",sourceDirName:"rendering",slug:"/rendering/behaviors",permalink:"/doodle/docs/rendering/behaviors",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Behaviors",hide_title:!0},sidebar:"tutorialSidebar",previous:{title:"3D",permalink:"/doodle/docs/rendering/3d"},next:{title:"Positioning",permalink:"/doodle/docs/layouts/overview"}},u={},m=[{value:"Behaviors",id:"behaviors",level:2},{value:"Implementing a Behavior",id:"implementing-a-behavior",level:3},{value:"Delegating to a Behavior",id:"delegating-to-a-behavior",level:3},{value:"Specialized Behaviors",id:"specialized-behaviors",level:2}];function b(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",strong:"strong",...(0,a.M)(),...e.components};return t||f("api",!1),t.Behavior||f("api.Behavior",!0),t.TabbedPanelBehavior||f("api.TabbedPanelBehavior",!0),t.ViewBehaviorDelegate||f("api.ViewBehaviorDelegate",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"behaviors",children:"Behaviors"}),"\n",(0,o.jsx)(n.p,{children:"It is common to make a View's behavior and presentation configurable. In many cases this happens through properties like colors, fonts, etc."}),"\n",(0,o.jsx)(r.A,{children:l}),"\n",(0,o.jsxs)(n.p,{children:["Sometimes a View needs to support more complex customization. Take a ",(0,o.jsx)(n.a,{href:"../ui_components/overview#tabbedpanel",children:"TabbedPanel"})," for example. The number of configurations is fairly open-ended; and the API would be needlessly complex if it tried to encompass everything."]}),"\n",(0,o.jsxs)(n.p,{children:["This is where a ",(0,o.jsx)(t.Behavior,{})," comes in handy. Views can offer deep customization by delegating rendering, hit detection and anything else to Behaviors. TabbedPanel--along with ",(0,o.jsx)(n.a,{href:"../ui_components/overview#textfield",children:"TextField"})," and many other controls--actually does this."]}),"\n",(0,o.jsx)(n.h3,{id:"implementing-a-behavior",children:"Implementing a Behavior"}),"\n",(0,o.jsxs)(n.p,{children:["Behaviors offer a few common capabilities that help with View customization. You create one by implementing the ",(0,o.jsx)(t.Behavior,{})," interface, or a sub-type of it depending on the target View."]}),"\n",(0,o.jsx)(r.A,{children:s}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.p,{children:["The methods on ",(0,o.jsx)(n.code,{children:"Behavior"})," are all optional"]})}),"\n",(0,o.jsx)(n.p,{children:"Behaviors support installation and uninstallation to and from Views. This gives each Behavior a chance to configure the target View upon first assignment and cleanup when removed."}),"\n",(0,o.jsx)(n.h3,{id:"delegating-to-a-behavior",children:"Delegating to a Behavior"}),"\n",(0,o.jsxs)(n.p,{children:["View subtypes need to manage behaviors directly. Kotlin does not have self types, so the ",(0,o.jsx)(n.code,{children:"View"})," base class cannot have a ",(0,o.jsx)(n.code,{children:"behavior<Self>"})," to make this easier."]}),"\n",(0,o.jsx)(r.A,{children:d}),"\n",(0,o.jsxs)(n.p,{children:["However, View subtypes can use the ",(0,o.jsx)(t.ViewBehaviorDelegate,{})," delegate to guarantee proper installation and uninstallation. This delegate also ensures a Behavior's overrides for things like ",(0,o.jsx)(n.code,{children:"clipCanvasToBounds"})," or ",(0,o.jsx)(n.code,{children:"mirrorWhenRightToLeft"})," are not missed during installation."]}),"\n",(0,o.jsx)(n.h2,{id:"specialized-behaviors",children:"Specialized Behaviors"}),"\n",(0,o.jsxs)(n.p,{children:["As mentioned before, TabbedPanel delegates a lot to its Behavior. It actually exposes the fact that it is a container to it. This is done using the ",(0,o.jsx)(t.TabbedPanelBehavior,{})," sub interface. Classes that implement this interface are able to directly modify their panel's ",(0,o.jsx)(n.code,{children:"children"})," and ",(0,o.jsx)(n.code,{children:"layout"}),"."]}),"\n",(0,o.jsx)(r.A,{children:h}),"\n",(0,o.jsx)(n.p,{children:"This provides great flexibility when defining the presentation and behavior for TabbedPanels. You can do similar things with Views in your app."}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.p,{children:["You can automatically style Views using ",(0,o.jsx)(n.a,{href:"/doodle/docs/themes",children:(0,o.jsx)(n.strong,{children:"Themes"})})]})})]})}function g(e={}){const{wrapper:n}={...(0,a.M)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(b,{...e})}):b(e)}function f(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);