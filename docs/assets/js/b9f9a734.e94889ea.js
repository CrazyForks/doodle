"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[92],{4358:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>f,contentTitle:()=>d,default:()=>p,frontMatter:()=>c,metadata:()=>l,toc:()=>h});var t=n(7462),r=(n(7294),n(3905)),o=(n(8209),n(5488)),s=n(5162),i=n(4903);const c={hide_title:!0},d="3D",l={unversionedId:"rendering/3d",id:"rendering/3d",title:"3D",description:"Canvas offers basic 3D capabilities through the use of AffineTransforms and Cameras. This enables Views to display",source:"@site/docs/rendering/3d.mdx",sourceDirName:"rendering",slug:"/rendering/3d",permalink:"/doodle/docs/rendering/3d",draft:!1,tags:[],version:"current",frontMatter:{hide_title:!0},sidebar:"tutorialSidebar",previous:{title:"Colors",permalink:"/doodle/docs/rendering/colors"},next:{title:"Behaviors",permalink:"/doodle/docs/rendering/behaviors"}},f={},h=[],m={toc:h};function p(e){let{components:a,...n}=e;return(0,r.kt)("wrapper",(0,t.Z)({},m,n,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"3d"},"3D"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"overview#the-canvas"},"Canvas")," offers basic 3D capabilities through the use of ",(0,r.kt)("inlineCode",{parentName:"p"},"AffineTransform"),"s and ",(0,r.kt)("inlineCode",{parentName:"p"},"Camera"),"s. This enables Views to display\ncontent in a shared 3D space. The following examples has a View that draws a 3D cube. The cube looks like a 3D object even though it is flat\non the View's surface."),(0,r.kt)("p",null,"The controls (which are overlaid on the View) let you change the starting transform applied to the cube's back face\n(which changes the cube's overall transform), the folding angle of each face, and the camera used to create the perspective."),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"demo",label:"Demo",mdxType:"TabItem"},(0,r.kt)(i.l,{functionName:"cube",height:"500",mdxType:"DoodleApp"})),(0,r.kt)(s.Z,{value:"code",label:"Cube.kt",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"class Cube: View() {\n    private val side   = 100.0\n    private val rect   = Rectangle(size = Size(side))\n    private val stroke = Stroke(thickness = 2.0, fill = Darkgray.paint)\n\n    var foldAngle       by renderProperty(-90 * degrees                    ) { _,_ -> (changed as ChangeObserversImpl).invoke() }\n    var canvasCamera    by renderProperty(Camera(Origin, 1000.0)           ) { _,_ -> (changed as ChangeObserversImpl).invoke() }\n    var canvasTransform by renderProperty(Identity.translate(z = -side / 2)) { _,_ -> (changed as ChangeObserversImpl).invoke() }\n\n    val changed: ChangeObservers<Cube> = ChangeObserversImpl(this)\n\n    override fun render(canvas: Canvas) {\n        var transform    = canvasTransform\n        var faceLocation = Point((width - side) / 2, (height - side) / 2)\n\n        drawFace(canvas, faceLocation, transform) // Back\n\n        faceLocation += Point(x = side)\n        transform    *= Identity.rotateY(around = faceLocation, foldAngle)\n\n        drawFace(canvas, faceLocation, transform) // Right\n\n        faceLocation -= Point(y = side)\n\n        drawFace(canvas, faceLocation, transform.rotateX(around = faceLocation + Point(y = side), foldAngle)) // Top\n\n        faceLocation += Point(y = 2 * side)\n        transform    *= Identity.rotateX(around = faceLocation, -foldAngle)\n\n        drawFace(canvas, faceLocation, transform) // Bottom\n\n        faceLocation += Point(y = side)\n        transform    *= Identity.rotateX(around = faceLocation, -foldAngle)\n\n        drawFace(canvas, faceLocation, transform) // Left\n\n        faceLocation += Point(x = side)\n        transform    *= Identity.rotateY(around = faceLocation, foldAngle)\n\n        drawFace(canvas, faceLocation, transform) // Front\n    }\n\n    private fun drawFace(canvas: Canvas, location: Point, transform: AffineTransform) {\n        canvas.transform(transform, canvasCamera) { rect(rect.at(location), stroke) }\n    }\n}\n")))))}p.isMDXComponent=!0}}]);