"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[2088],{8872:(e,n,o)=>{o.d(n,{o:()=>d});var i=o(1504),t=o(8556),a=o.n(t),r=o(312),l=o(1130),s=(o(5544),o(7624));class d extends i.Component{constructor(e){super(e),e.args&&(this.args=JSON.parse(e.args)),this.height=e.height,this.functionName="reactComponent",this.ref=i.createRef()}componentDidMount(){let e=this.ref.current.children[1];this.ref.current.removeChild(this.ref.current.children[1]),this.app=a()[this.functionName](this.ref.current.children[0],e)}componentWillUnmount(){this.app}render(){return(0,s.jsxs)("div",{className:r.c.doodle,ref:this.ref,children:[(0,s.jsx)("div",{style:{position:"relative",height:this.height+"px"}}),(0,s.jsx)(l.cp,{})]})}}},3432:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>P,contentTitle:()=>A,default:()=>L,frontMatter:()=>C,metadata:()=>T,toc:()=>B});var i=o(7624),t=o(4552),a=o(7793),r=o(6236),l=o(5272),s=o(7492),d=o(8872),c=o(3220),p=o(7196),m=o(9540),u=o(7696),h=o(2456),w=o(6388);const g='package io.nacular.doodle.docs.apps\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.controls.buttons.PushButton\nimport io.nacular.doodle.controls.form.Always\nimport io.nacular.doodle.controls.form.Form\nimport io.nacular.doodle.controls.form.labeled\nimport io.nacular.doodle.controls.form.textField\nimport io.nacular.doodle.controls.form.verticalLayout\nimport io.nacular.doodle.controls.text.TextField\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.drawing.Font\nimport io.nacular.doodle.event.KeyCode.Companion.Enter\nimport io.nacular.doodle.event.KeyListener\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.theme.Theme\nimport io.nacular.doodle.theme.ThemeManager\nimport io.nacular.doodle.utils.Resizer\n\nclass EnterKeyInterceptApp(\n    display     : Display,\n    font        : Font,\n    themeManager: ThemeManager,\n    theme       : Theme\n): Application {\n    private lateinit var name    : TextField\n    private lateinit var password: TextField\n\n    private val submit = PushButton("Submit").apply {\n        this.font    = font\n        this.size    = Size(100, 32)\n        this.enabled = false\n\n        this.fired += {\n            name.text     = ""\n            password.text = ""\n        }\n    }\n\n    private val form = Form { this (\n        + labeled("Name",     showRequired = Always()) { textField(Regex(".{3,}")) { name     = textField } },\n        + labeled("Password", showRequired = Always()) { textField(Regex(".{3,}")) { password = textField } },\n        onInvalid = { submit.enabled = false },\n    ) { _,_ ->\n        submit.enabled = true\n    } }.apply {\n        this.font      = font\n        this.size      = Size(300, 100)\n        this.layout    = verticalLayout(this, spacing = 12.0, itemHeight = 32.0)\n        this.focusable = false\n        Resizer(this).apply { movable = false }\n    }\n\n    init {\n        themeManager.selected = theme\n\n//sampleStart\n        form.keyFilter += KeyListener.pressed {\n            if (it.code == Enter && submit.enabled) {\n                it.consume()\n                submit.click()\n            }\n        }\n//sampleEnd\n\n        display += listOf(form, submit)\n\n        display.layout = constrain(form, submit) { form_, submit_ ->\n            val spacing = 10\n\n            form_.center    eq parent.center - Point(y = (spacing + submit_.height.readOnly) / 2)\n            submit_.top     eq form_.bottom + spacing\n            submit_.centerX eq form_.centerX\n        }\n    }\n\n    override fun shutdown() {}\n}';var v=o(6068);const y="package io.nacular.doodle.docs.apps\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.container\nimport io.nacular.doodle.core.renderProperty\nimport io.nacular.doodle.docs.utils.BlueColor\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.drawing.SweepGradientPaint\nimport io.nacular.doodle.drawing.opacity\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.event.PointerEvent\nimport io.nacular.doodle.event.PointerListener.Companion.entered\nimport io.nacular.doodle.event.PointerMotionListener.Companion.on\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.geometry.ringSection\nimport io.nacular.doodle.layout.constraints.center\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.layout.constraints.fill\nimport io.nacular.doodle.utils.lerp\nimport io.nacular.measured.units.Angle.Companion.degrees\nimport io.nacular.measured.units.times\nimport kotlin.math.max\nimport kotlin.math.min\n\nclass SweepGradientProgressApp(display: Display): Application {\n\n    private class Progress: View() {\n        var progress by renderProperty(1f)\n\n        private val thickness  =  50.0\n        private val startAngle =  20 * degrees\n        private val endAngle   = 360 * degrees\n\n        init {\n            clipCanvasToBounds = false\n        }\n\n        override fun render(canvas: Canvas) {\n            val center      = Point(width / 2, height / 2)\n            val outerRadius = min(center.x, center.y)\n\n//sampleStart\n            canvas.outerShadow(vertical = 10.0, blurRadius = 10.0, color = Black opacity 0.5f) {\n                path(\n                    ringSection(\n                        center      = center,\n                        innerRadius = max(0.0, outerRadius - thickness),\n                        outerRadius = outerRadius,\n                        start       = startAngle,\n                        end         = lerp(startAngle, endAngle, progress),\n                        endCap      = { _,it ->\n                            arcTo(it, radius = thickness / 2, largeArch = true, sweep = true)\n                        }\n                    ),\n                    SweepGradientPaint(\n                        color1      = BlueColor opacity 0f,\n                        color2      = BlueColor opacity 1f,\n                        center      = center,\n                        rotation    = startAngle\n                    )\n                )\n            }\n//sampleEnd\n        }\n    }\n\n    init {\n        display += container {\n            val bar = Progress().apply { size = Size(200) }\n\n            +bar\n            layout = constrain(bar, center)\n\n            val updateProgress = { event: PointerEvent ->\n                bar.progress = (toLocal(event.location, event.target).x / width).toFloat()\n            }\n\n            pointerChanged += entered {\n                updateProgress(it)\n            }\n\n            pointerMotionChanged += on(\n                moved   = updateProgress,\n                dragged = updateProgress\n            )\n        }\n\n        display.layout = constrain(display.first(), fill)\n\n        display.fill(White.paint)\n    }\n\n    override fun shutdown() {}\n}";var f=o(9656);const b="package controls\n\nimport io.nacular.doodle.controls.range.Slider\nimport io.nacular.measured.units.Length.Companion.meters\nimport io.nacular.measured.units.Length.Companion.miles\nimport io.nacular.measured.units.Time.Companion.hours\nimport io.nacular.measured.units.Time.Companion.seconds\nimport io.nacular.measured.units.div\nimport io.nacular.measured.units.times\n\n//sampleStart\nval velocitySlider = Slider(10 * meters / seconds .. 100 * miles / hours)\n//sampleEnd",x="package controls\n\nimport io.nacular.doodle.controls.ConfinedValueModel\nimport io.nacular.doodle.controls.range.Slider\nimport io.nacular.doodle.utils.Interpolator\n\nfun <T: Comparable<T>> customSlider(model: ConfinedValueModel<T>, interpolator: Interpolator<T>) {\n//sampleStart\n    val slider: Slider<T> = Slider(model, interpolator = interpolator)\n//sampleEnd\n}",j="package controls\n\nimport io.nacular.doodle.controls.ConfinedValueModel\nimport io.nacular.doodle.controls.form.Form\nimport io.nacular.doodle.controls.form.slider\nimport io.nacular.doodle.utils.Interpolator\nimport io.nacular.measured.units.Length.Companion.meters\nimport io.nacular.measured.units.Length.Companion.miles\nimport io.nacular.measured.units.Measure\nimport io.nacular.measured.units.Time.Companion.hours\nimport io.nacular.measured.units.Time.Companion.seconds\nimport io.nacular.measured.units.Velocity\nimport io.nacular.measured.units.div\nimport io.nacular.measured.units.times\n\nfun <T: Comparable<T>> slidersInForm(model: ConfinedValueModel<T>, interpolator: Interpolator<T>) {\n//sampleStart\n    Form {this(\n        + slider('A' .. 'Z'),\n        + slider(10 * meters/seconds .. 10 * miles/hours),\n        + slider(model, interpolator = interpolator),\n        onInvalid = {}\n    ) { _: Char, _: Measure<Velocity>, _: T ->\n\n    }}\n//sampleEnd\n}",k="package controls\n\nimport io.nacular.doodle.controls.range.Slider\n\n//sampleStart\nval charSlider = Slider('A' .. 'Z')\n//sampleEnd";var S=o(2712);const C={hide_title:!0,title:"Whats New \u2728"},A=void 0,T={id:"whatsnew",title:"Whats New \u2728",description:"0.10.2 \u2022 June 2024",source:"@site/docs/whatsnew.mdx",sourceDirName:".",slug:"/whatsnew",permalink:"/doodle/docs/whatsnew",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{hide_title:!0,title:"Whats New \u2728"},sidebar:"tutorialSidebar",previous:{title:"Installation",permalink:"/doodle/docs/installation"},next:{title:"Applications",permalink:"/doodle/docs/applications"}},P={},B=[{value:"0.10.2 \u2022 June 2024",id:"0102--june-2024",level:2},{value:"Animation Chaining",id:"animation-chaining",level:3},{value:"Desktop Accessibility",id:"desktop-accessibility",level:3},{value:"SpinButton Accessibility",id:"spinbutton-accessibility",level:3},{value:"Improved Sliders",id:"improved-sliders",level:3},{value:"0.10.1 \u2022 May 2024",id:"0101--may-2024",level:2},{value:"Sweep Gradient Paint",id:"sweep-gradient-paint",level:3},{value:"0.10.0 \u2022 Feb 2024",id:"0100--feb-2024",level:2},{value:"Host arbitrary HTML elements (Browser)",id:"host-arbitrary-html-elements-browser",level:3},{value:"WASM JS (Browser)",id:"wasm-js-browser",level:3},{value:"Multi-window apps (Desktop)",id:"multi-window-apps-desktop",level:3},{value:"Native window menus (Desktop)",id:"native-window-menus-desktop",level:3},{value:"Native context menus",id:"native-context-menus",level:3},{value:"Key event filters and bubbling (All Platforms)",id:"key-event-filters-and-bubbling-all-platforms",level:3}];function M(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.M)(),...e.components};return c.m||D("api",!1),c.m.AccessibilityModuleDesktop||D("api.AccessibilityModuleDesktop",!0),c.m.BasicCircularProgressIndicatorBehavior||D("api.BasicCircularProgressIndicatorBehavior",!0),c.m.BasicCircularRangeSliderBehavior||D("api.BasicCircularRangeSliderBehavior",!0),c.m.SpinButtonRole||D("api.SpinButtonRole",!0),c.m.SweepGradientPaint||D("api.SweepGradientPaint",!0),c.m.view||D("api.view",!1),c.m.view.keyChanged||D("api.view.keyChanged",!0),c.m.view.keyFilter||D("api.view.keyFilter",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h2,{id:"0102--june-2024",children:[(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle/releases/tag/v0.10.2",children:"0.10.2"})," \u2022 June 2024"]}),"\n",(0,i.jsx)(n.h3,{id:"animation-chaining",children:(0,i.jsx)(n.a,{href:"animations#chaining-animations",children:"Animation Chaining"})}),"\n",(0,i.jsxs)(n.p,{children:["Animations can now be chained within an animation block using the new ",(0,i.jsx)(n.code,{children:"then"}),' method. This makes it easier to have sequential animations and avoids the need to explicitly track secondary animations for cancellation, since these are tied to their "parent" animation.']}),"\n",(0,i.jsx)(l.u,{functionName:"animationChaining",height:"400"}),"\n",(0,i.jsx)(s.A,{children:S.c}),"\n",(0,i.jsx)(n.h3,{id:"desktop-accessibility",children:"Desktop Accessibility"}),"\n",(0,i.jsxs)(n.p,{children:["Doodle's web apps have had accessibility support for some time. Now those capabilities are available for desktop apps as well. You simply include the ",(0,i.jsx)(c.m.AccessibilityModuleDesktop,{})," in your app and follow the ",(0,i.jsx)(n.a,{href:"accessibility",children:"guidelines"})," of how to add roles, labels, etc. to your Views."]}),"\n",(0,i.jsx)(n.h3,{id:"spinbutton-accessibility",children:"SpinButton Accessibility"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"ui_components/overview#spinbutton",children:"SpinButton"}),"s now use the new ",(0,i.jsx)(c.m.SpinButtonRole,{})," that allows assistive tools to better read them. This role exposes the currently selected value based on a new ",(0,i.jsx)(n.code,{children:"valueAccessibilityLabeler"})," function that converts the value to a ",(0,i.jsx)(n.code,{children:"String"}),"."]}),"\n",(0,i.jsxs)(n.h3,{id:"improved-sliders",children:["Improved ",(0,i.jsx)(n.a,{href:"ui_components/overview#slider",children:"Sliders"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arbitrary Types"})}),"\n",(0,i.jsxs)(n.p,{children:["Sliders can now represent values of any ",(0,i.jsx)(n.code,{children:"Comparable"})," type ",(0,i.jsx)(n.code,{children:"T"})," between two ",(0,i.jsx)(n.code,{children:"start"})," and ",(0,i.jsx)(n.code,{children:"end"})," values. This is possible for ",(0,i.jsx)(n.code,{children:"T"}),"s that have some interpolation between a ",(0,i.jsx)(n.code,{children:"start"})," and ",(0,i.jsx)(n.code,{children:"end"})," based on some value between ",(0,i.jsx)(n.code,{children:"0"})," and ",(0,i.jsx)(n.code,{children:"1"}),". This is done via a new ",(0,i.jsx)(n.code,{children:"TypeConverter<T>"})," that defines the interpolation (and its inverse)."]}),"\n",(0,i.jsxs)(n.p,{children:["This means you can now create sliders for numeric types like ",(0,i.jsx)(n.code,{children:"Measure<T>"})," directly and their ",(0,i.jsx)(n.code,{children:"value"})," will by of the right type."]}),"\n",(0,i.jsx)(l.u,{functionName:"velocitySlider",height:"200"}),"\n",(0,i.jsx)(s.A,{children:b}),"\n",(0,i.jsx)(l.u,{functionName:"charSlider",height:"200"}),"\n",(0,i.jsx)(s.A,{children:k}),"\n",(0,i.jsxs)(n.p,{children:["You can also create Sliders for any type ",(0,i.jsx)(n.code,{children:"T"}),", as long as it is ",(0,i.jsx)(n.code,{children:"Comparable"})," and you can create an ",(0,i.jsx)(n.code,{children:"Interpolator"})," for it."]}),"\n",(0,i.jsx)(s.A,{children:x}),"\n",(0,i.jsx)(n.p,{children:"These, more flexible Sliders can also be used in forms as expected."}),"\n",(0,i.jsx)(s.A,{children:j}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"This change applies to range, circular and circular-range sliders as well."})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Non-linearity"})}),"\n",(0,i.jsx)(n.p,{children:"Sliders are linear by default, which means a change in their position translates to a linear change in their value. There are cases however, when it makes sense to have a slider's value change in a non-linear way. You can do this by providing a function that maps values between the slider's input and output spaces. These values are all within the [0-1] domain, and work very similarly to easing functions used for animations. The big difference is they have two forms: f(x) and f^-1(x)."}),"\n",(0,i.jsx)(n.p,{children:"This examples shows two sliders that control the rectangle's opacity. One uses a logarithmic function while the other is the typical linear slider. Notice the difference in how quickly the opacity changes in the beginning when adjusting the logarithmic slider."}),"\n",(0,i.jsxs)(a.c,{children:[(0,i.jsx)(r.c,{value:"Non-linearity",children:(0,i.jsx)(l.u,{functionName:"nonLinearSlider",height:"350"})}),(0,i.jsx)(r.c,{value:"Usage",children:(0,i.jsx)(s.A,{children:f.c})})]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"All slider types support custom functions to make them non-linear."})}),"\n",(0,i.jsxs)(n.h2,{id:"0101--may-2024",children:[(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle/releases/tag/v0.10.1",children:"0.10.1"})," \u2022 May 2024"]}),"\n",(0,i.jsxs)(n.p,{children:["This version is mostly focused on bug fixes, but it also includes a new ",(0,i.jsx)(n.code,{children:"Paint"})," type."]}),"\n",(0,i.jsx)(n.h3,{id:"sweep-gradient-paint",children:"Sweep Gradient Paint"}),"\n",(0,i.jsxs)(n.p,{children:["You can now render content using the new ",(0,i.jsx)(c.m.SweepGradientPaint,{}),". This paint creates a smooth gradient between colors around a center point. It is a great match for radial progress indicators."]}),"\n",(0,i.jsx)(l.u,{functionName:"sweepGradientPaint",height:"300"}),"\n",(0,i.jsx)(s.A,{children:v.c}),"\n",(0,i.jsx)(n.p,{children:"This new paint makes it easy to create gradient controls like this simple progress indicator."}),"\n",(0,i.jsxs)(a.c,{children:[(0,i.jsx)(r.c,{value:"Example",children:(0,i.jsx)(l.u,{functionName:"sweepGradientProgress",height:"300"})}),(0,i.jsx)(r.c,{value:"Code",children:(0,i.jsx)(s.A,{children:y})})]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["You can also use this paint with circular ",(0,i.jsx)(n.a,{href:"/doodle/docs/ui_components/overview#progressbar",children:"ProgressIndicator"})," and ",(0,i.jsx)(n.a,{href:"/doodle/docs/ui_components/overview#circularslider",children:"CircularRangeSlider"})," via ",(0,i.jsx)(c.m.BasicCircularProgressIndicatorBehavior,{})," and ",(0,i.jsx)(c.m.BasicCircularRangeSliderBehavior,{})," respectively."]})}),"\n",(0,i.jsxs)(n.h2,{id:"0100--feb-2024",children:[(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle/releases/tag/v0.10.0",children:"0.10.0"})," \u2022 Feb 2024"]}),"\n",(0,i.jsx)(n.p,{children:"The latest version of Doodle brings lots of important updates, especially in terms of better platform support for both Browser and Desktop. Some of the key highlights include:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"New ability to host embed arbitrary HTML elements as Views on Web"}),"\n",(0,i.jsx)(n.li,{children:"WASM JS support"}),"\n",(0,i.jsx)(n.li,{children:"Multiple windows in Desktop apps"}),"\n",(0,i.jsx)(n.li,{children:"OS menu bars in Desktop"}),"\n",(0,i.jsx)(n.li,{children:"More native context menus in Desktop apps"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"host-arbitrary-html-elements-browser",children:"Host arbitrary HTML elements (Browser)"}),"\n",(0,i.jsx)(n.p,{children:"You can now embed any HTML element into your app as a View. This means Doodle apps can now host React and other web components and interop with a much larger part of the Web ecosystem out of the box!"}),"\n",(0,i.jsx)(d.o,{height:"400"}),"\n",(0,i.jsxs)(a.c,{children:[(0,i.jsx)(r.c,{value:"App",children:(0,i.jsx)(s.A,{children:h.c})}),(0,i.jsx)(r.c,{value:"Example Launcher",children:(0,i.jsx)(s.A,{children:w.c})})]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["This app embeds a ",(0,i.jsx)(n.a,{href:"https://projects.wojtekmaj.pl/react-calendar/",children:"react-calendar"}),"."]})}),"\n",(0,i.jsx)(n.h3,{id:"wasm-js-browser",children:"WASM JS (Browser)"}),"\n",(0,i.jsxs)(n.p,{children:["Doodle now supports the ",(0,i.jsx)(n.a,{href:"/docs/installation",children:"WasmJS"})," build target. This means apps can also target WebAssembly for the Browser. The APIs/features for this new target are identical as those for the ",(0,i.jsx)(n.code,{children:"js"})," target; which means code can be shared between apps targeting both. The only difference is that the ",(0,i.jsx)(n.code,{children:"application"})," launchers need to be called from separate source sets (i.e. ",(0,i.jsx)(n.code,{children:"jsMain"})," vs ",(0,i.jsx)(n.code,{children:"wasmJsMain"}),")."]}),"\n",(0,i.jsx)(n.h3,{id:"multi-window-apps-desktop",children:"Multi-window apps (Desktop)"}),"\n",(0,i.jsxs)(n.p,{children:["Apps for Desktop can now create/manage multiple windows using the new ",(0,i.jsx)(n.code,{children:"WindowGroup"})," interface. Simply inject it into your app to get started. The API provides access to an app's ",(0,i.jsx)(n.code,{children:"main"})," window as well as methods for creating new windows. Single window apps continue to work as they did before. That is, an app that injects the ",(0,i.jsx)(n.code,{children:"Display"})," will receive the ",(0,i.jsx)(n.code,{children:"main"})," window display and can manipulate it as before. But apps that want to manage their window(s) will need to inject this new type."]}),"\n",(0,i.jsx)(s.A,{children:p.c}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["There's no need to inject ",(0,i.jsx)(n.code,{children:"Display"})," if you already inject ",(0,i.jsx)(n.code,{children:"WindowGroup"}),". That's because the injected ",(0,i.jsx)(n.code,{children:"Display"})," is equivalent to ",(0,i.jsx)(n.code,{children:"windowGroup.main.display"})]})}),"\n",(0,i.jsx)(n.h3,{id:"native-window-menus-desktop",children:"Native window menus (Desktop)"}),"\n",(0,i.jsx)(n.p,{children:"Apps can now set up native menus for their windows. This looks a lot like working with the existing menu APIs, but it results in changes to the OS window decoration. These menus are just as interactive as the in-app ones as well, meaning they trigger events when the user interacts with them."}),"\n",(0,i.jsx)(s.A,{children:m.c}),"\n",(0,i.jsx)(n.h3,{id:"native-context-menus",children:"Native context menus"}),"\n",(0,i.jsx)(n.p,{children:"Apps can now set up native context/popup menus for their windows. The API is very similar to native menus."}),"\n",(0,i.jsx)(s.A,{children:u.c}),"\n",(0,i.jsx)(n.h3,{id:"key-event-filters-and-bubbling-all-platforms",children:"Key event filters and bubbling (All Platforms)"}),"\n",(0,i.jsxs)(n.p,{children:['Key events now "sink" and "bubble" like pointer events. This means ancestor Views can intercept (and veto) them before they are delivered to their target (the focused View). They also bubble up to ancestors after being delivered to the target if they are not consumed. The notifications for the first phase happen via a new ',(0,i.jsx)(c.m.view.keyFilter,{})," property, while the bubbling phase is notified via the existing ",(0,i.jsx)(c.m.view.keyChanged,{})," property."]}),"\n",(0,i.jsxs)(n.p,{children:["This change makes it much easier to create Views like the following; which intercepts the ",(0,i.jsx)(n.code,{children:"ENTER"})," key to press the submit button."]}),"\n",(0,i.jsx)(l.u,{functionName:"enterKeyIntercept",height:"300"}),"\n",(0,i.jsx)(s.A,{children:g})]})}function L(e={}){const{wrapper:n}={...(0,t.M)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(M,{...e})}):M(e)}function D(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},2712:(e,n,o)=>{o.d(n,{c:()=>i});const i="package io.nacular.doodle.docs.apps\n\nimport io.nacular.doodle.animation.Animation\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.transition.easeOutBounce\nimport io.nacular.doodle.animation.tween\nimport io.nacular.doodle.animation.tweenDouble\nimport io.nacular.doodle.animation.tweenPoint\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.height\nimport io.nacular.doodle.core.renderProperty\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.core.width\nimport io.nacular.doodle.docs.utils.controlBackgroundColor\nimport io.nacular.doodle.drawing.AffineTransform.Companion.Identity\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.Color.Companion.Lightgray\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.drawing.opacity\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.event.PointerListener.Companion.on\nimport io.nacular.doodle.geometry.Circle\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.geometry.Vector3D\nimport io.nacular.doodle.geometry.circumference\nimport io.nacular.doodle.geometry.inset\nimport io.nacular.doodle.geometry.lineTo\nimport io.nacular.doodle.geometry.path\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.layout.constraints.fill\nimport io.nacular.doodle.utils.autoCanceling\nimport io.nacular.measured.units.Angle.Companion.acos\nimport io.nacular.measured.units.Angle.Companion.degrees\nimport io.nacular.measured.units.Time.Companion.seconds\nimport io.nacular.measured.units.times\nimport kotlin.math.PI\nimport kotlin.math.cos\nimport kotlin.math.sqrt\n\nclass AnimationChainingApp(private val display: Display, private val animate: Animator): Application {\n    private class Wheel: View() {\n        val radius        get() =  circle.radius + thickness / 2\n        val diameter      get() =  2 * radius\n        val circumference get() =  2 * PI * radius\n        var bottom       get() = position + Point(radius, 2 * radius); set(new) {\n            position = new - Point(radius, 2 * radius)\n        }\n        val center        get() = position + Point(radius, radius)\n        var rotation            by renderProperty(0 * degrees)\n\n        private val thickness        =  20.0\n        private val dashLength get() =  circle.circumference / 8\n\n        private val circle    get() = Circle(\n            center = Point(width, height) / 2.0,\n            radius = minOf(width/2, height/2) - thickness / 2\n        )\n\n        override fun contains(point: Point) = false\n\n        override fun render(canvas: Canvas) {\n            val c = circle\n            val d = dashLength\n\n            canvas.circle(c.inset(-thickness / 2 + 0.5), Stroke(Lightgray))\n            canvas.circle(c.inset( thickness / 2      ), Stroke(Lightgray))\n\n            canvas.rotate(around = Point(radius, radius), by = rotation) {\n            circle(\n                c,\n                Stroke(\n                    color     = Color.Blue,\n                    dashes    = doubleArrayOf(d, d),\n                    thickness = thickness,\n                )\n            )}\n        }\n    }\n\n    private var animation: Animation<*>? by autoCanceling()\n\n    private val wheel        = Wheel().apply { size = Size(100) }\n    private var rampBounds   = calculateRampBounds()\n    private val rollBounce   = easeOutBounce(0.15f)\n    private val fallDuration = 1 * seconds\n    private val rollDuration = 3 * seconds\n\n    init {\n        display += view {\n            + wheel\n\n            render = {\n                outerShadow(\n                    color      = Black opacity 0.05f,\n                    vertical   = -10.0,\n                    blurRadius =  10.0\n                ) {\n                    path(\n                        path(0.0, rampBounds.y)\n                            .lineTo(rampBounds.position                )\n                            .lineTo(rampBounds.right, rampBounds.bottom)\n                            .lineTo(0.0,              rampBounds.bottom)\n                            .finish(),\n                        White.paint\n                    )\n                }\n            }\n\n            pointerChanged += on(\n                entered = { startAnimation() },\n                pressed = { startAnimation() }\n            )\n        }\n\n        display.fill(controlBackgroundColor.paint)\n\n        display.layout       = constrain(display.first(), fill)\n        display.sizeChanged += { _,_,_ ->\n            rampBounds = calculateRampBounds()\n            animation?.cancel()\n            resetWheel()\n        }\n    }\n\n    private fun resetWheel() {\n        wheel.bottom   = Point(wheel.radius, 2 * wheel.radius)\n        wheel.rotation  = 0 * degrees\n        wheel.transform = Identity\n    }\n\n    private fun startAnimation() {\n        resetWheel()\n\n        animation = animate {\n            val rampLength              = sqrt(rampBounds.width * rampBounds.width + rampBounds.height * rampBounds.height)\n            val radiusLengthRatio       = wheel.radius / rampLength\n            val bottomYOffsetFromCenter = rampBounds.width  * radiusLengthRatio\n            val bottomXOffsetFromCenter = rampBounds.height * radiusLengthRatio\n            val bottomXOffsetWall       = wheel.radius + bottomXOffsetFromCenter\n            val bottomYOffsetFloor      = bottomXOffsetWall * rampBounds.height / rampBounds.width\n            val tippingPoint            = Identity.rotate(\n                around = Point(wheel.radius, rampBounds.y),\n                by     = acos(rampBounds.width / rampLength)\n            )(Point(wheel.radius, rampBounds.y - wheel.radius))\n\n            val wheelBottomEnd          = Point(\n                rampBounds.right  - bottomXOffsetWall  + bottomXOffsetFromCenter,\n                rampBounds.bottom - bottomYOffsetFloor - bottomYOffsetFromCenter + wheel.radius\n            )\n            val rollLength              = wheelBottomEnd distanceFrom wheel.bottom\n            val rotations               = rollLength / wheel.circumference\n\n//sampleStart\n            wheel.bottom to Point(wheel.radius, rampBounds.y) using (tweenPoint(easeOutBounce, fallDuration)) {\n                // (1) Ball falls and bounces\n                wheel.bottom = it\n            } then {\n                // (2) Then it slides down the hill and bounces off the wall, by animating x and deriving y\n                wheel.bottom.x to rampBounds.width using (tweenDouble(rollBounce, rollDuration)) { x ->\n                    wheel.bottom = Point(x, wheelBottomY(x, tippingPoint))\n                }\n\n                // (2) While rolling at the same time\n                0 * degrees to 360 * degrees * rotations using (tween(degrees, rollBounce, rollDuration)) {\n                    wheel.rotation = it\n                }\n            }\n//sampleEnd\n        }\n    }\n\n    /**\n     * Calculate the ball's bottom position to keep it on the ramp as it moves horizontally.\n     *\n     * The first phase of the move is the portion where the ball is rolling over the edge.\n     * Then it transitions to normal linear motion.\n     */\n    private fun wheelBottomY(centerX: Double, tippingPoint: Vector3D) = when {\n        centerX < tippingPoint.x -> rampBounds.y - wheel.radius * cos((centerX - wheel.radius) / wheel.radius)\n        else                     -> tippingPoint.y + (centerX - tippingPoint.x) * rampBounds.height / rampBounds.width\n    } + wheel.radius\n\n    private fun calculateRampBounds() = Rectangle(\n        x      = wheel.radius,\n        y      = display.height / 2,\n        width  = display.width - wheel.radius,\n        height = display.height / 2\n    )\n\n    override fun shutdown() {\n        animation?.cancel()\n    }\n}"},2456:(e,n,o)=>{o.d(n,{c:()=>i});const i='package io.nacular.doodle.docs.apps\n\nimport io.nacular.doodle.HtmlElementViewFactory\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.controls.text.Label\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.then\nimport io.nacular.doodle.docs.utils.DateRangeSelectionModel\nimport io.nacular.doodle.docs.utils.HorizontalCalendar\nimport io.nacular.doodle.docs.utils.ShadowCard\nimport io.nacular.doodle.drawing.Font\nimport io.nacular.doodle.geometry.PathMetrics\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.theme.Theme\nimport io.nacular.doodle.theme.ThemeManager\nimport kotlinx.datetime.DatePeriod\nimport kotlinx.datetime.LocalDate\nimport kotlinx.datetime.plus\nimport org.w3c.dom.HTMLElement\n\nclass ReactCalendarApp(\n    display        : Display,\n    font           : Font,\n    today          : LocalDate,\n    animate        : Animator,\n    pathMetrics    : PathMetrics,\n    themeManager   : ThemeManager,\n    theme          : Theme,\n    htmlElementView: HtmlElementViewFactory,\n    reactCalendar  : HTMLElement,\n    appHeight      : (Double) -> Unit\n): Application {\n\n    private val doodleCalendar = HorizontalCalendar(\n        today,\n        animate,\n        pathMetrics,\n        startDate = today,\n        endDate   = today + DatePeriod(years = 10),\n        DateRangeSelectionModel()\n    ).apply {\n        this.font = font\n    }\n\n    init {\n        themeManager.selected = theme\n\n//sampleStart\n        display += Label("Doodle").apply { this.font = font }\n        display += ShadowCard(doodleCalendar)\n        display += Label("React").apply { this.font = font }\n        display += htmlElementView(element = reactCalendar)\n//sampleEnd\n\n        val spacing = 20\n\n        display.layout = constrain(\n            display.children[0],\n            display.children[1],\n            display.children[2],\n            display.children[3]\n        ) { doodleLabel, doodle, reactLabel, react ->\n\n            doodle.top          eq doodleLabel.bottom + spacing\n            doodle.height       eq 280\n            react.height        eq doodle.height\n\n            doodleLabel.top     eq spacing\n            doodleLabel.centerX eq doodle.centerX\n            doodleLabel.width.preserve\n            doodleLabel.height.preserve\n\n            reactLabel.centerX  eq react.centerX\n            reactLabel.width.preserve\n            reactLabel.height.preserve\n\n            when {\n                parent.width.readOnly > 800 -> {\n                    doodle.width    eq (parent.width - 3 * spacing) / 2\n                    doodle.right    eq parent.centerX - spacing / 2\n                    react.top       eq doodle.top\n                    react.width     eq doodle.width\n                    react.left      eq doodle.right + spacing\n                    reactLabel.top  eq doodleLabel.top\n                }\n                else -> {\n                    doodle.left     eq spacing\n                    doodle.right    eq parent.right - spacing\n                    react.top       eq reactLabel.bottom + spacing\n                    react.left      eq spacing\n                    react.right     eq parent.right - spacing\n                    reactLabel.top  eq doodle.bottom + spacing\n                }\n            }\n        }.then { container ->\n            // signal to outer docs about height of the app\n            appHeight(container.children.maxOf { it.bounds.bottom } + spacing)\n        }\n    }\n\n    override fun shutdown() {\n        // no-op\n    }\n}'},9656:(e,n,o)=>{o.d(n,{c:()=>i});const i="package controls\n\nimport io.nacular.doodle.controls.range.InvertibleFunction\nimport io.nacular.doodle.controls.range.Slider\nimport kotlin.math.log\nimport kotlin.math.pow\n\n//sampleStart\n/**\n * Logarithmic function and inverse https://www.desmos.com/calculator/qq59ey0bub\n */\nprivate object LogFunction: InvertibleFunction {\n    override fun invoke (value: Float) = log((10f - 1) * value + 1, 10f)\n    override fun inverse(value: Float) = (10f.pow(value) - 1)/(10 - 1)\n}\n\nval logarithmicSlider = Slider(0.0 .. 1.0, function = LogFunction)\n//sampleEnd"},6388:(e,n,o)=>{o.d(n,{c:()=>i});const i="package elementview\n\nimport io.nacular.doodle.HtmlElementViewFactory\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.application.HtmlElementViewModule\nimport io.nacular.doodle.application.Modules\nimport io.nacular.doodle.application.application\nimport io.nacular.doodle.core.Display\nimport org.kodein.di.instance\nimport org.w3c.dom.HTMLElement\n\nprivate class MyApp(\n    display    : Display,\n    viewFactory: HtmlElementViewFactory,\n    element    : HTMLElement\n): Application {\n    init {\n        display += viewFactory(element)\n    }\n\n    override fun shutdown() {}\n}\n\nfun main(element: HTMLElement) {\n//sampleStart\n    application(modules = listOf(Modules.HtmlElementViewModule)) {\n         MyApp(display = instance(), viewFactory = instance(), element = element)\n    }\n//sampleEnd\n}\n"},6068:(e,n,o)=>{o.d(n,{c:()=>i});const i="package rendering\n\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.Color\nimport io.nacular.doodle.drawing.GradientPaint.Stop\nimport io.nacular.doodle.drawing.SweepGradientPaint\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.measured.units.Angle\nimport io.nacular.measured.units.Measure\n\n/**\n * Example showing how to use [SweepGradientPaint]s.\n */\nfun sweepGradientPaint(color1: Color, color2: Color, center: Point, rotation: Measure<Angle>) {\n//sampleStart\n    view {\n        render = {\n            // Simple version with 2 colors\n            rect(bounds.atOrigin, SweepGradientPaint(\n                color1,\n                color2,\n                center,\n                rotation\n            ))\n        }\n    }\n\n    view {\n        render = {\n            // Also able to use a list of color stops\n            rect(\n                bounds.atOrigin, SweepGradientPaint(\n                    listOf(\n                        Stop(color1, 0f),\n                        Stop(color1, 1f / 3),\n                        // ...\n                    ),\n                    center,\n                    rotation\n                )\n            )\n        }\n    }\n//sampleEnd\n}"},7196:(e,n,o)=>{o.d(n,{c:()=>i});const i='package display\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.core.WindowGroup\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.layout.constraints.fill\n\n//sampleStart\nclass MyCoolApp(windows: WindowGroup): Application {\n    init {\n        // main window\'s display, same as if Display were injected\n        windows.main.apply {\n            title = "Main Window"\n\n            // manipulate main window\'s display\n            display += view {}\n        }\n\n        // create a new window\n        windows {\n            title                = "A New Window!"\n            size                 = Size(500)\n            enabled              = false\n            resizable            = false\n            triesToAlwaysBeOnTop = true\n\n            // manipulate the new window\'s display\n            display += view {}\n            display.layout = constrain(display.first(), fill)\n\n            closed += {\n                // handle window close\n            }\n        }\n    }\n\n    override fun shutdown() {}\n}\n//sampleEnd'},7696:(e,n,o)=>{o.d(n,{c:()=>i});const i='package display\n\nimport io.nacular.doodle.controls.popupmenu.MenuBehavior.ItemInfo\nimport io.nacular.doodle.core.Icon\nimport io.nacular.doodle.core.Window\nimport io.nacular.doodle.geometry.Point\n\nfun contextMenu(window: Window, icon1: Icon<ItemInfo>, icon2: Icon<ItemInfo>) {\n//sampleStart\n    window.popupMenu(at = Point()) {\n        action("Do action 2", icon1) { /*..*/ }\n        menu("Sub menu") {\n            action("Do action sub", icon = icon2) { /*..*/ }\n            separator()\n            prompt("Some Prompt sub") { /*..*/ }\n        }\n        separator()\n        prompt("Some Prompt") { /*..*/ }\n    }\n//sampleEnd\n}'},9540:(e,n,o)=>{o.d(n,{c:()=>i});const i='package display\n\nimport io.nacular.doodle.controls.popupmenu.MenuBehavior.ItemInfo\nimport io.nacular.doodle.core.Icon\nimport io.nacular.doodle.core.Window\n\nfun example(window: Window, icon1: Icon<ItemInfo>, icon2: Icon<ItemInfo>) {\n//sampleStart\n    window.menuBar {\n        menu("Menu 1") {\n            action("Do action 2", icon1) { /*..*/ }\n            menu("Sub menu") {\n                action("Do action sub", icon = icon2) { /*..*/ }\n                separator()\n                prompt("Some Prompt sub") { /*..*/ }\n            }\n            separator()\n            prompt("Some Prompt") { /*..*/ }\n        }\n\n        menu("Menu 2") {\n            // ...\n        }\n    }\n//sampleEnd\n}'}}]);