"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[3412],{9288:(e,n,i)=>{i.d(n,{cp:()=>d});var t=i(7624),r=i(2172),s=(i(1268),i(5388),i(5720));function o(e){const n={admonition:"admonition",p:"p",...(0,r.M)(),...e.components};return(0,t.jsxs)(n.admonition,{title:"Module Required",type:"info",children:[(0,t.jsxs)("p",{children:["You must include the ",e.link," in your application in order to use these features."]}),(0,t.jsx)(s.A,{children:e.module}),(0,t.jsx)(n.p,{children:"Doodle uses opt-in modules like this to improve bundle size."})]})}function d(e={}){const{wrapper:n}={...(0,r.M)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},476:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>h,contentTitle:()=>a,default:()=>v,frontMatter:()=>l,metadata:()=>c,toc:()=>p});var t=i(7624),r=i(2172),s=(i(1268),i(5388),i(7996),i(5720)),o=i(3148);i(9288);const d="package pointerinput\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.event.KeyListener.Companion.pressed\nimport io.nacular.doodle.event.PointerListener.Companion.clicked\nimport io.nacular.doodle.event.PointerMotionListener.Companion.moved\n\nfun filter(view: View) {\n//sampleStart\n    view.pointerFilter += clicked { event ->\n        // called whenever a pointer is pressed on this\n        // View or its children, before the target\n        // is notified\n    }\n\n    view.pointerMotionFilter += moved { event ->\n        // called whenever a pointer is pressed on this\n        // View or its children, before the target\n        // is notified\n    }\n\n    view.keyFilter += pressed { event ->\n        // called whenever a key is pressed while this\n        // View or one of its children has focus,\n        // before the target is notified\n    }\n\n//sampleEnd\n}\n",l={title:"Event Sinking | Bubbling",hide_title:!0},a=void 0,c={id:"user_input/eventorder",title:"Event Sinking | Bubbling",description:"Event sinking and filtering",source:"@site/docs/user_input/eventorder.mdx",sourceDirName:"user_input",slug:"/user_input/eventorder",permalink:"/doodle/docs/user_input/eventorder",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Event Sinking | Bubbling",hide_title:!0},sidebar:"tutorialSidebar",previous:{title:"Keyboard",permalink:"/doodle/docs/user_input/keyboard"},next:{title:"Drag \u2022 Drop",permalink:"/doodle/docs/dragdrop"}},h={},p=[{value:"Event sinking and filtering",id:"event-sinking-and-filtering",level:2},{value:"Event bubbling",id:"event-bubbling",level:2},{value:"Pointer events for ancestors",id:"pointer-events-for-ancestors",level:2}];function u(e){const n={admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.M)(),...e.components};return o||f("api",!1),o.EventConsume||f("api.EventConsume",!0),o.EventSource||f("api.EventSource",!0),o.KeyListener||f("api.KeyListener",!0),o.PointerEventTarget||f("api.PointerEventTarget",!0),o.PointerListener||f("api.PointerListener",!0),o.PointerMotionListener||f("api.PointerMotionListener",!0),o.ViewKeyFilter||f("api.ViewKeyFilter",!0),o.ViewPointerFilter||f("api.ViewPointerFilter",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"event-sinking-and-filtering",children:"Event sinking and filtering"}),"\n",(0,t.jsxs)(n.p,{children:['Pointer and Key events "sink" from ancestors down to their target. The "sink" portion is the first phase of event handling; and it runs ',(0,t.jsx)(n.strong,{children:"before"}),' the "bubbling" phase. The root ancestor and all descendants toward the ',(0,t.jsx)(o.PointerEventTarget,{})," ",(0,t.jsx)(n.code,{children:"View"})," are notified of the event before the target is during this phase."]}),"\n",(0,t.jsx)(n.p,{children:'This phase can also be considered the filter phase, because it lets ancestors decide which events their children get to handle, since they can "veto" an event before it reaches the intended target.'}),"\n",(0,t.jsxs)(n.p,{children:["Listeners can take part in this phase of event handling as well. You do this by registering the following types via their respective properties within ",(0,t.jsx)(n.code,{children:"View"}),"."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(o.PointerListener,{})," via ",(0,t.jsx)(o.ViewPointerFilter,{})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(o.PointerMotionListener,{})," via ",(0,t.jsx)(o.ViewPointerFilter,{})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(o.KeyListener,{})," via ",(0,t.jsx)(o.ViewKeyFilter,{})]}),"\n"]}),"\n",(0,t.jsx)(s.A,{children:d}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["Calling ",(0,t.jsx)(o.EventConsume,{})," during filter will prevent descendants (and the target) from receiving the event"]})}),"\n",(0,t.jsx)(n.h2,{id:"event-bubbling",children:"Event bubbling"}),"\n",(0,t.jsxs)(n.p,{children:['Event "bubbling" is the second and final phase of event handling. This phase notifies the target ',(0,t.jsx)(n.code,{children:"View"}),' and then "bubbles" the event up to ancestors of that ',(0,t.jsx)(n.code,{children:"View"})," as long as the event remains unconsumed. This means you can listen to all events that happen to the descendants of a ",(0,t.jsx)(n.code,{children:"View"})," during this phase as well. And similar to the filter phase, you will only receive events that were not consumed before-hand, which in this case means ",(0,t.jsx)(n.strong,{children:"down"})," the hierarchy."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["Bubbling is canceled if any listener calls ",(0,t.jsx)(o.EventConsume,{}),"."]})}),"\n",(0,t.jsx)(n.h2,{id:"pointer-events-for-ancestors",children:"Pointer events for ancestors"}),"\n",(0,t.jsxs)(n.p,{children:["Pointer events sent to an ancestors and descendants are slightly different from those sent to the ",(0,t.jsx)(n.code,{children:"View"}),". These events continue to have the same ",(0,t.jsx)(o.PointerEventTarget,{})," (",(0,t.jsx)(n.code,{children:"View"})," where the event fired), but their ",(0,t.jsx)(o.EventSource,{})," changes to the recipient ancestor as they bubble or sink."]})]})}function v(e={}){const{wrapper:n}={...(0,r.M)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}function f(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);