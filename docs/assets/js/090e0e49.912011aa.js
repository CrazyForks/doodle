"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[956],{564:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>w,contentTitle:()=>f,default:()=>v,frontMatter:()=>m,metadata:()=>p,toc:()=>u});var a=i(7624),t=i(2172),r=(i(1268),i(5388),i(7996)),s=i(5720),o=i(3148);const d="import io.nacular.doodle.drawing.AffineTransform\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.measured.units.Angle.Companion.degrees\nimport io.nacular.measured.units.Angle.Companion.radians\nimport io.nacular.measured.units.times\nimport kotlin.math.PI\n\nfun affineTransformChaining(transform: AffineTransform) {\n//sampleStart\n    transform.\n        rotateY(by = 45 * degrees, around = Point( 2, 4)).\n        rotateX(by = PI * radians, around = Point(10, 3)).\n        //...\n        flipHorizontally()\n//sampleEnd\n}",l="import io.nacular.doodle.core.View\nimport io.nacular.doodle.core.center\nimport io.nacular.doodle.drawing.AffineTransform.Companion.Identity\nimport io.nacular.measured.units.Angle.Companion.degrees\nimport io.nacular.measured.units.times\n\nfun affineTransform(view: View) {\n//sampleStart\n    view.transform = Identity\n    view.transform = Identity.rotateX(around = view.center, by = 45 * degrees)\n//sampleEnd\n}",c="\nimport io.nacular.doodle.core.View\n\nfun View.twoSidedView() {\n//sampleStart\n//  Example of how one might determine whether a View is facing the user.\n//  This takes the cross product of 2 vectors on the View's surface and\n//  applies its transformation and camera.\n\n    val points = (camera.projection * transform).invoke(bounds.points.take(3))\n    val faceUp = (points[1] - points[0] cross points[2] - points[1]).z > 0.0\n//sampleEnd\n}",h="import io.nacular.doodle.core.View\nimport io.nacular.doodle.drawing.AffineTransform.Companion.Identity\n\nfun identityTransform(view: View) {\n//sampleStart\n    // Scale view by 2 in x and y\n    view.transform = Identity.scale(2.0, 2.0)\n\n    // ...\n\n    // Remove all transform effects\n    view.transform = Identity\n//sampleEnd\n}",m={hide_title:!0,title:"Transforms"},f=void 0,p={id:"transforms",title:"Transforms",description:"Transforms",source:"@site/docs/transforms.mdx",sourceDirName:".",slug:"/transforms",permalink:"/doodle/docs/transforms",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{hide_title:!0,title:"Transforms"},sidebar:"tutorialSidebar",previous:{title:"Constraints",permalink:"/doodle/docs/layouts/constraints"},next:{title:"Animation",permalink:"/doodle/docs/animations"}},w={},u=[{value:"Transforms",id:"transforms",level:2},{value:"Affine transforms",id:"affine-transforms",level:2},{value:"Identity transform",id:"identity-transform",level:2},{value:"Cameras",id:"cameras",level:2},{value:"Sharing cameras",id:"sharing-cameras",level:2},{value:"2-sided views",id:"2-sided-views",level:2}];function g(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",strong:"strong",...(0,t.M)(),...e.components};return o||y("api",!1),o.AffineTransform||y("api.AffineTransform",!0),o.Camera||y("api.Camera",!0),o.Identity||y("api.Identity",!0),o.View||y("api.View",!0),o.ViewCamera||y("api.ViewCamera",!0),o.ViewTransform||y("api.ViewTransform",!0),o.ViewVisible||y("api.ViewVisible",!0),o.ViewX||y("api.ViewX",!0),o.ViewY||y("api.ViewY",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"transforms",children:"Transforms"}),"\n",(0,a.jsxs)(n.p,{children:["Each ",(0,a.jsx)(o.View,{})," is a flat, 2D surface bound to a 2D grid. This means Views can only have an ",(0,a.jsx)(o.ViewX,{}),"/",(0,a.jsx)(o.ViewY,{})," position, and an area within the plane. However, Views can also be transformed using ",(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Affine_transformation",children:"Affine Transformations"})," (and perspective) that alter the way they are displayed. These transforms allow you to change a View's position and shape in the full 3D volume."]}),"\n",(0,a.jsx)(r.u,{functionName:"playingCard",height:"500"}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsx)(n.p,{children:"Use the right slider to change the camera distance from the View, which changes the intensity of the perspective used to render it."})}),"\n",(0,a.jsx)(n.h2,{id:"affine-transforms",children:"Affine transforms"}),"\n",(0,a.jsxs)(n.p,{children:["Each View has a ",(0,a.jsx)(o.ViewTransform,{})," that can be set at any time to change how it is rendered. Changes to this property will update the View on screen if it is ",(0,a.jsx)(o.ViewVisible,{}),". Transforms are very lightweight and do not require re-rendering or trigger layouts when modified. This makes them a great option for animations and other UI treatments."]}),"\n",(0,a.jsx)(s.A,{children:l}),"\n",(0,a.jsxs)(n.p,{children:["Multiple ",(0,a.jsx)(o.AffineTransform,{})," instances can also be combined to produce more complex operations. The end result is a single transform that will behave as though each operation were done in succession."]}),"\n",(0,a.jsx)(s.A,{children:d}),"\n",(0,a.jsx)(n.h2,{id:"identity-transform",children:"Identity transform"}),"\n",(0,a.jsxs)(n.p,{children:["Views default to the ",(0,a.jsx)(o.Identity,{})," transform, which does not change the View at all. Set this to effectively clear a View's transform."]}),"\n",(0,a.jsx)(s.A,{children:h}),"\n",(0,a.jsx)(n.h2,{id:"cameras",children:"Cameras"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(o.AffineTransform,{}),"s warp an object while preserving collinearity (points on a line remain on a line) and distance ratios. This means they are insufficient to produce perspective. Perspective requires a transformation that preserves collinearity, but not distance ratios. Doodle supports this via ",(0,a.jsx)(o.Camera,{}),"s. Each Camera has a ",(0,a.jsx)(n.code,{children:"position"})," (relative to a View's parent) and ",(0,a.jsx)(n.code,{children:"distance"}),", which define where vanishing points will be and the intensity their parallel warping effect. Each View has a ",(0,a.jsx)(o.ViewCamera,{})," that will combine with its ",(0,a.jsx)(n.code,{children:"transform"})," to produce a final perspective transformation."]}),"\n",(0,a.jsx)(r.u,{functionName:"camera",height:"500"}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsx)(n.p,{children:"Drag the camera to change its position. Resize it to change its distance from the plane."})}),"\n",(0,a.jsx)(n.h2,{id:"sharing-cameras",children:"Sharing cameras"}),"\n",(0,a.jsx)(n.p,{children:"Views can share a single Camera, which allows them to share the same perspective when they have the same parent (or are all top-level). The result, as you can see below is the effect of the Views sharing the same 3D space."}),"\n",(0,a.jsx)(r.u,{functionName:"camera2",height:"500"}),"\n",(0,a.jsx)(n.admonition,{type:"caution",children:(0,a.jsxs)(n.p,{children:["A View's Camera position is relative to its parent, so shared Cameras only produce the single 3D space for Views with the ",(0,a.jsx)(n.strong,{children:"same parent"}),"."]})}),"\n",(0,a.jsx)(n.h2,{id:"2-sided-views",children:"2-sided views"}),"\n",(0,a.jsxs)(n.p,{children:["Views render onto an infinitely flat plane that is similar to a sheet of glass. This means you see the contents of a View that is flipped or rotated as though you are looking through the back of that pane of glass. You can have Views with 2-sides of course, as you see with the playing cards. But that requires logic to decide when the View's back is visible. The playing card does this by recomputing its face direction whenever its ",(0,a.jsx)(o.ViewTransform,{})," or ",(0,a.jsx)(o.ViewCamera,{})," change, and repainting if needed."]}),"\n",(0,a.jsx)(s.A,{children:c})]})}function v(e={}){const{wrapper:n}={...(0,t.M)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(g,{...e})}):g(e)}function y(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);