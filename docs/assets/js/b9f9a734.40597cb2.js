"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[6e3],{5736:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>p,contentTitle:()=>m,default:()=>v,frontMatter:()=>f,metadata:()=>h,toc:()=>u});var r=a(7624),o=a(2172),t=a(1268),i=a(5388),s=a(7996),d=a(5720),c=a(3148);const l="package io.nacular.doodle.docs.utils\n\nimport io.nacular.doodle.core.Camera\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.renderProperty\nimport io.nacular.doodle.drawing.AffineTransform\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.utils.ChangeObservers\nimport io.nacular.doodle.utils.ChangeObserversImpl\nimport io.nacular.measured.units.Angle\nimport io.nacular.measured.units.times\n\n//sampleStart\nclass Cube: View() {\n    private val side   = 100.0\n    private val rect   = Rectangle(size = Size(side))\n    private val stroke = Stroke(thickness = 2.0, fill = Color.Darkgray.paint)\n\n    var foldAngle       by renderProperty(-90 * Angle.degrees) { _,_ -> (changed as ChangeObserversImpl).invoke() }\n    var canvasCamera    by renderProperty(Camera(Point.Origin, 1000.0)) { _,_ -> (changed as ChangeObserversImpl).invoke() }\n    var canvasTransform by renderProperty(AffineTransform.Identity.translate(z = -side / 2)) { _,_ -> (changed as ChangeObserversImpl).invoke() }\n\n    val changed: ChangeObservers<Cube> = ChangeObserversImpl(this)\n\n    override fun render(canvas: Canvas) {\n        var transform    = canvasTransform\n        var faceLocation = Point((width - side) / 2, (height - side) / 2)\n\n        drawFace(canvas, faceLocation, transform) // Back\n\n        faceLocation += Point(x = side)\n        transform    *= AffineTransform.Identity.rotateY(around = faceLocation, foldAngle)\n\n        drawFace(canvas, faceLocation, transform) // Right\n\n        faceLocation -= Point(y = side)\n\n        drawFace(canvas, faceLocation, transform.rotateX(around = faceLocation + Point(y = side), foldAngle)) // Top\n\n        faceLocation += Point(y = 2 * side)\n        transform    *= AffineTransform.Identity.rotateX(around = faceLocation, -foldAngle)\n\n        drawFace(canvas, faceLocation, transform) // Bottom\n\n        faceLocation += Point(y = side)\n        transform    *= AffineTransform.Identity.rotateX(around = faceLocation, -foldAngle)\n\n        drawFace(canvas, faceLocation, transform) // Left\n\n        faceLocation += Point(x = side)\n        transform    *= AffineTransform.Identity.rotateY(around = faceLocation, foldAngle)\n\n        drawFace(canvas, faceLocation, transform) // Front\n    }\n\n    private fun drawFace(canvas: Canvas, location: Point, transform: AffineTransform) {\n        canvas.transform(transform, canvasCamera) { rect(rect.at(location), stroke) }\n    }\n}\n//sampleEnd",f={title:"3D",hide_title:!0},m=void 0,h={id:"rendering/3d",title:"3D",description:"3D rendering",source:"@site/docs/rendering/3d.mdx",sourceDirName:"rendering",slug:"/rendering/3d",permalink:"/doodle/docs/rendering/3d",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"3D",hide_title:!0},sidebar:"tutorialSidebar",previous:{title:"Colors",permalink:"/doodle/docs/rendering/colors"},next:{title:"Behaviors",permalink:"/doodle/docs/rendering/behaviors"}},p={},u=[{value:"3D rendering",id:"3d-rendering",level:2}];function g(e){const n={a:"a",h2:"h2",p:"p",...(0,o.M)(),...e.components};return c||w("api",!1),c.AffineTransform||w("api.AffineTransform",!0),c.Camera||w("api.Camera",!0),c.View||w("api.View",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"3d-rendering",children:"3D rendering"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"overview#the-canvas",children:"Canvas"})," offers basic 3D capabilities through the use of ",(0,r.jsx)(c.AffineTransform,{}),"s and ",(0,r.jsx)(c.Camera,{}),"s. This enables ",(0,r.jsx)(c.View,{}),"s to display content in a shared 3D space."]}),"\n",(0,r.jsx)(n.p,{children:"The following examples has a View that draws a 3D cube. The cube looks like a 3D object even though it is flat on the View's surface. The controls (which are overlaid on the View) let you change the starting transform applied to the cube's back face (which changes the cube's overall transform), the folding angle of each face, and the camera used to create the perspective."}),"\n",(0,r.jsxs)(t.c,{children:[(0,r.jsx)(i.c,{value:"Demo",children:(0,r.jsx)(s.u,{functionName:"cube",height:"500"})}),(0,r.jsx)(i.c,{value:"Cube.kt",children:(0,r.jsx)(d.A,{children:l})})]})]})}function v(e={}){const{wrapper:n}={...(0,o.M)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(g,{...e})}):g(e)}function w(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);