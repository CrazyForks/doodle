"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[7835],{1775:(e,t,n)=>{n.d(t,{A:()=>i});const i='import io.nacular.doodle.controls.text.Label\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.layout.constraints.fill\n\nfun labelFitText() {\n//sampleStart\n    view {\n        + Label("Hello") // Label fits its text by default\n\n        layout = constrain(children.first(), fill) // \u274c Label would ignore layout\n    }\n//sampleEnd\n}'},7045:(e,t,n)=>{n.d(t,{Z:()=>d});var i=n(6540),o=n(3387),a=n.n(o),s=n(7528),r=n(8596),l=(n(7957),n(4848));class d extends i.Component{constructor(e){super(e),e.args&&(this.args=JSON.parse(e.args)),this.height=e.height,this.functionName="reactComponent",this.ref=i.createRef()}componentDidMount(){let e=this.ref.current.children[1];this.ref.current.removeChild(this.ref.current.children[1]),this.app=a()[this.functionName](this.ref.current.children[0],e)}componentWillUnmount(){this.app}render(){return(0,l.jsxs)("div",{className:s.A.doodle,ref:this.ref,children:[(0,l.jsx)("div",{style:{position:"relative",height:this.height+"px"}}),(0,l.jsx)(r.Ay,{})]})}}},8726:(e,t,n)=>{n.d(t,{A:()=>i});const i='import io.nacular.doodle.controls.text.Label\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.layout.constraints.fill\n\nfun labelFitText() {\n//sampleStart\n    view {\n        + Label("Hello") // Label fits its text by default\n\n        layout = constrain(children.first(), fill) // \u2705 works as expected\n    }\n//sampleEnd\n}'},9375:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>y,contentTitle:()=>g,default:()=>x,frontMatter:()=>m,metadata:()=>i,toc:()=>w});const i=JSON.parse('{"id":"migrating/0.10.x_0.11.0","title":"Migrating to 0.11.0","description":"Upgrade to Kotlin 2.0","source":"@site/docs/migrating/0.10.x_0.11.0.mdx","sourceDirName":"migrating","slug":"/migrating/0.10.x_0.11.0","permalink":"/doodle/docs/migrating/0.10.x_0.11.0","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"hide_title":true,"title":"Migrating to 0.11.0"},"sidebar":"tutorialSidebar","previous":{"title":"Whats New \u2728","permalink":"/doodle/docs/whatsnew"},"next":{"title":"Installation","permalink":"/doodle/docs/installation"}}');var o=n(4848),a=n(8453),s=(n(5537),n(9329),n(7269),n(4069)),r=(n(7045),n(9172));const l="import io.nacular.doodle.core.Layout\nimport io.nacular.doodle.core.PositionableContainer\nimport io.nacular.doodle.geometry.Rectangle\n\n//sampleStart\nclass SimpleLayout: Layout {\n    override fun layout(container: PositionableContainer) {\n        container.children.forEach {\n            it.bounds = Rectangle(0.0, 0.0, container.width, container.height)\n        }\n    }\n}\n//sampleEnd",d="import io.nacular.doodle.core.Layout\nimport io.nacular.doodle.core.Positionable\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.layout.Insets\n\n//sampleStart\nclass SimpleLayout: Layout {\n    override fun layout(views: Sequence<Positionable>, min: Size, current: Size, max: Size, insets: Insets): Size {\n        views.forEach {\n            it.updateBounds(Rectangle(0.0, 0.0, current.width, current.height))\n        }\n\n        return current\n    }\n}\n//sampleEnd";var c=n(1775),u=n(8726);const h="\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.geometry.Size\n\nfun invalidSize() {\n//sampleStart\nval view1 = view {}.apply { size = Size(10, 50) }\nval view2 = view {}.apply { size = view1.size   } // view2.size == Size(10, 50)\n//sampleEnd\n}",p="\nimport io.nacular.doodle.core.view\n\nfun invalidSize() {\n//sampleStart\nval view1 = view {}.apply { suggestSize(10.0, 50.0) }\nval view2 = view {}.apply { suggestSize(view1.size) } // view2.size == Size.Empty since suggestion usually async\n//sampleEnd\n}",m={hide_title:!0,title:"Migrating to 0.11.0"},g="Migrating to 0.11.0",y={},w=[{value:"Upgrade to Kotlin 2.0",id:"upgrade-to-kotlin-20",level:2},{value:"Adjust to the new layout paradigm",id:"adjust-to-the-new-layout-paradigm",level:2},{value:"Update custom Layouts",id:"update-custom-layouts",level:2}];function v(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",...(0,a.R)(),...e.components};return r.F||f("api",!1),r.F.Layout||f("api.Layout",!0),r.F.View||f("api.View",!0),r.F.view||f("api.view",!1),r.F.view.bounds||f("api.view.bounds",!0),r.F.view.suggestBounds||f("api.view.suggestBounds",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"migrating-to-0110",children:"Migrating to 0.11.0"})}),"\n",(0,o.jsx)(t.h2,{id:"upgrade-to-kotlin-20",children:"Upgrade to Kotlin 2.0"}),"\n",(0,o.jsxs)(t.p,{children:["Doodle now requires Kotlin 2.0. So you'll need to update your app to use the newer version of Kotlin. See ",(0,o.jsx)(t.a,{href:"/docs/installation",children:"installation"})," for instructions."]}),"\n",(0,o.jsx)(t.h2,{id:"adjust-to-the-new-layout-paradigm",children:"Adjust to the new layout paradigm"}),"\n",(0,o.jsxs)(t.p,{children:["A ",(0,o.jsx)(r.F.View,{}),"'s bounds is no longer editable directly as it was in previous versions of Doodle. This is a major change to the way Doodle layout functions; but it is important to avoid some major pitfalls of the previous approach. Namely, it was very easy to write code that would not produce the expected layout. This is a good example of something that would cause issues before:"]}),"\n",(0,o.jsx)(t.admonition,{title:"0.10.x",type:"note",children:(0,o.jsx)(s.v,{children:c.A})}),"\n",(0,o.jsxs)(t.p,{children:["Now it just works as expected since ",(0,o.jsx)(r.F.View,{}),"s cannot override the ",(0,o.jsx)(r.F.Layout,{})," they are managed by."]}),"\n",(0,o.jsx)(t.admonition,{title:"0.11.0",type:"tip",children:(0,o.jsx)(s.v,{children:u.A})}),"\n",(0,o.jsxs)(t.p,{children:["More specifically, a ",(0,o.jsx)(r.F.View,{})," is given a ",(0,o.jsx)(t.code,{children:"min"})," and ",(0,o.jsx)(t.code,{children:"max"})," size it can take by its parent's ",(0,o.jsx)(r.F.Layout,{}),". It then picks a size it would like to take in that range and reports back to the ",(0,o.jsx)(r.F.Layout,{}),", which uses that information to position/size it and the other Views it manages."]}),"\n",(0,o.jsxs)(t.p,{children:["This means you cannot directly change a ",(0,o.jsx)(r.F.View,{}),"'s ",(0,o.jsx)(r.F.view.bounds,{})," like before; and can only suggest changes (see ",(0,o.jsx)(r.F.view.suggestBounds,{})," etc.) that the ",(0,o.jsx)(r.F.View,{})," may use to determine its final size. Therefore, code like the following no longer works, and cannot be directly converted to this new bounds-suggestion system; since bounds suggestions are not guaranteed in the way a normal setter would be."]}),"\n",(0,o.jsx)(t.admonition,{title:"0.10.x",type:"note",children:(0,o.jsx)(s.v,{children:h})}),"\n",(0,o.jsx)(t.admonition,{title:"0.11.0",type:"tip",children:(0,o.jsx)(s.v,{children:p})}),"\n",(0,o.jsx)(t.h2,{id:"update-custom-layouts",children:"Update custom Layouts"}),"\n",(0,o.jsxs)(t.p,{children:["Your custom ",(0,o.jsx)(r.F.Layout,{}),"s will need to change because the APIs have evolved in the latest version. ",(0,o.jsx)(r.F.Layout,{}),"s are no longer aware of the View they are laying out. Instead, they now work with a sequence of Views directly and have all other necessary context provided in the call to ",(0,o.jsx)(t.code,{children:"layout"}),"."]}),"\n",(0,o.jsx)(t.admonition,{title:"0.10.x",type:"note",children:(0,o.jsx)(s.v,{children:l})}),"\n",(0,o.jsx)(t.admonition,{title:"0.11.0",type:"tip",children:(0,o.jsx)(s.v,{children:d})})]})}function x(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(v,{...e})}):v(e)}function f(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);