"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[8062],{340:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>V,contentTitle:()=>M,default:()=>K,frontMatter:()=>C,metadata:()=>t,toc:()=>E});const t=JSON.parse('{"id":"userinput","title":"User Input","description":"Pointer handling is easy with Doodle; simply include the PointerModule when launching your app, and the underlying framework uses it to produce key events.","source":"@site/docs/userinput.mdx","sourceDirName":".","slug":"/userinput","permalink":"/doodle/docs/userinput","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"User Input","hide_title":true},"sidebar":"tutorialSidebar","previous":{"title":"Layout","permalink":"/doodle/docs/layout"},"next":{"title":"Transforms","permalink":"/doodle/docs/transforms"}}');var o=i(4848),r=i(8453),s=i(5537),a=i(9329),d=i(7269),l=i(4069),c=i(9172),p=i(3729);const h="package pointerinput\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.application.Modules.Companion.PointerModule\nimport io.nacular.doodle.application.application\nimport io.nacular.doodle.core.Display\nimport org.kodein.di.instance\nimport rendering.MyApp\n\n//sampleStart\nfun main() {\n    /** Include [PointerModule] when launching your app */\n    application(modules = listOf(PointerModule)) {\n        MyApp(instance())\n    }\n}\n\n/**\n * Pointer events will fire for this app when launched with [PointerModule]\n */\nclass MyApp(display: Display): Application {\n    override fun shutdown() {}\n}\n//sampleEnd",u="package pointerinput\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.event.PointerListener.Companion.pressed\n\nfun consume(view: View) {\n//sampleStart\n    view.pointerChanged += pressed { event ->\n        // ... take action based on event\n\n        event.consume() // indicate that no other listeners should be notified\n    }\n//sampleEnd\n}\n",v="package io.nacular.doodle.docs.utils\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.renderProperty\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color.Companion.Red\nimport io.nacular.doodle.drawing.circle\nimport io.nacular.doodle.drawing.opacity\nimport io.nacular.doodle.event.PointerListener\nimport io.nacular.doodle.geometry.Circle\nimport io.nacular.doodle.geometry.Point\n\n//sampleStart\n/**\n * This view renders a circle and provides precise hit detection for it.\n */\nclass CircularView(radius: Double): View() {\n    private val circle      = Circle(Point(radius, radius), radius)\n    private var pointerOver by renderProperty(false)\n\n    init {\n        suggestSize(circle.boundingRectangle.size)\n\n        pointerChanged += PointerListener.on(\n            entered = { pointerOver = true  },\n            exited  = { pointerOver = false }\n        )\n    }\n\n    override fun intersects(point: Point) = point - position in circle\n\n    override fun render(canvas: Canvas) {\n        canvas.circle(circle, color = if (pointerOver) Red opacity 0.5f else Red)\n    }\n}\n//sampleEnd",m="package io.nacular.doodle.docs.utils\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.renderProperty\nimport io.nacular.doodle.drawing.AffineTransform.Companion.Identity\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.event.PointerListener.Companion.on\nimport io.nacular.doodle.geometry.ConvexPolygon\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.reversed\nimport io.nacular.doodle.geometry.toPath\n\n//sampleStart\n/**\n * This view renders a triangular shape and provides precise hit detection for it.\n */\nclass TriangleView: View() {\n    private val outerPoly get() = ConvexPolygon(Point(width / 2), Point(width, height), Point(0, height))\n    private val innerPoly get() = Identity.scale(\n        around = Point(width / 2, height * 2 / 3),\n        x      = 0.5,\n        y      = 0.5\n    ).invoke(outerPoly.reversed())\n\n    private var pointerOver by renderProperty(false)\n\n    init {\n        pointerChanged += on(\n            entered = { pointerOver = true  },\n            exited  = { pointerOver = false }\n        )\n    }\n\n    /**\n     * Override [intersects] this instead of [contains] to get [point]\n     * that is mapped to this view's plane, where intersection logic is\n     * much simpler.\n     */\n    override fun intersects(point: Point) = (point - position).let {\n        it in outerPoly && it !in innerPoly\n    }\n\n    override fun render(canvas: Canvas) {\n        canvas.path(\n            path = outerPoly.toPath() + innerPoly.toPath(),\n            fill = if (pointerOver) Black.paint else White.paint\n        )\n    }\n}\n//sampleEnd",y="package pointerinput\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.event.PointerEvent\nimport io.nacular.doodle.event.PointerListener\nimport io.nacular.doodle.event.PointerListener.Companion.on\nimport io.nacular.doodle.event.PointerListener.Companion.pressed\n\nfun example(view: View) {\n//sampleStart\n    // Listen to pressed/exit via interface override\n    view.pointerChanged += object: PointerListener {\n        override fun pressed(event: PointerEvent) {\n            // ..\n        }\n\n        override fun exited(event: PointerEvent) {\n            // ..\n        }\n    }\n\n    // Listener to pressed via DSL\n    view.pointerChanged += pressed { event -> /* .. */ }\n\n    // Listen to pressed/exit via DSL\n    view.pointerChanged += on(\n        pressed = { event -> /* .. */ },\n        exited  = { event -> /* .. */ },\n    )\n//sampleEnd\n}",w="package pointerinput\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.event.PointerEvent\nimport io.nacular.doodle.event.PointerMotionListener\nimport io.nacular.doodle.event.PointerMotionListener.Companion.moved\nimport io.nacular.doodle.event.PointerMotionListener.Companion.on\n\nfun pointerMotion(view: View) {\n//sampleStart\n    // Listen to moved/dragged via interface override\n    view.pointerMotionChanged += object: PointerMotionListener {\n        override fun moved(event: PointerEvent) {\n            // ..\n        }\n\n        override fun dragged(event: PointerEvent) {\n            // ..\n        }\n    }\n\n    // Listener to moved via DSL\n    view.pointerMotionChanged += moved { event -> /* .. */ }\n\n    // Listen to moved/dragged via DSL\n    view.pointerMotionChanged += on(\n        moved   = { event -> /* .. */ },\n        dragged = { event -> /* .. */ },\n    )\n//sampleEnd\n}",x="package pointerinput\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.event.PointerMotionListener.Companion.moved\n\nfun multiTouch(view: View) {\n//sampleStart\n    view.pointerMotionChanged += moved { event ->\n        event.targetInteractions  // the set of interactions with the target View\n        event.changedInteractions // the interactions that changed (triggered) this event\n        event.allInteractions     // all active interactions for the app\n    }\n//sampleEnd\n}\n",g="package keyboard\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.application.Modules.Companion.KeyboardModule\nimport io.nacular.doodle.application.application\nimport io.nacular.doodle.core.Display\nimport org.kodein.di.instance\nimport rendering.MyApp\n\n//sampleStart\nfun main() {\n    /** Include [KeyboardModule] when launching your app */\n    application(modules = listOf(KeyboardModule)) {\n        MyApp(instance())\n    }\n}\n\n/**\n * Key events will fire for this app when launched with [KeyboardModule]\n */\nclass MyApp(display: Display): Application {\n    override fun shutdown() {}\n}\n//sampleEnd",f="package focus\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.application.Modules.Companion.KeyboardModule\nimport io.nacular.doodle.application.application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.focus.FocusManager\nimport org.kodein.di.instance\n\n//sampleStart\nfun main() {\n    application(modules = listOf(KeyboardModule)) {\n        // FocusManager is available in the KeyboardModule\n        MyApp(display = instance(), focusManager = instance())\n    }\n}\n\nclass MyApp(display: Display, focusManager: FocusManager): Application {\n    init {\n        val view = view {}\n\n        display += view\n\n        // ...\n\n        focusManager.requestFocus(view)\n\n        // ...\n    }\n\n    override fun shutdown() {}\n}\n//sampleEnd",j="package keyboard\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.event.KeyEvent\nimport io.nacular.doodle.event.KeyListener\nimport io.nacular.doodle.event.KeyListener.Companion.on\nimport io.nacular.doodle.event.KeyListener.Companion.pressed\n\nfun example(view: View) {\n//sampleStart\n    // Listen to pressed/released via interface override\n    view.keyChanged += object: KeyListener {\n        override fun pressed(event: KeyEvent) {\n            // ..\n        }\n\n        override fun released(event: KeyEvent) {\n            // ..\n        }\n    }\n\n    // Listener to pressed via DSL\n    view.keyChanged += pressed { event -> /* .. */ }\n\n    // Listen to pressed/released via DSL\n    view.keyChanged += on(\n        pressed  = { event -> /* .. */ },\n        released = { event -> /* .. */ },\n    )\n//sampleEnd\n}",b="package keyboard\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.event.KeyListener.Companion.pressed\n\nfun consume(view: View) {\n//sampleStart\n    view.keyChanged += pressed { event ->\n        // ... take action based on event\n\n        event.consume() // indicate that no other listeners should be notified\n    }\n//sampleEnd\n}\n",k='package keyboard\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.event.KeyListener.Companion.pressed\nimport io.nacular.doodle.event.KeyText.Companion.Backspace\nimport io.nacular.doodle.event.KeyText.Companion.Enter\n\nfun virtualKeys(view: View) {\n//sampleStart\n    view.keyChanged += pressed { event ->\n        when (event.key) {\n            Enter     -> { /* ... */ }\n            Backspace -> { /* ... */ }\n            // ...\n        }\n    }\n\n    view.keyChanged += pressed { event ->\n        // this will be user-appropriate text when the key pressed is not\n        // one of the "named" keys (i.e. Tab, Shift, Enter, ...)\n        event.key.text\n    }\n//sampleEnd\n}\n',P="package keyboard\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.event.KeyCode.Companion.AltLeft\nimport io.nacular.doodle.event.KeyCode.Companion.AltRight\nimport io.nacular.doodle.event.KeyCode.Companion.Backspace\nimport io.nacular.doodle.event.KeyListener.Companion.pressed\n\nfun physicalKeys(view: View) {\n//sampleStart\n    view.keyChanged += pressed { event ->\n        when (event.code) {\n            AltLeft   -> { /* ... */ }\n            AltRight  -> { /* ... */ }\n            Backspace -> { /* ... */ }\n            // ...\n        }\n    }\n//sampleEnd\n}\n",F="package pointerinput\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.event.KeyListener.Companion.pressed\nimport io.nacular.doodle.event.PointerListener.Companion.clicked\nimport io.nacular.doodle.event.PointerMotionListener.Companion.moved\n\nfun filter(view: View) {\n//sampleStart\n    view.pointerFilter += clicked { event ->\n        // called whenever a pointer is pressed on this\n        // View or its children, before the target\n        // is notified\n    }\n\n    view.pointerMotionFilter += moved { event ->\n        // called whenever a pointer is pressed on this\n        // View or its children, before the target\n        // is notified\n    }\n\n    view.keyFilter += pressed { event ->\n        // called whenever a key is pressed while this\n        // View or one of its children has focus,\n        // before the target is notified\n    }\n\n//sampleEnd\n}\n",C={title:"User Input",hide_title:!0},M="User input",V={},E=[...p.RM,{value:"Pointer input",id:"pointer-input",level:2},{value:"Hit detection",id:"hit-detection",level:3},{value:"Support for transforms",id:"support-for-transforms",level:3},{value:"Pointer listeners",id:"pointer-listeners",level:3},{value:"Pointer events",id:"pointer-events",level:3},{value:"Pointer motion events",id:"pointer-motion-events",level:3},{value:"Multi-touch",id:"multi-touch",level:3},{value:"Keyboard input",id:"keyboard-input",level:2},...p.RM,{value:"Key Listeners",id:"key-listeners",level:3},{value:"Key events",id:"key-events",level:3},{value:"Virtual keys and text",id:"virtual-keys-and-text",level:3},{value:"Physical keys",id:"physical-keys",level:3},{value:"Event sinking and filtering",id:"event-sinking-and-filtering",level:2},{value:"Event bubbling",id:"event-bubbling",level:2},{value:"Pointer events for ancestors",id:"pointer-events-for-ancestors",level:2}];function L(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return c.F||T("api",!1),c.F.EventConsume||T("api.EventConsume",!0),c.F.EventSource||T("api.EventSource",!0),c.F.FocusManager||T("api.FocusManager",!0),c.F.Interaction||T("api.Interaction",!0),c.F.KeyEventCode||T("api.KeyEventCode",!0),c.F.KeyEventKey||T("api.KeyEventKey",!0),c.F.KeyListener||T("api.KeyListener",!0),c.F.KeyboardModule||T("api.KeyboardModule",!0),c.F.PointerEvent||T("api.PointerEvent",!0),c.F.PointerEventTarget||T("api.PointerEventTarget",!0),c.F.PointerListener||T("api.PointerListener",!0),c.F.PointerModule||T("api.PointerModule",!0),c.F.PointerMotionListener||T("api.PointerMotionListener",!0),c.F.view||T("api.view",!1),c.F.view.bounds||T("api.view.bounds",!0),c.F.view.containsPoint||T("api.view.containsPoint",!0),c.F.view.enabled||T("api.view.enabled",!0),c.F.view.intersects||T("api.view.intersects",!0),c.F.view.keyChanged||T("api.view.keyChanged",!0),c.F.view.keyFilter||T("api.view.keyFilter",!0),c.F.view.pointerChanged||T("api.view.pointerChanged",!0),c.F.view.pointerFilter||T("api.view.pointerFilter",!0),c.F.view.pointerMotionChanged||T("api.view.pointerMotionChanged",!0),c.F.view.pointerMotionFilter||T("api.view.pointerMotionFilter",!0),c.F.view.toLocal||T("api.view.toLocal",!0),c.F.view.transform||T("api.view.transform",!0),c.F.view.visible||T("api.view.visible",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"user-input",children:"User input"})}),"\n",(0,o.jsxs)(n.p,{children:["Pointer handling is easy with Doodle; simply include the ",(0,o.jsx)(n.code,{children:"PointerModule"})," when launching your app, and the underlying framework uses it to produce key events."]}),"\n",(0,o.jsx)(p.Ay,{link:(0,o.jsx)(c.F.PointerModule,{}),module:h}),"\n",(0,o.jsx)(n.h2,{id:"pointer-input",children:"Pointer input"}),"\n",(0,o.jsx)(n.h3,{id:"hit-detection",children:"Hit detection"}),"\n",(0,o.jsxs)(n.p,{children:["The framework relies on the ",(0,o.jsx)(n.code,{children:"View"})," ",(0,o.jsx)(c.F.view.containsPoint,{})," method to determine when the pointer is within a ",(0,o.jsx)(n.code,{children:"View"}),"'s boundaries. This method gets a point in the ",(0,o.jsx)(n.strong,{children:"view's parent reference frame"})," (or the ",(0,o.jsx)(n.a,{href:"/doodle/docs/display",children:(0,o.jsx)(n.strong,{children:"Display"})}),"'s for top-level Views)) and returns whether or not that point intersects the view. The default implementation just checks the point against ",(0,o.jsx)(c.F.view.bounds,{})," and accounts for the view's ",(0,o.jsx)(c.F.view.transform,{}),"."]}),"\n",(0,o.jsxs)(s.A,{children:[(0,o.jsx)(a.A,{value:"Demo",children:(0,o.jsx)(d.T,{functionName:"hitDetection",height:"250"})}),(0,o.jsx)(a.A,{value:"Code",children:(0,o.jsx)(l.v,{children:v})})]}),"\n",(0,o.jsx)(n.h3,{id:"support-for-transforms",children:"Support for transforms"}),"\n",(0,o.jsxs)(n.p,{children:["Doodle also accounts for transformations applied to the ",(0,o.jsx)(n.code,{children:"View"}),"'s ancestors when delivering pointer events. This means the ",(0,o.jsx)(n.code,{children:"View"})," will receive the right notification whenever the pointer intersects its parent despite transformations. Hit detection logic in the ",(0,o.jsx)(n.code,{children:"View"})," is then triggered as usual. The ",(0,o.jsx)(n.code,{children:"View"})," still needs to take its own transformation into account though, since the given point used in hit detection is within the parent coordinate space. This is automatically handled if the ",(0,o.jsx)(n.code,{children:"View"})," implements ",(0,o.jsx)(c.F.view.intersects,{})," or if ",(0,o.jsx)(c.F.view.toLocal,{})," is used when overriding ",(0,o.jsx)(c.F.view.containsPoint,{}),"."]}),"\n",(0,o.jsxs)(s.A,{children:[(0,o.jsx)(a.A,{value:"Demo",children:(0,o.jsx)(d.T,{functionName:"hitDetectionTransform",height:"500"})}),(0,o.jsx)(a.A,{value:"Code",children:(0,o.jsx)(l.v,{children:m})})]}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.p,{children:["Override ",(0,o.jsx)(c.F.view.intersects,{})," instead of ",(0,o.jsx)(c.F.view.containsPoint,{})," unless you want to factor in the view's transform into your hit detection logic."]})}),"\n",(0,o.jsx)(n.h3,{id:"pointer-listeners",children:"Pointer listeners"}),"\n",(0,o.jsxs)(n.p,{children:["Views are able to receive pointer events once the ",(0,o.jsx)(c.F.PointerModule,{})," is loaded, they are ",(0,o.jsx)(c.F.view.visible,{})," and ",(0,o.jsx)(c.F.view.enabled,{}),". You can then attach a ",(0,o.jsx)(c.F.PointerListener,{})," to any ",(0,o.jsx)(n.code,{children:"View"}),"'s ",(0,o.jsx)(c.F.view.pointerChanged,{})," property and get notified whenever a pointer does one of the following:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Enters"})," the View"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Pressed"})," within the View"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Released"})," within the View"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Clicked"})," (Pressed then Released) within the View"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Exits"})," the View"]}),"\n"]}),"\n",(0,o.jsx)(l.v,{children:y}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)(c.F.PointerListener,{})," has no-op defaults for each event, so you only need to implement the ones you need."]})}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["Notice that ",(0,o.jsx)(c.F.view.pointerChanged,{}),"--like other observable properties--supports many observers and enables you to add/remove an observer any time."]})}),"\n",(0,o.jsx)(n.h3,{id:"pointer-events",children:"Pointer events"}),"\n",(0,o.jsxs)(n.p,{children:["The event provided to ",(0,o.jsx)(c.F.PointerListener,{}),"s carries information about the ",(0,o.jsx)(n.code,{children:"View"})," it originated from (",(0,o.jsx)(c.F.PointerEventTarget,{}),"), the ",(0,o.jsx)(n.code,{children:"View"})," it is sent to (",(0,o.jsx)(c.F.EventSource,{}),"), various attributes about the state of the pointers--like buttons pressed--and their locations relative to the target ",(0,o.jsx)(n.code,{children:"View"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Pointer events are ",(0,o.jsx)(n.strong,{children:"consumable"}),". This means any observer can call ",(0,o.jsx)(c.F.EventConsume,{})," on an event and prevent subsequent listeners from receiving it."]}),"\n",(0,o.jsx)(l.v,{children:u}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["Calling ",(0,o.jsx)(c.F.EventConsume,{})," during filter will prevent descendants (and the target) from receiving the event"]})}),"\n",(0,o.jsx)(n.h3,{id:"pointer-motion-events",children:"Pointer motion events"}),"\n",(0,o.jsxs)(n.p,{children:["Pointer motion events occur whenever a pointer moves within a View. They are treated separately from ",(0,o.jsx)(n.a,{href:"userinput#pointer-events",children:(0,o.jsx)(n.strong,{children:"pointer events"})})," because of their high frequency. The ",(0,o.jsx)(n.a,{href:"userinput#pointer-events",children:"PointerModule"})," is also required to enable them. And ",(0,o.jsx)(n.a,{href:"userinput#hit-detection",children:(0,o.jsx)(n.strong,{children:"hit detection"})})," follows the same rules as with pointer events."]}),"\n",(0,o.jsxs)(n.p,{children:["Registration is different though. You use listen to ",(0,o.jsx)(c.F.view.pointerMotionChanged,{})," and implement ",(0,o.jsx)(c.F.PointerMotionListener,{}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Pointer motion listeners are notified whenever a pointer:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Moves"})," within a View"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Drags"})," anywhere while pressed, if the press started in a View"]}),"\n"]}),"\n",(0,o.jsx)(l.v,{children:w}),"\n",(0,o.jsx)(n.h3,{id:"multi-touch",children:"Multi-touch"}),"\n",(0,o.jsxs)(n.p,{children:["Pointer events support multiple, simultaneous inputs by default. This covers the multi-touch use-case on mobile and other similar scenarios. The ",(0,o.jsx)(c.F.PointerEvent,{})," class contains information about all active ",(0,o.jsx)(c.F.Interaction,{}),"s for the current event. This includes those directed at the event target. Apps are therefore able to incorporate this into their pointer handling."]}),"\n",(0,o.jsx)(l.v,{children:x}),"\n",(0,o.jsx)(n.p,{children:"Doodle also does not limit simultaneous interactions to a single View. All active interactions will be sent to the appropriate Views and managed concurrently. This means it is possible to drag multiple items at the same time."}),"\n",(0,o.jsx)(d.T,{functionName:"positioning",args:"[2]",height:"400"}),"\n",(0,o.jsxs)(n.admonition,{type:"tip",children:[(0,o.jsx)(n.p,{children:"Try moving both boxes at the same time if you are on a mobile device or have multiple pointers."}),(0,o.jsxs)(n.admonition,{type:"tip",children:[(0,o.jsx)(n.h2,{id:"keyboard-input",children:"Keyboard input"}),(0,o.jsxs)(n.p,{children:["Key handling is simple with Doodle; simply include the ",(0,o.jsx)(n.code,{children:"KeyboardModule"})," when launching your app, and the underlying framework uses it to produce key events."]}),(0,o.jsx)(p.Ay,{link:(0,o.jsx)(c.F.KeyboardModule,{}),module:g}),(0,o.jsx)(n.p,{children:"A View must gain focus in order to begin receiving key events. This ensures that only a single View can receive key events at any time within the app."}),(0,o.jsxs)(n.p,{children:["Use the ",(0,o.jsx)(c.F.FocusManager,{})," to control focus. It is included in the ",(0,o.jsx)(n.code,{children:"KeyboardModule"}),". Just inject it into your app to begin managing the focus."]}),(0,o.jsx)(l.v,{children:f}),(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.p,{children:["Some controls (i.e. ",(0,o.jsx)(n.a,{href:"ui_components/overview#textfield",children:"TextField"}),") also manage their focus when styled in the native theme"]})})]})]}),"\n",(0,o.jsx)(n.h3,{id:"key-listeners",children:"Key Listeners"}),"\n",(0,o.jsxs)(n.p,{children:["Views are able to receive key events once the ",(0,o.jsx)(c.F.KeyboardModule,{})," is loaded and they have ",(0,o.jsx)(n.code,{children:"focus"}),". You can then attach a ",(0,o.jsx)(c.F.KeyListener,{})," to any View and get notified whenever it has focus and a key is ",(0,o.jsx)(n.strong,{children:"Pressed"})," or ",(0,o.jsx)(n.strong,{children:"Released"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["You get these notifications by registering with a View's ",(0,o.jsx)(c.F.view.keyChanged,{})," property."]}),"\n",(0,o.jsx)(l.v,{children:j}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)(c.F.KeyListener,{})," has no-op defaults for the 2 events, so you only need to implement the ones you need."]})}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["Notice that ",(0,o.jsx)(c.F.view.keyChanged,{}),"--like other observable properties--supports many observers and enables you to add/remove\nan observer any time."]})}),"\n",(0,o.jsx)(n.h3,{id:"key-events",children:"Key events"}),"\n",(0,o.jsxs)(n.p,{children:["The event provided to key listeners carries information about the View it originated from (",(0,o.jsx)(c.F.EventSource,{}),"), and various attributes about the key that was pressed or released."]}),"\n",(0,o.jsxs)(n.p,{children:["Key events are ",(0,o.jsx)(n.strong,{children:"consumable"}),". This means any observer can call ",(0,o.jsx)(c.F.EventConsume,{})," on the event and prevent subsequent listeners from receiving it."]}),"\n",(0,o.jsx)(l.v,{children:b}),"\n",(0,o.jsx)(n.h3,{id:"virtual-keys-and-text",children:"Virtual keys and text"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"KeyEvent"}),"'s ",(0,o.jsx)(c.F.KeyEventKey,{}),' is a layout independent identifier that tells you which "virtual key" was pressed or which text the key can be translated into. Most key handling use-cases should use this property to compare keys.']}),"\n",(0,o.jsx)(l.v,{children:k}),"\n",(0,o.jsx)(n.h3,{id:"physical-keys",children:"Physical keys"}),"\n",(0,o.jsx)(n.p,{children:'Some applications will require the use of "physical" keys instead of virtual ones. This makes sense for games or other apps where the key position on a physical keyboard matters.'}),"\n",(0,o.jsxs)(n.p,{children:["This information comes from ",(0,o.jsx)(n.code,{children:"KeyEvent"}),"'s ",(0,o.jsx)(c.F.KeyEventCode,{}),"."]}),"\n",(0,o.jsx)(l.v,{children:P}),"\n",(0,o.jsx)(n.admonition,{type:"caution",children:(0,o.jsx)(n.p,{children:"Physical keys do not take keyboard differences and locale into account; so avoid them if possible"})}),"\n",(0,o.jsx)(n.h2,{id:"event-sinking-and-filtering",children:"Event sinking and filtering"}),"\n",(0,o.jsxs)(n.p,{children:['Pointer and Key events "sink" from ancestors down to their target. The "sink" portion is the first phase of event handling; and it runs ',(0,o.jsx)(n.strong,{children:"before"}),' the "bubbling" phase. The root ancestor and all descendants toward the ',(0,o.jsx)(c.F.PointerEventTarget,{})," ",(0,o.jsx)(n.code,{children:"View"})," are notified of the event before the target is during this phase."]}),"\n",(0,o.jsx)(n.p,{children:'This phase can also be considered the filter phase, because it lets ancestors decide which events their children get to handle, since they can "veto" an event before it reaches the intended target.'}),"\n",(0,o.jsxs)(n.p,{children:["Listeners can take part in this phase of event handling as well. You do this by registering the following types via their respective properties within ",(0,o.jsx)(n.code,{children:"View"}),"."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(c.F.PointerListener,{})," via ",(0,o.jsx)(c.F.view.pointerFilter,{})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(c.F.PointerMotionListener,{})," via ",(0,o.jsx)(c.F.view.pointerMotionFilter,{})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(c.F.KeyListener,{})," via ",(0,o.jsx)(c.F.view.keyFilter,{})]}),"\n"]}),"\n",(0,o.jsx)(l.v,{children:F}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["Calling ",(0,o.jsx)(c.F.EventConsume,{})," during filter will prevent descendants (and the target) from receiving the event"]})}),"\n",(0,o.jsx)(n.h2,{id:"event-bubbling",children:"Event bubbling"}),"\n",(0,o.jsxs)(n.p,{children:['Event "bubbling" is the second and final phase of event handling. This phase notifies the target ',(0,o.jsx)(n.code,{children:"View"}),' and then "bubbles" the event up to ancestors of that ',(0,o.jsx)(n.code,{children:"View"})," as long as the event remains unconsumed. This means you can listen to all events that happen to the descendants of a ",(0,o.jsx)(n.code,{children:"View"})," during this phase as well. And similar to the filter phase, you will only receive events that were not consumed before-hand, which in this case means ",(0,o.jsx)(n.strong,{children:"down"})," the hierarchy."]}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["Bubbling is canceled if any listener calls ",(0,o.jsx)(c.F.EventConsume,{}),"."]})}),"\n",(0,o.jsx)(n.h2,{id:"pointer-events-for-ancestors",children:"Pointer events for ancestors"}),"\n",(0,o.jsxs)(n.p,{children:["Pointer events sent to an ancestors and descendants are slightly different from those sent to the ",(0,o.jsx)(n.code,{children:"View"}),". These events continue to have the same ",(0,o.jsx)(c.F.PointerEventTarget,{})," (",(0,o.jsx)(n.code,{children:"View"})," where the event fired), but their ",(0,o.jsx)(c.F.EventSource,{})," changes to the recipient ancestor as they bubble or sink."]})]})}function K(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(L,{...e})}):L(e)}function T(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},3729:(e,n,i)=>{i.d(n,{Ay:()=>d,RM:()=>s});var t=i(4848),o=i(8453),r=(i(5537),i(9329),i(4069));const s=[];function a(e){const n={admonition:"admonition",p:"p",...(0,o.R)(),...e.components};return(0,t.jsxs)(n.admonition,{title:"Module Required",type:"info",children:[(0,t.jsxs)("p",{children:["You must include the ",e.link," in your application in order to use these features."]}),(0,t.jsx)(r.v,{children:e.module}),(0,t.jsx)(n.p,{children:"Doodle uses opt-in modules like this to improve bundle size."})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}}}]);