"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[6509],{7105:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>F,contentTitle:()=>C,default:()=>T,frontMatter:()=>V,metadata:()=>t,toc:()=>S});const t=JSON.parse('{"id":"layout","title":"Layout","description":"View bounds","source":"@site/docs/layout.mdx","sourceDirName":".","slug":"/layout","permalink":"/doodle/docs/layout","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Layout","hide_title":true},"sidebar":"tutorialSidebar","previous":{"title":"Rendering","permalink":"/doodle/docs/rendering"},"next":{"title":"User Input","permalink":"/doodle/docs/userinput"}}');var o=i(4848),a=i(8453),s=(i(5537),i(9329),i(7269)),r=i(4069),l=i(9172);const d='package io.nacular.doodle.docs.apps\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.docs.utils.Panel\nimport io.nacular.doodle.drawing.Color.Companion.Gray\nimport io.nacular.doodle.drawing.Color.Companion.Lightgray\nimport io.nacular.doodle.drawing.TextMetrics\nimport io.nacular.doodle.layout.constraints.constrain\n\nclass ConstraintCreationApp(display: Display, textMetrics: TextMetrics): Application {\n    init {\n        val panel1 = Panel(textMetrics, "Panel 1").apply { backgroundColor = Lightgray }\n        val panel2 = Panel(textMetrics, "Panel 2").apply { backgroundColor = Gray      }\n\n        display += listOf(panel1, panel2)\n\n        // use Layout that follows constraints to position items\n//sampleStart\n        display.layout = constrain(panel1, panel2) { panel1, panel2 ->\n            panel1.top    eq 0\n            panel1.left   eq 0\n            panel1.right  eq parent.right / 3\n            panel1.bottom eq parent.bottom\n\n            panel2.top    eq panel1.top\n            panel2.left   eq panel1.right\n            panel2.right  eq parent.right\n            panel2.bottom eq parent.bottom\n        }\n//sampleEnd\n    }\n\n    override fun shutdown() {}\n}',c="\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.view\n\nfun positioning(display: Display) {\n//sampleStart\n    val view  = view {}\n    val panel = view {}\n\n    view.suggestX       ( 0.0      ) // suggest move to       [10, 0]\n    view.suggestPosition(13.0, -2.0) // suggest reposition to [13,-2]\n\n    display += panel                 // panel's position is 0,0\n//sampleEnd\n}",h="\nimport io.nacular.doodle.core.Layout\nimport io.nacular.doodle.core.Layout.Companion.simpleLayout\nimport io.nacular.doodle.core.Positionable\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.layout.Insets\n\nfun example() {\n//sampleStart\n    class CustomLayout: Layout {\n        override fun layout(views: Sequence<Positionable>, min: Size, current: Size, max: Size, insets: Insets): Size {\n            views.filter { it.visible }.forEach { child ->\n                child.updateBounds(Rectangle(/*...*/))\n            }\n\n            return current\n        }\n    }\n\n    // DSL for basic layout\n    simpleLayout { views, min, current, max, insets ->\n        views.filter { it.visible }.forEach { child ->\n            child.updateBounds(Rectangle(/*...*/))\n        }\n\n        current\n    }\n//sampleEnd\n}\n",p="import io.nacular.doodle.core.View\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.utils.Resizer\n\nfun resizer(view: View) {\n//sampleStart\n    view.apply {\n        suggestBounds(Rectangle(100, 100))\n        Resizer(this) // monitors the View and manages resize/move\n    }\n//sampleEnd\n}",u='package io.nacular.doodle.docs.apps\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.container\nimport io.nacular.doodle.core.width\nimport io.nacular.doodle.docs.utils.Panel\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.Color.Companion.Gray\nimport io.nacular.doodle.drawing.Color.Companion.Lightgray\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.drawing.TextMetrics\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.layout.constraints.Strength.Companion.Strong\nimport io.nacular.doodle.layout.constraints.center\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.utils.Resizer\nimport kotlin.math.min\n\nclass ConstraintStrengthApp(display: Display, textMetrics: TextMetrics): Application {\n    init {\n        val panel = object: Panel(textMetrics, "Panel") {\n            init {\n                backgroundColor = Lightgray\n            }\n\n            override fun render(canvas: Canvas) {\n                super.render(canvas)\n                canvas.rect(bounds.atOrigin, Stroke(Black, 2.0))\n            }\n        }\n\n        display += container {\n            this += panel\n\n            suggestSize(Size(min(400.0, display.width - 20), min(300.0, display.width - 20)))\n\n//sampleStart\n            layout = constrain(panel) {\n                it.left   eq     0\n                it.width  lessEq 200\n                it.right  eq     parent.right strength Strong // ignored when conflicts with above constraint\n                it.height eq     parent.height\n            }\n//sampleEnd\n\n            render = { rect(bounds.atOrigin, fill = Gray.paint) }\n\n            // helper to resize container\n            Resizer(this, movable = false)\n        }\n\n        // use Layout that follows constraints to position items\n        display.layout = constrain(display.first(), center)\n\n        display.fill(White.paint)\n    }\n\n    override fun shutdown() {}\n}',w='package io.nacular.doodle.docs.apps\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.container\nimport io.nacular.doodle.core.height\nimport io.nacular.doodle.core.width\nimport io.nacular.doodle.docs.utils.BlueColor\nimport io.nacular.doodle.docs.utils.Panel\nimport io.nacular.doodle.drawing.Color.Companion.Gray\nimport io.nacular.doodle.drawing.Color.Companion.Lightgray\nimport io.nacular.doodle.drawing.Color.Companion.Pink\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.drawing.TextMetrics\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.layout.constraints.Strength.Companion.Weak\nimport io.nacular.doodle.layout.constraints.center\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.utils.Direction.East\nimport io.nacular.doodle.utils.Direction.West\nimport io.nacular.doodle.utils.Resizer\nimport kotlin.math.min\n\nclass ComplexConstraintsApp(display: Display, textMetrics: TextMetrics): Application {\n    init {\n        val panel1 = Panel(textMetrics, "1").apply { backgroundColor = Pink; suggestWidth(350.0); Resizer(this, movable = false).apply { directions = setOf(East      ) } }\n        val panel2 = Panel(textMetrics, "2").apply { backgroundColor = Gray; suggestWidth( 50.0); Resizer(this                 ).apply { directions = setOf(East, West) } }\n        val panel3 = Panel(textMetrics, "3").apply { backgroundColor = Lightgray;                 Resizer(this, movable = false).apply { directions = setOf(West      ) } }\n\n        display += container {\n            this += listOf(panel1, panel2, panel3)\n\n            suggestSize(width = min(400.0, display.width - 20), height = min(300.0, display.height - 20))\n\n            val inset = 5\n\n//sampleStart\n            layout = constrain(panel1, panel2, panel3) { p1, p2, p3 ->\n                p1.top    eq     inset\n                p1.left   eq     inset\n                p1.width  lessEq (parent.width - inset) / 3\n                p1.width  eq     350 strength Weak\n                p1.height eq     parent.height - 2 * inset\n\n                p2.top    eq p1.top\n                p2.left   eq p1.right\n                p2.height eq p1.height\n\n                p3.top    eq p2.top\n                p3.left   eq p2.right\n                p3.height eq p2.height\n\n                p1.width + p2.width + p3.width eq parent.width - 2 * inset\n            }\n//sampleEnd\n\n            render = { rect(bounds.atOrigin, fill = BlueColor.paint) }\n\n            // helper to resize container\n            Resizer(this, movable = false)\n        }\n\n        // use Layout that follows constraints to position items\n        display.layout = constrain(display.first(), center)\n\n        display.fill(White.paint)\n    }\n\n    override fun shutdown() {}\n}',m="package constraints\n\nimport io.nacular.doodle.core.Container\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.layout.constraints.constrain\n\nfun basicConstraints(container: Container, view: View) {\n//sampleStart\n    val threshold = 100\n\n    container.layout = constrain(view) {\n        // This will result in different constraints being applied dynamically as\n        // container.width crosses the threshold\n        when {\n            container.width < threshold -> it.width eq parent.width / 2\n            else                        -> it.width eq parent.width\n        }\n    }\n//sampleEnd\n}",v="package constraints\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.layout.constraints.constrain\n\nfun basicConstraints(constant1: Double, constant2: Double, v1: View, v2: View) {\n    constrain(v1, v2) { view1, view2 ->\n//sampleStart\n        view1.left  eq        constant1 * view2.left   + constant2\n        view1.top   lessEq    constant1 * view2.height + constant2\n        view1.width greaterEq constant1 * view2.bottom + constant2\n//sampleEnd\n    }\n}",g="import io.nacular.doodle.core.container\nimport io.nacular.doodle.layout.HorizontalFlowLayout\n\nfun horizontalLayout() {\n//sampleStart\n    val container = container {}\n\n    container.layout = HorizontalFlowLayout() // Container exposes its layout\n//sampleEnd\n}",y="package constraints\n\nimport io.nacular.doodle.core.Container\nimport io.nacular.doodle.layout.constraints.Bounds\nimport io.nacular.doodle.layout.constraints.ConstraintDslContext\nimport io.nacular.doodle.layout.constraints.ConstraintLayout\nimport io.nacular.doodle.layout.constraints.constrain\nimport viewcreation.view1\nimport viewcreation.view2\n\nfun removal(container: Container) {\n//sampleStart\n    val constraints: ConstraintDslContext.(Bounds, Bounds) -> Unit = { v1, v2 ->\n        // ...\n    }\n\n    val layout: ConstraintLayout = constrain(view1, view2, constraints)\n\n    // remove constraints applied to these views\n    layout.unconstrain(view1, view2, constraints)\n//sampleEnd\n}",x="package constraints\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.layout.constraints.constrain\n\nfun multiView1(v1: View, v2: View) {\n    constrain(v1, v2) { view1, view2 ->\n//sampleStart\n    view1.width + 2 * view2.width eq parent.width - 10\n//sampleEnd\n    }\n}",f="package constraints\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.layout.constraints.constrain\n\nfun multiView2(v1: View, v2: View) {\n    constrain(v1, v2) { view1, view2 ->\n//sampleStart\n    view1.width + 10 eq parent.width - 2 * view2.width\n//sampleEnd\n    }\n}",j="package constraints\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.layout.constraints.constrain\n\nfun centerExpansions(v: View) {\n    constrain(v) { view ->\n//sampleStart\n        view.center                 eq parent.center      //   =\n        //                                                     \u2502\n        view.centerX                eq parent.centerX     // \u25c4\u2500\u2518\u2500\u2500\u2500\u2500\u2510\n        view.centerY                eq parent.centerY     // \u25c4\u2500\u2518\u2500\u2500\u2510 =\n        //                                                        = \u2502\n        view.top  + view.height / 2 eq parent.height / 2  // \u25c4\u2500\u2500\u2500\u2500\u2502\u2500\u2518\n        view.left + view.width  / 2 eq parent.width  / 2  // \u25c4\u2500\u2500\u2500\u2500\u2518\n//sampleEnd\n    }\n}",b="package constraints\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.layout.constraints.constrain\n\nfun readOnly(v: View) {\n    constrain(v) { view ->\n//sampleStart\n        view.top  + view.height.readOnly / 2 eq parent.centerY\n        view.left + view.width.readOnly  / 2 eq parent.centerX\n//sampleEnd\n    }\n}",z="package constraints\n\nimport io.nacular.doodle.core.Container\nimport io.nacular.doodle.layout.constraints.constrain\nimport viewcreation.view1\n\nfun badRemoval(container: Container) {\n//sampleStart\n    val layout = constrain(view1) { it.center eq parent.center }\n\n    // DO NOT DO THIS\n    layout.unconstrain(view1) { it.center eq parent.center }\n//sampleEnd\n}",V={title:"Layout",hide_title:!0},C="View positioning and sizing",F={},S=[{value:"View bounds",id:"view-bounds",level:2},{value:"A View&#39;s preferred size",id:"a-views-preferred-size",level:3},{value:"Auditing a View&#39;s size",id:"auditing-a-views-size",level:3},{value:"Using Layouts",id:"using-layouts",level:2},{value:"Constraint layouts",id:"constraint-layouts",level:2},{value:"Constraints are live",id:"constraints-are-live",level:3},{value:"Removing constraints",id:"removing-constraints",level:3},{value:"Constraint Strength",id:"constraint-strength",level:3},{value:"Readonly attributes",id:"readonly-attributes",level:3},{value:"View transforms",id:"view-transforms",level:2}];function k(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",strong:"strong",...(0,a.R)(),...e.components};return l.F||q("api",!1),l.F.Bounds||q("api.Bounds",!0),l.F.Constrain||q("api.Constrain",!0),l.F.Display||q("api.Display",!0),l.F.HorizontalFlowLayout||q("api.HorizontalFlowLayout",!0),l.F.Identity||q("api.Identity",!0),l.F.Layout||q("api.Layout",!0),l.F.Resizer||q("api.Resizer",!0),l.F.Size||q("api.Size",!0),l.F.Strength||q("api.Strength",!0),l.F.Unconstrain||q("api.Unconstrain",!0),l.F.View||q("api.View",!0),l.F.view||q("api.view",!1),l.F.view.boundingBox||q("api.view.boundingBox",!0),l.F.view.bounds||q("api.view.bounds",!0),l.F.view.idealSize||q("api.view.idealSize",!0),l.F.view.layout||q("api.view.layout",!0),l.F.view.position||q("api.view.position",!0),l.F.view.preferredSize||q("api.view.preferredSize",!0),l.F.view.size||q("api.view.size",!0),l.F.view.sizeAuditor||q("api.view.sizeAuditor",!0),l.F.view.suggestBounds||q("api.view.suggestBounds",!0),l.F.view.suggestPosition||q("api.view.suggestPosition",!0),l.F.view.suggestSize||q("api.view.suggestSize",!0),l.F.view.transform||q("api.view.transform",!0),l.F.view.x||q("api.view.x",!0),l.F.view.y||q("api.view.y",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"view-positioning-and-sizing",children:"View positioning and sizing"})}),"\n",(0,o.jsx)(n.h2,{id:"view-bounds",children:"View bounds"}),"\n",(0,o.jsxs)(n.p,{children:["Every View has an ",(0,o.jsx)(l.F.view.x,{}),", ",(0,o.jsx)(l.F.view.y,{})," position (in pixels) relative to its parent. This is exactly where the View will be rendered--unless it (or an ancestor) also has a ",(0,o.jsx)(l.F.view.transform,{}),". Doodle ensures that there is never a disconnect between a View's ",(0,o.jsx)(l.F.view.position,{}),", ",(0,o.jsx)(l.F.view.transform,{})," and render coordinates."]}),"\n",(0,o.jsxs)(n.p,{children:["Views get their positions and size constraints from their parent's ",(0,o.jsx)(n.a,{href:"layout#using-layouts",children:"Layout"})," (or that of the ",(0,o.jsx)(l.F.Display,{})," if they are top-level). A View's parent (via its ",(0,o.jsx)(l.F.view.layout,{}),") dictates the ",(0,o.jsx)(n.code,{children:"min"})," and ",(0,o.jsx)(n.code,{children:"max"})," ",(0,o.jsx)(l.F.Size,{})," the View can have. The View then picks a size within that range and shares it with the parent's ",(0,o.jsx)(l.F.view.layout,{}),". This size is used as part of the ",(0,o.jsx)(n.code,{children:"layout"}),"'s placement and results in a final position ans size for the View."]}),"\n",(0,o.jsxs)(n.p,{children:["This means you cannot directly specify a View's bounds, and can only ",(0,o.jsx)(n.strong,{children:"suggest"})," values using ",(0,o.jsx)(l.F.view.suggestPosition,{}),", ",(0,o.jsx)(l.F.view.suggestSize,{}),", ",(0,o.jsx)(l.F.view.suggestBounds,{})," etc. These hints do not guarantee the View's bounds will update as expected, since that is governed by the process just described."]}),"\n",(0,o.jsx)(r.v,{children:c}),"\n",(0,o.jsxs)(n.p,{children:["This demo shows how the pointer can be used to position Views easily. In this case, we use the ",(0,o.jsx)(l.F.Resizer,{})," utility to provide simple resize/move operations. The ",(0,o.jsx)(n.code,{children:"Resizer"})," simply monitors the ",(0,o.jsx)(n.code,{children:"View"})," for pointer events and suggests updates to its ",(0,o.jsx)(n.code,{children:"bounds"})," accordingly. These suggestions take effect because the View's parent has no ",(0,o.jsx)(n.a,{href:"layout#using-layouts",children:"Layout"}),", etc."]}),"\n",(0,o.jsx)(r.v,{children:p}),"\n",(0,o.jsx)(s.T,{functionName:"positioning",height:"400"}),"\n",(0,o.jsx)(n.h3,{id:"a-views-preferred-size",children:"A View's preferred size"}),"\n",(0,o.jsxs)(n.p,{children:["All Views have a ",(0,o.jsx)(l.F.view.preferredSize,{})," property that they use when trying to determine what to adopt within the ",(0,o.jsx)(n.code,{children:"min"}),", ",(0,o.jsx)(n.code,{children:"max"})," constraints they receive from their parent. The default behavior uses the View's ",(0,o.jsx)(l.F.view.layout,{})," to calculate a size or the latest size suggestion if no ",(0,o.jsx)(n.code,{children:"layout"})," is present."]}),"\n",(0,o.jsxs)(n.p,{children:["This value is also used to derive the View's ",(0,o.jsx)(l.F.view.idealSize,{}),"; which is essentially a result of calling: ",(0,o.jsx)(n.code,{children:"preferredSize(Size.Empty, Size.Infinity)"}),"."]}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsx)(n.p,{children:"You can override this behavior by providing your own lambda for this property."})}),"\n",(0,o.jsx)(n.h3,{id:"auditing-a-views-size",children:"Auditing a View's size"}),"\n",(0,o.jsxs)(n.p,{children:["In addition to a customizable ",(0,o.jsx)(n.code,{children:"preferredSize"}),', Views can also "audit" their size using their ',(0,o.jsx)(l.F.view.sizeAuditor,{}),". A View's ",(0,o.jsx)(n.code,{children:"sizeAuditor"})," is called whenever its size is being changed. The auditor is given the current size, the new size, and the ",(0,o.jsx)(n.code,{children:"min"}),", ",(0,o.jsx)(n.code,{children:"max"})," constraints the View has to fit into. It can then determine what final size the View should have. The value chosen is still coerced into the min-max range by the framework."]}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsx)(n.p,{children:"SizeAuditors makes creating Views with fixed aspect ratios much easier. And the framework even has an auditor that helps with this."})}),"\n",(0,o.jsx)(n.h2,{id:"using-layouts",children:"Using Layouts"}),"\n",(0,o.jsxs)(n.p,{children:["A ",(0,o.jsx)(l.F.Layout,{})," keeps track of a ",(0,o.jsx)(n.code,{children:"View"})," and its children and automatically arranges the children as sizes change. This happens (by default) whenever View's ",(0,o.jsx)(l.F.view.size,{})," changes, or one of its children has its ",(0,o.jsx)(l.F.view.bounds,{})," change. The View class also ",(0,o.jsx)(n.code,{children:"protects"})," its ",(0,o.jsx)(l.F.view.layout,{})," property by default so it can encapsulate special handling if needed, but sub-classes are free to expose it."]}),"\n",(0,o.jsxs)(n.p,{children:["This examples shows the use of ",(0,o.jsx)(l.F.HorizontalFlowLayout,{}),", which wraps a View's children from left to right within its bounds."]}),"\n",(0,o.jsx)(r.v,{children:g}),"\n",(0,o.jsx)(s.T,{functionName:"flowLayout",height:"400"}),"\n",(0,o.jsxs)(n.p,{children:["Doodle comes with several useful layouts, including one based on constraints. But you can easily create custom Layouts by implementing the ",(0,o.jsx)(l.F.Layout,{})," interface or using the ",(0,o.jsx)(n.code,{children:"simpleLayout"})," utility function."]}),"\n",(0,o.jsx)(r.v,{children:h}),"\n",(0,o.jsxs)(n.p,{children:["Layouts are generally triggered whenever their monitored View changes size or has a child whose bounds change. This default behavior can also be customized for cases when a Layout wants to ignore certain changes. In fact, Layouts are asked whether they want to respond to ",(0,o.jsx)(l.F.view.size,{})," changes in their container and ",(0,o.jsx)(l.F.view.bounds,{})," for children."]}),"\n",(0,o.jsx)(n.h2,{id:"constraint-layouts",children:"Constraint layouts"}),"\n",(0,o.jsxs)(n.p,{children:["Doodle also supports a constraints based layout that uses linear equations to define placement. This approach lets you write equations that define how several anchor points on a ",(0,o.jsx)(l.F.View,{})," (based on a provided ",(0,o.jsx)(l.F.Bounds,{}),") will be placed relative to other Views and the ",(0,o.jsx)(n.code,{children:"parent"})," View. This covers many of the common layout use cases and is easy to use."]}),"\n",(0,o.jsxs)(n.p,{children:["Each linear equation is one of the following forms. Where ",(0,o.jsx)(n.code,{children:"attribute"})," refers to anchor points or ",(0,o.jsx)(n.code,{children:"width"})," and ",(0,o.jsx)(n.code,{children:"height"}),"."]}),"\n",(0,o.jsx)(r.v,{children:v}),"\n",(0,o.jsxs)(n.p,{children:["The Constraint system will modify all the attributes provided to it to ensure every equation (or inequality) is satisfied. In the above example, that means updating widths fo ",(0,o.jsx)(n.code,{children:"view1"})," and ",(0,o.jsx)(n.code,{children:"view2"})," to ensure they add up to the ",(0,o.jsx)(n.code,{children:"parent"})," width minus 10."]}),"\n",(0,o.jsxs)(n.admonition,{type:"tip",children:[(0,o.jsx)(n.p,{children:"You can also include multiple Views in a single equation:"}),(0,o.jsx)(r.v,{children:x}),(0,o.jsx)(n.p,{children:"The fact that these are equations (or inequalities) means you can flip the order of attributes and have the same effect, as long as you obey the rules of mathematics and change signs accordingly. So the equation above is the same as:"}),(0,o.jsx)(r.v,{children:f})]}),"\n",(0,o.jsxs)(n.p,{children:["Constraint layouts are created using the ",(0,o.jsx)(l.F.Constrain,{})," function. This function takes a list of ",(0,o.jsx)(n.code,{children:"View"}),"s and a lambda that defines the constraints to apply. For example, the following shows a new layout being created to position and size two panels within a container:"]}),"\n",(0,o.jsx)(s.T,{functionName:"createConstraints",height:"300"}),"\n",(0,o.jsx)(r.v,{children:d}),"\n",(0,o.jsx)(n.h3,{id:"constraints-are-live",children:"Constraints are live"}),"\n",(0,o.jsx)(n.p,{children:'The constraint definitions provided when creating a layout are "live", meaning they are invoked on every layout. This makes it easy to capture external variables or use conditional logic in constraints. But it also means care has to be taken to avoid inefficient layouts. Below is an example of a layout that changes behavior based on a threshold variable.'}),"\n",(0,o.jsx)(r.v,{children:m}),"\n",(0,o.jsx)(n.h3,{id:"removing-constraints",children:"Removing constraints"}),"\n",(0,o.jsx)(n.p,{children:"Live constraints make it easy to support conditional logic, which covers most cases where constraints may need to be suppressed. But sometimes it is necessary to remove a set of constraints from a layout entirely. This is done in a very similar way to how we define constraints to begin with."}),"\n",(0,o.jsx)(n.p,{children:"Removing constraints is analogous to removing a handler. That is if we think of a constraint block and the list of Views it targets as a single handler that is invoked whenever a layout is triggered. In that way, removing the constraints requires specifying the same list of Views and the block when removing it."}),"\n",(0,o.jsx)(r.v,{children:y}),"\n",(0,o.jsxs)(n.admonition,{type:"caution",children:[(0,o.jsxs)(n.p,{children:["The order and number of Views provided to ",(0,o.jsx)(l.F.Unconstrain,{})," must match what was used during ",(0,o.jsx)(l.F.Constrain,{}),". That is because changing order or arity would result in a different constraint effect than was applied."]}),(0,o.jsx)(n.p,{children:"You should store a reference to the constrain block to ensure it is identified as the same one used during register. Do not do the following"}),(0,o.jsx)(r.v,{children:z})]}),"\n",(0,o.jsx)(n.h3,{id:"constraint-strength",children:"Constraint Strength"}),"\n",(0,o.jsxs)(n.p,{children:["It is possible to define constraints that conflict with each other. This result in an error since there is no clear solution. But you can resolve these conflicts by providing a relative priority or ",(0,o.jsx)(l.F.Strength,{})," for the constraints in question. This allows the engine to break lower strength constraints when there are conflicts."]}),"\n",(0,o.jsxs)(n.p,{children:["All constraints have the ",(0,o.jsx)(n.code,{children:"Required"})," strength by default. This is the highest possible strength that tells the engine to enforce such a constraint. But you can specify the strength explicitly."]}),"\n",(0,o.jsx)(r.v,{children:u}),"\n",(0,o.jsx)(s.T,{functionName:"constraintStrength",height:"400"}),"\n",(0,o.jsx)(n.p,{children:"This results in the panel matching its parent's width whenever it is 200 or less."}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsx)(n.p,{children:"Notice that the constraints indicate a weaker priority/strength for the view's right property. This approach allows you to relax certain constraints when there are conflicts."})}),"\n",(0,o.jsx)(n.p,{children:"The following shows a more complex set of constraints that also use strengths and inequality."}),"\n",(0,o.jsx)(s.T,{functionName:"complexConstraints",height:"400"}),"\n",(0,o.jsx)(r.v,{children:w}),"\n",(0,o.jsx)(n.h3,{id:"readonly-attributes",children:"Readonly attributes"}),"\n",(0,o.jsxs)(n.p,{children:["Sometimes it is necessary to refer to an attribute in a constraint without the risk of changing it. A good example of this trying to center a ",(0,o.jsx)(n.code,{children:"View"}),". The normal approach to doing this involves using the ",(0,o.jsx)(n.code,{children:"center"}),", ",(0,o.jsx)(n.code,{children:"centerX"}),", or ",(0,o.jsx)(n.code,{children:"centerY"})," attributes. But all of these are just short-hand that expand as follows. This means using them actually adds constraints to the ",(0,o.jsx)(n.code,{children:"width"})," and/or ",(0,o.jsx)(n.code,{children:"height"})," as well as ",(0,o.jsx)(n.code,{children:"top"})," and ",(0,o.jsx)(n.code,{children:"left"}),"."]}),"\n",(0,o.jsx)(r.v,{children:j}),"\n",(0,o.jsx)(n.p,{children:"Readonly attributes can help you avoid these additional constraints:"}),"\n",(0,o.jsx)(r.v,{children:b}),"\n",(0,o.jsxs)(n.p,{children:["The use of ",(0,o.jsx)(n.code,{children:"readOnly"})," converts the attributes to constants that are evaluated whenever the constraints are evaluated. This means there are only 2 constraints defined for ",(0,o.jsx)(n.code,{children:"view"})," in this example, instead of 4."]}),"\n",(0,o.jsx)(n.admonition,{type:"warning",children:(0,o.jsxs)(n.p,{children:["Notice that it is possible to have a slightly stale value when using ",(0,o.jsx)(n.code,{children:"readOnly"}),". That's because the value is derived BEFORE the constraints are applied. Which means the source property could change if it is a part of some other constraint; leaving the ",(0,o.jsx)(n.code,{children:"readOnly"})," value behind."]})}),"\n",(0,o.jsxs)(n.p,{children:["To do this, you simply use the ",(0,o.jsx)(n.code,{children:"readOnly"})," property of the attribute:"]}),"\n",(0,o.jsx)(n.h2,{id:"view-transforms",children:"View transforms"}),"\n",(0,o.jsxs)(n.p,{children:["You can change the shape of a View using a linear ",(0,o.jsx)(n.a,{href:"transforms",children:"transform"}),". This will change the way the View is rendered to the screen, and can even change the size of the View. But a transformed View still retains the same ",(0,o.jsx)(l.F.view.bounds,{}),", while its ",(0,o.jsx)(l.F.view.boundingBox,{})," changes with the transform. This means layouts will continue to treat the View as though nothing about it changed."]}),"\n",(0,o.jsx)(n.p,{children:"Hit detection and other behavior work as expected for Views that have been transformed."}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsx)(n.p,{children:"Changes to a View's transform will not trigger layout."})}),"\n",(0,o.jsx)(s.T,{functionName:"transforms",height:"400"}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"boundingBox"})," == ",(0,o.jsx)(n.code,{children:"bounds"})," when ",(0,o.jsx)(l.F.view.transform,{})," == ",(0,o.jsx)(l.F.Identity,{}),"."]})})]})}function T(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(k,{...e})}):k(e)}function q(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);