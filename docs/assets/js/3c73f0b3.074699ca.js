"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[1640],{9712:(e,n,i)=>{i.d(n,{SI:()=>s,cp:()=>d});var t=i(7624),o=i(4552),r=(i(7793),i(6236),i(7492));const s=[];function a(e){const n={admonition:"admonition",p:"p",...(0,o.M)(),...e.components};return(0,t.jsxs)(n.admonition,{title:"Module Required",type:"info",children:[(0,t.jsxs)("p",{children:["You must include the ",e.link," in your application in order to use these features."]}),(0,t.jsx)(r.A,{children:e.module}),(0,t.jsx)(n.p,{children:"Doodle uses opt-in modules like this to improve bundle size."})]})}function d(e={}){const{wrapper:n}={...(0,o.M)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},6380:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>P,contentTitle:()=>j,default:()=>C,frontMatter:()=>g,metadata:()=>f,toc:()=>y});var t=i(7624),o=i(4552),r=i(7793),s=i(6236),a=i(5272),d=i(7492),l=i(3220),c=i(9712);const p="package pointerinput\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.application.Modules.Companion.PointerModule\nimport io.nacular.doodle.application.application\nimport io.nacular.doodle.core.Display\nimport org.kodein.di.instance\nimport rendering.MyApp\n\n//sampleStart\nfun main() {\n    /** Include [PointerModule] when launching your app */\n    application(modules = listOf(PointerModule)) {\n        MyApp(instance())\n    }\n}\n\n/**\n * Pointer events will fire for this app when launched with [PointerModule]\n */\nclass MyApp(display: Display): Application {\n    override fun shutdown() {}\n}\n//sampleEnd",h="package pointerinput\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.event.PointerListener.Companion.pressed\n\nfun consume(view: View) {\n//sampleStart\n    view.pointerChanged += pressed { event ->\n        // ... take action based on event\n\n        event.consume() // indicate that no other listeners should be notified\n    }\n//sampleEnd\n}\n",u="package io.nacular.doodle.docs.utils\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.renderProperty\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color.Companion.Red\nimport io.nacular.doodle.drawing.circle\nimport io.nacular.doodle.drawing.opacity\nimport io.nacular.doodle.event.PointerListener\nimport io.nacular.doodle.geometry.Circle\nimport io.nacular.doodle.geometry.Point\n\n//sampleStart\n/**\n * This view renders a circle and provides precise hit detection for it.\n */\nclass CircularView(radius: Double): View() {\n    private val circle      = Circle(Point(radius, radius), radius)\n    private var pointerOver by renderProperty(false)\n\n    init {\n        size = circle.boundingRectangle.size\n\n        pointerChanged += PointerListener.on(\n            entered = { pointerOver = true  },\n            exited  = { pointerOver = false }\n        )\n    }\n\n    override fun intersects(point: Point) = point - position in circle\n\n    override fun render(canvas: Canvas) {\n        canvas.circle(circle, color = if (pointerOver) Red opacity 0.5f else Red)\n    }\n}\n//sampleEnd",m="package io.nacular.doodle.docs.utils\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.renderProperty\nimport io.nacular.doodle.drawing.AffineTransform.Companion.Identity\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.event.PointerListener.Companion.on\nimport io.nacular.doodle.geometry.ConvexPolygon\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.reversed\nimport io.nacular.doodle.geometry.toPath\n\n//sampleStart\n/**\n * This view renders a triangular shape and provides precise hit detection for it.\n */\nclass TriangleView: View() {\n    private val outerPoly get() = ConvexPolygon(Point(width / 2), Point(width, height), Point(0, height))\n    private val innerPoly get() = Identity.scale(\n        around = Point(width / 2, height * 2 / 3),\n        x      = 0.5,\n        y      = 0.5\n    ).invoke(outerPoly.reversed())\n\n    private var pointerOver by renderProperty(false)\n\n    init {\n        pointerChanged += on(\n            entered = { pointerOver = true  },\n            exited  = { pointerOver = false }\n        )\n    }\n\n    /**\n     * Override [intersects] this instead of [contains] to get [point]\n     * that is mapped to this view's plane, where intersection logic is\n     * much simpler.\n     */\n    override fun intersects(point: Point) = (point - position).let {\n        it in outerPoly && it !in innerPoly\n    }\n\n    override fun render(canvas: Canvas) {\n        canvas.path(\n            path = outerPoly.toPath() + innerPoly.toPath(),\n            fill = if (pointerOver) Black.paint else White.paint\n        )\n    }\n}\n//sampleEnd",v="package pointerinput\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.event.PointerEvent\nimport io.nacular.doodle.event.PointerListener\nimport io.nacular.doodle.event.PointerListener.Companion.on\nimport io.nacular.doodle.event.PointerListener.Companion.pressed\n\nfun example(view: View) {\n//sampleStart\n    // Listen to pressed/exit via interface override\n    view.pointerChanged += object: PointerListener {\n        override fun pressed(event: PointerEvent) {\n            // ..\n        }\n\n        override fun exited(event: PointerEvent) {\n            // ..\n        }\n    }\n\n    // Listener to pressed via DSL\n    view.pointerChanged += pressed { event -> /* .. */ }\n\n    // Listen to pressed/exit via DSL\n    view.pointerChanged += on(\n        pressed = { event -> /* .. */ },\n        exited  = { event -> /* .. */ },\n    )\n//sampleEnd\n}",w="package pointerinput\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.event.PointerEvent\nimport io.nacular.doodle.event.PointerMotionListener\nimport io.nacular.doodle.event.PointerMotionListener.Companion.moved\nimport io.nacular.doodle.event.PointerMotionListener.Companion.on\n\nfun pointerMotion(view: View) {\n//sampleStart\n    // Listen to moved/dragged via interface override\n    view.pointerMotionChanged += object: PointerMotionListener {\n        override fun moved(event: PointerEvent) {\n            // ..\n        }\n\n        override fun dragged(event: PointerEvent) {\n            // ..\n        }\n    }\n\n    // Listener to moved via DSL\n    view.pointerMotionChanged += moved { event -> /* .. */ }\n\n    // Listen to moved/dragged via DSL\n    view.pointerMotionChanged += on(\n        moved   = { event -> /* .. */ },\n        dragged = { event -> /* .. */ },\n    )\n//sampleEnd\n}",x="package pointerinput\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.event.PointerMotionListener.Companion.moved\n\nfun multiTouch(view: View) {\n//sampleStart\n    view.pointerMotionChanged += moved { event ->\n        event.targetInteractions  // the set of interactions with the target View\n        event.changedInteractions // the interactions that changed (triggered) this event\n        event.allInteractions     // all active interactions for the app\n    }\n//sampleEnd\n}\n",g={title:"Pointer",hide_title:!0},j=void 0,f={id:"user_input/pointer",title:"Pointer",description:"Pointer input",source:"@site/docs/user_input/pointer.mdx",sourceDirName:"user_input",slug:"/user_input/pointer",permalink:"/doodle/docs/user_input/pointer",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Pointer",hide_title:!0},sidebar:"tutorialSidebar",previous:{title:"Transforms",permalink:"/doodle/docs/transforms"},next:{title:"Keyboard",permalink:"/doodle/docs/user_input/keyboard"}},P={},y=[{value:"Pointer input",id:"pointer-input",level:2},...c.SI,{value:"Hit detection",id:"hit-detection",level:2},{value:"Support for transforms",id:"support-for-transforms",level:2},{value:"Pointer listeners",id:"pointer-listeners",level:2},{value:"Pointer events",id:"pointer-events",level:2},{value:"Pointer motion events",id:"pointer-motion-events",level:2},{value:"Multi-touch",id:"multi-touch",level:2}];function b(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.M)(),...e.components};return l.m||M("api",!1),l.m.EventConsume||M("api.EventConsume",!0),l.m.EventSource||M("api.EventSource",!0),l.m.Interaction||M("api.Interaction",!0),l.m.PointerEvent||M("api.PointerEvent",!0),l.m.PointerEventTarget||M("api.PointerEventTarget",!0),l.m.PointerListener||M("api.PointerListener",!0),l.m.PointerModule||M("api.PointerModule",!0),l.m.PointerMotionListener||M("api.PointerMotionListener",!0),l.m.view||M("api.view",!1),l.m.view.bounds||M("api.view.bounds",!0),l.m.view.containsPoint||M("api.view.containsPoint",!0),l.m.view.enabled||M("api.view.enabled",!0),l.m.view.intersects||M("api.view.intersects",!0),l.m.view.pointerChanged||M("api.view.pointerChanged",!0),l.m.view.pointerMotionChanged||M("api.view.pointerMotionChanged",!0),l.m.view.toLocal||M("api.view.toLocal",!0),l.m.view.transform||M("api.view.transform",!0),l.m.view.visible||M("api.view.visible",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"pointer-input",children:"Pointer input"}),"\n",(0,t.jsxs)(n.p,{children:["Pointer handling is easy with Doodle; simply include the ",(0,t.jsx)(n.code,{children:"PointerModule"})," when launching your app, and the underlying framework uses it to produce key events."]}),"\n",(0,t.jsx)(c.cp,{link:(0,t.jsx)(l.m.PointerModule,{}),module:p}),"\n",(0,t.jsx)(n.h2,{id:"hit-detection",children:"Hit detection"}),"\n",(0,t.jsxs)(n.p,{children:["The framework relies on the ",(0,t.jsx)(n.code,{children:"View"})," ",(0,t.jsx)(l.m.view.containsPoint,{})," method to determine when the pointer is within a ",(0,t.jsx)(n.code,{children:"View"}),"'s boundaries. This method gets a point in the ",(0,t.jsx)(n.strong,{children:"view's parent reference frame"})," (or the ",(0,t.jsx)(n.a,{href:"/doodle/docs/display#an-apps-root-container",children:(0,t.jsx)(n.strong,{children:"Display"})}),"'s for top-level Views)) and returns whether or not that point intersects the view. The default implementation just checks the point against ",(0,t.jsx)(l.m.view.bounds,{})," and accounts for the view's ",(0,t.jsx)(l.m.view.transform,{}),"."]}),"\n",(0,t.jsxs)(r.c,{children:[(0,t.jsx)(s.c,{value:"Demo",children:(0,t.jsx)(a.u,{functionName:"hitDetection",height:"250"})}),(0,t.jsx)(s.c,{value:"Code",children:(0,t.jsx)(d.A,{children:u})})]}),"\n",(0,t.jsx)(n.h2,{id:"support-for-transforms",children:"Support for transforms"}),"\n",(0,t.jsxs)(n.p,{children:["Doodle also accounts for transformations applied to the ",(0,t.jsx)(n.code,{children:"View"}),"'s ancestors when delivering pointer events. This means the ",(0,t.jsx)(n.code,{children:"View"})," will receive the right notification whenever the pointer intersects its parent despite transformations. Hit detection logic in the ",(0,t.jsx)(n.code,{children:"View"})," is then triggered as usual. The ",(0,t.jsx)(n.code,{children:"View"})," still needs to take its own transformation into account though, since the given point used in hit detection is within the parent coordinate space. This is automatically handled if the ",(0,t.jsx)(n.code,{children:"View"})," implements ",(0,t.jsx)(l.m.view.intersects,{})," or if ",(0,t.jsx)(l.m.view.toLocal,{})," is used when overriding ",(0,t.jsx)(l.m.view.containsPoint,{}),"."]}),"\n",(0,t.jsxs)(r.c,{children:[(0,t.jsx)(s.c,{value:"Demo",children:(0,t.jsx)(a.u,{functionName:"hitDetectionTransform",height:"500"})}),(0,t.jsx)(s.c,{value:"Code",children:(0,t.jsx)(d.A,{children:m})})]}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["Override ",(0,t.jsx)(l.m.view.intersects,{})," instead of ",(0,t.jsx)(l.m.view.containsPoint,{})," unless you want to factor in the view's transform into your hit detection logic."]})}),"\n",(0,t.jsx)(n.h2,{id:"pointer-listeners",children:"Pointer listeners"}),"\n",(0,t.jsxs)(n.p,{children:["Views are able to receive pointer events once the ",(0,t.jsx)(l.m.PointerModule,{})," is loaded, they are ",(0,t.jsx)(l.m.view.visible,{})," and ",(0,t.jsx)(l.m.view.enabled,{}),". You can then attach a ",(0,t.jsx)(l.m.PointerListener,{})," to any ",(0,t.jsx)(n.code,{children:"View"}),"'s ",(0,t.jsx)(l.m.view.pointerChanged,{})," property and get notified whenever a pointer does one of the following:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Enters"})," the View"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Pressed"})," within the View"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Released"})," within the View"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Clicked"})," (Pressed then Released) within the View"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Exits"})," the View"]}),"\n"]}),"\n",(0,t.jsx)(d.A,{children:v}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:[(0,t.jsx)(l.m.PointerListener,{})," has no-op defaults for each event, so you only need to implement the ones you need."]})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["Notice that ",(0,t.jsx)(l.m.view.pointerChanged,{}),"--like other observable properties--supports many observers and enables you to add/remove an observer any time."]})}),"\n",(0,t.jsx)(n.h2,{id:"pointer-events",children:"Pointer events"}),"\n",(0,t.jsxs)(n.p,{children:["The event provided to ",(0,t.jsx)(l.m.PointerListener,{}),"s carries information about the ",(0,t.jsx)(n.code,{children:"View"})," it originated from (",(0,t.jsx)(l.m.PointerEventTarget,{}),"), the ",(0,t.jsx)(n.code,{children:"View"})," it is sent to (",(0,t.jsx)(l.m.EventSource,{}),"), various attributes about the state of the pointers--like buttons pressed--and their locations relative to the target ",(0,t.jsx)(n.code,{children:"View"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Pointer events are ",(0,t.jsx)(n.strong,{children:"consumable"}),". This means any observer can call ",(0,t.jsx)(l.m.EventConsume,{})," on an event and prevent subsequent listeners from receiving it."]}),"\n",(0,t.jsx)(d.A,{children:h}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["Calling ",(0,t.jsx)(l.m.EventConsume,{})," during filter will prevent descendants (and the target) from receiving the event"]})}),"\n",(0,t.jsx)(n.h2,{id:"pointer-motion-events",children:"Pointer motion events"}),"\n",(0,t.jsxs)(n.p,{children:["Pointer motion events occur whenever a pointer moves within a View. They are treated separately from ",(0,t.jsx)(n.a,{href:"/doodle/docs/user_input/pointer",children:(0,t.jsx)(n.strong,{children:"pointer events"})})," because of their high frequency. The ",(0,t.jsx)(n.a,{href:"/doodle/docs/user_input/pointer",children:"PointerModule"})," is also required to enable them. And ",(0,t.jsx)(n.a,{href:"/doodle/docs/user_input/pointer#hit-detection",children:(0,t.jsx)(n.strong,{children:"hit detection"})})," follows the same rules as with pointer events."]}),"\n",(0,t.jsxs)(n.p,{children:["Registration is different though. You use listen to ",(0,t.jsx)(l.m.view.pointerMotionChanged,{})," and implement ",(0,t.jsx)(l.m.PointerMotionListener,{}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Pointer motion listeners are notified whenever a pointer:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Moves"})," within a View"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Drags"})," anywhere while pressed, if the press started in a View"]}),"\n"]}),"\n",(0,t.jsx)(d.A,{children:w}),"\n",(0,t.jsx)(n.h2,{id:"multi-touch",children:"Multi-touch"}),"\n",(0,t.jsxs)(n.p,{children:["Pointer events support multiple, simultaneous inputs by default. This covers the multi-touch use-case on mobile and other similar scenarios. The ",(0,t.jsx)(l.m.PointerEvent,{})," class contains information about all active ",(0,t.jsx)(l.m.Interaction,{}),"s for the current event. This includes those directed at the event target. Apps are therefore able to incorporate this into their pointer handling."]}),"\n",(0,t.jsx)(d.A,{children:x}),"\n",(0,t.jsx)(n.p,{children:"Doodle also does not limit simultaneous interactions to a single View. All active interactions will be sent to the appropriate Views and managed concurrently. This means it is possible to drag multiple items at the same time."}),"\n",(0,t.jsx)(a.u,{functionName:"positioning",args:"[2]",height:"400"}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsx)(n.p,{children:"Try moving both boxes at the same time if you are on a mobile device or have multiple pointers."}),(0,t.jsx)(n.admonition,{type:"tip"})]})]})}function C(e={}){const{wrapper:n}={...(0,o.M)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(b,{...e})}):b(e)}function M(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);