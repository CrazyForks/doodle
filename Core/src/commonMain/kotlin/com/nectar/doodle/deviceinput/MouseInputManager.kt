package com.nectar.doodle.deviceinputimport com.nectar.doodle.controls.panels.ScrollPanelimport com.nectar.doodle.core.Displayimport com.nectar.doodle.core.Viewimport com.nectar.doodle.event.MouseEventimport com.nectar.doodle.system.Cursorimport com.nectar.doodle.system.Cursor.Companion.Defaultimport com.nectar.doodle.system.MouseInputServiceimport com.nectar.doodle.system.SystemMouseEventimport com.nectar.doodle.system.SystemMouseEvent.Typeimport com.nectar.doodle.system.SystemMouseEvent.Type.Clickimport com.nectar.doodle.system.SystemMouseEvent.Type.Downimport com.nectar.doodle.system.SystemMouseEvent.Type.Dragimport com.nectar.doodle.system.SystemMouseEvent.Type.Enterimport com.nectar.doodle.system.SystemMouseEvent.Type.Exitimport com.nectar.doodle.system.SystemMouseEvent.Type.Moveimport com.nectar.doodle.system.SystemMouseEvent.Type.Upimport com.nectar.doodle.system.SystemMouseScrollEventimport com.nectar.doodle.system.SystemPointerEventinterface MouseInputManager {    fun shutdown()}@Suppress("NestedLambdaShadowedImplicitParameter")class MouseInputManagerImpl(private val display: Display, private val inputService: MouseInputService): MouseInputManager, MouseInputService.Listener {    private var mouseDown   = false    private var clickedView = null as View?    private val viewFinder  = ViewFinderImpl(display)    private var coveredView = null as View?        set(new) {            if (new == field) {                return            }            field?.let { unregisterCursorListeners(it) }            field = new            field?.let { registerCursorListeners  (it) }        }    private var cursor = null as Cursor?        set(new) {            field = new            inputService.cursor = cursor ?: display.cursor ?: Default        }    private var toolTipText = ""        set(new) {            field = new            inputService.toolTipText = field        }    private val displayCursorChanged = { _: Display, _: Cursor?, new: Cursor? -> cursor = new }    private val viewCursorChanged = { view: View, _: Cursor?, _: Cursor? ->        cursor = cursor(of = view)    }    init {        inputService += this        display.cursorChanged += displayCursorChanged        cursor = display.cursor    }    override fun shutdown() {        inputService -= this        display.cursorChanged -= displayCursorChanged    }    override fun changed(event: SystemMouseEvent) {        when (event.type) {            Up -> when(event.clickCount) {                1    -> mouseUp(event)                else -> doubleClick(event)            }            Move -> mouseMove(event)            Down -> mouseDown(event)            else -> {}        }    }    override fun changed(event: SystemMouseScrollEvent) = mouseScroll(event)    private fun mouseUp(event: SystemMouseEvent) {        val view = view(from = event)        if (clickedView != null || mouseDown) {            clickedView?.let {                deliver(createMouseEvent(event, it))                if (view === it) {                    deliver(createMouseEvent(event, it, Click))                }                event.consume()            }            if (view !== clickedView) {                clickedView?.let {                    // Avoid case where mouse-move hasn't been seen (possible if drag-drop happened)                    if (coveredView == it) {                        coveredView = null                        deliver(createMouseEvent(event, it, Exit))                    }                }                if (view != null) {                    coveredView = view                    deliver(createMouseEvent(event, view, Enter))                    deliver(createMouseEvent(event, view, Up   ))                    cursor = cursor(of = view)                    event.consume()                } else {                    cursor = display.cursor                }            } else {                cursor = cursor(of = view)            }            clickedView = null        } else if (view != null) {            deliver(createMouseEvent(event, view, Enter))            deliver(createMouseEvent(event, view       ))            cursor = cursor(of = view)            event.consume()        } else {            cursor = display.cursor        }        mouseDown = false    }    private fun mouseDown(event: SystemMouseEvent) {        toolTipText = ""        view(from = event)?.let { view ->            if (view != coveredView) {                createMouseEvent(event, view, Enter).also {                    deliver(it)                    toolTipText = view.toolTipText(it)                }                coveredView = view                cursor      = cursor(of = coveredView)            }            deliver(createMouseEvent(event, view))            clickedView = view            event.consume()        }        mouseDown = true    }    private fun doubleClick(event: SystemMouseEvent) {        toolTipText = ""        view(from = event)?.let {            deliver(createMouseEvent(event, it, Up   ))            deliver(createMouseEvent(event, it, Click))            event.consume()        }    }    private fun mouseMove(event: SystemMouseEvent) {        clickedView?.let {            deliver(createMouseEvent(event, it, Drag))            cursor = cursor(of = it)            event.consume()        }        val view = view(from = event)        if (view !== coveredView) {            coveredView?.let {                if (!mouseDown || it === clickedView) {                    deliver(createMouseEvent(event, it, Exit))                    event.consume()                }            }            if (view != null) {                if (!mouseDown || view === clickedView) {                    createMouseEvent(event, view, Enter).also {                        deliver(it)                        toolTipText = view.toolTipText(it)                    }                    cursor = cursor(of = coveredView)                    event.consume()                }            } else if (clickedView == null) {                toolTipText = ""                cursor = null            }            coveredView = view        } else if (!mouseDown) {            coveredView?.let {                deliver(createMouseEvent(event, it, Move))                event.consume()            }            if (coveredView == null) {                toolTipText = ""            }            cursor = cursor(of = coveredView)        }    }    private fun mouseScroll(event: SystemMouseScrollEvent) {//        view(from = event)?.let {//            it.handleMouseScrollEvent_(MouseScrollEvent(//                    it,//                    it,//                    event.location - it.toAbsolute(Origin),//                    event.xRotation,//                    event.yRotation,//                    event.modifiers))////            event.consume()//        }    }    private fun deliver(event: MouseEvent) {        val chain = mutableListOf(event.target)        var view = event.target.parent        while (view != null) {            if (view.enabled && view.visible) {                chain += view            }            view = view.parent        }        // Sinking        chain.asReversed().forEach {            val newEvent = event.with(source = it)            when (newEvent.type) {                Move, Drag -> it.filterMouseMotionEvent_(newEvent)                else       -> it.filterMouseEvent_      (newEvent)            }            if (newEvent.consumed) {                return            }        }        // Floating        chain.forEach {            val newEvent = event.with(source = it)            when (newEvent.type) {                Move, Drag -> it.handleMouseMotionEvent_(newEvent)                else       -> it.handleMouseEvent_      (newEvent)            }            if (newEvent.consumed) {                return            }        }    }    private fun registerCursorListeners(view: View) {        var value: View? = view        while (value != null) {            value.cursorChanged += viewCursorChanged            if (value.cursor != null) {                break            } else {                value = value.parent            }        }    }    private fun unregisterCursorListeners(view: View) {        var value: View? = view        while (value != null) {            value.cursorChanged -= viewCursorChanged            value = value.parent        }    }    private fun cursor(of: View?) = when (display.cursor) {        null -> of?.cursor        else -> display.cursor    }    private fun view(from: SystemPointerEvent): View? {        var view = viewFinder.find(from.location)        return view?.let {            if (from.nativeScrollPanel) {                while(view != null && view !is ScrollPanel) {                    view = view?.parent                }            }            view        }    }    private fun createMouseEvent(event: SystemMouseEvent, target: View, type: Type = event.type) = MouseEvent(            target,            target,            type,            target.fromAbsolute(event.location),            event.buttons,            event.clickCount,            event.modifiers)}