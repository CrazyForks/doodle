"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[6708],{8751:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>w,contentTitle:()=>m,default:()=>j,frontMatter:()=>y,metadata:()=>g,toc:()=>x});var o=i(7624),t=i(4552),a=i(7793),s=i(6236),r=i(5272),l=i(7492),d=i(3220);const c="import io.nacular.doodle.core.container\nimport io.nacular.doodle.layout.HorizontalFlowLayout\n\nfun horizontalLayout() {\n//sampleStart\n    val container = container {}\n\n    container.layout = HorizontalFlowLayout() // Container exposes its layout\n//sampleEnd\n}",u="import io.nacular.doodle.core.Layout\nimport io.nacular.doodle.core.Layout.Companion.simpleLayout\nimport io.nacular.doodle.core.PositionableContainer\nimport io.nacular.doodle.geometry.Rectangle\n\nfun example() {\n//sampleStart\n    class CustomLayout: Layout {\n        override fun layout(container: PositionableContainer) {\n            container.children.filter { it.visible }.forEach { child ->\n                child.bounds = Rectangle(/*...*/)\n            }\n        }\n    }\n\n    // DSL for basic layout\n    simpleLayout { container ->\n        container.children.filter { it.visible }.forEach { child ->\n            child.bounds = Rectangle(/*...*/)\n        }\n    }\n//sampleEnd\n}\n",h="\nimport io.nacular.doodle.core.Layout.Companion.simpleLayout\nimport io.nacular.doodle.core.container\nimport io.nacular.doodle.docs.utils.BlueView\nimport io.nacular.doodle.drawing.Color.Companion.Lightgray\nimport io.nacular.doodle.drawing.lighter\nimport io.nacular.doodle.drawing.rect\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.utils.Resizer\n\nfun unresponsiveLayout() {\n//sampleStart\n    container {\n        repeat(2) {\n            this += BlueView().apply { size = Size(50) }\n        }\n\n        // This Layout does not override\n        // requiresLayout(\n        //     child: Positionable,\n        //     of   : PositionableContainer,\n        //     old  : SizePreferences,\n        //     new  : SizePreferences\n        // ): Boolean\n        // Which means it defaults to ignoring changes to child SizePreferences\n        layout = simpleLayout { container ->\n            var x = 0.0\n            container.children.forEach {\n                it.x = x\n                x += (it.idealSize?.width ?: it.width) + 1\n            }\n        }\n\n        size = Size(200)\n        render = {\n            rect(bounds.atOrigin, Lightgray.lighter())\n        }\n\n        Resizer(this)\n    }\n//sampleEnd\n}",p="import io.nacular.doodle.core.Layout\nimport io.nacular.doodle.core.Positionable\nimport io.nacular.doodle.core.PositionableContainer\nimport io.nacular.doodle.core.View.SizePreferences\nimport io.nacular.doodle.core.container\nimport io.nacular.doodle.docs.utils.BlueView\nimport io.nacular.doodle.drawing.Color.Companion.Lightgray\nimport io.nacular.doodle.drawing.lighter\nimport io.nacular.doodle.drawing.rect\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.utils.Resizer\n\nfun responsiveLayout(updateOnIdealChange: Boolean) {\n//sampleStart\n    container {\n        repeat(2) {\n            this += BlueView().apply { size = Size(50) }\n        }\n\n        layout = object: Layout {\n            // Request layout whenever a child's idealSize changes\n            // (and the updateOnIdealChange switch is tuned on)\n            override fun requiresLayout(\n                child: Positionable,\n                of   : PositionableContainer,\n                old  : SizePreferences,\n                new  : SizePreferences\n            ) = updateOnIdealChange && old.idealSize != new.idealSize\n\n            // This Layout is very unusual (b/c it is contrived) in that it does not depend\n            // on the container's size. So it ignores these changes.\n            override fun requiresLayout(container: PositionableContainer, old: Size, new: Size) = false\n\n            override fun layout(container: PositionableContainer) {\n                var x = 0.0\n                container.children.forEach {\n                    it.x = x\n                    x += (it.idealSize?.width ?: it.width) + 1\n                }\n            }\n        }\n\n        size   = Size(200)\n        render = {\n            rect(bounds.atOrigin, Lightgray.lighter())\n        }\n\n        Resizer(this)\n    }\n//sampleEnd\n}",y={title:"Using Layouts",hide_title:!0},m=void 0,g={id:"layouts/layouts",title:"Using Layouts",description:"Using Layouts",source:"@site/docs/layouts/layouts.mdx",sourceDirName:"layouts",slug:"/layouts/",permalink:"/doodle/docs/layouts/",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Using Layouts",hide_title:!0},sidebar:"tutorialSidebar",previous:{title:"Positioning",permalink:"/doodle/docs/layouts/overview"},next:{title:"Constraints",permalink:"/doodle/docs/layouts/constraints"}},w={},x=[{value:"Using Layouts",id:"using-layouts",level:2},{value:"Custom Layouts",id:"custom-layouts",level:2},{value:"When layout triggers",id:"when-layout-triggers",level:2}];function f(e){const n={admonition:"admonition",code:"code",h2:"h2",p:"p",...(0,t.M)(),...e.components};return d.m||v("api",!1),d.m.HorizontalFlowLayout||v("api.HorizontalFlowLayout",!0),d.m.Layout||v("api.Layout",!0),d.m.LayoutRequiresLayout||v("api.LayoutRequiresLayout",!0),d.m.PositionableContainer||v("api.PositionableContainer",!0),d.m.SizePreferences||v("api.SizePreferences",!0),d.m.View||v("api.View",!0),d.m.view||v("api.view",!1),d.m.view.bounds||v("api.view.bounds",!0),d.m.view.idealSize||v("api.view.idealSize",!0),d.m.view.layout||v("api.view.layout",!0),d.m.view.size||v("api.view.size",!0),d.m.view.transform||v("api.view.transform",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"using-layouts",children:"Using Layouts"}),"\n",(0,o.jsxs)(n.p,{children:["A ",(0,o.jsx)(d.m.Layout,{})," keeps track of a View and its children and automatically arranges the children as sizes change. This happens (by default) whenever View's ",(0,o.jsx)(d.m.view.size,{})," changes, or one of its children has its ",(0,o.jsx)(d.m.view.bounds,{})," change. The View class also ",(0,o.jsx)(n.code,{children:"protects"})," its ",(0,o.jsx)(d.m.view.layout,{})," property by default so it can encapsulate special handling if needed, but sub-classes are free to expose it."]}),"\n",(0,o.jsxs)(n.p,{children:["This examples shows the use of ",(0,o.jsxs)("p",{children:[(0,o.jsx)(d.m.HorizontalFlowLayout,{}),", which wraps a View's children from left to right within its bounds."]})]}),"\n",(0,o.jsx)(l.A,{children:c}),"\n",(0,o.jsx)(r.u,{functionName:"flowLayout",height:"400"}),"\n",(0,o.jsx)(n.admonition,{type:"caution",children:(0,o.jsxs)(n.p,{children:["Changes to a View's ",(0,o.jsx)(d.m.view.transform,{})," will not trigger layout."]})}),"\n",(0,o.jsx)(n.h2,{id:"custom-layouts",children:"Custom Layouts"}),"\n",(0,o.jsxs)(n.p,{children:["Doodle comes with several useful layouts, including one based on constraints. But you can easily create custom Layouts by implementing the ",(0,o.jsx)(d.m.Layout,{})," interface or using the ",(0,o.jsx)(n.code,{children:"simpleLayout"})," utility function."]}),"\n",(0,o.jsx)(l.A,{children:u}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)(d.m.Layout,{})," works with ",(0,o.jsx)(d.m.PositionableContainer,{})," instead of ",(0,o.jsx)(d.m.View,{})," directly because the latter does not expose its children by design."]})}),"\n",(0,o.jsx)(n.h2,{id:"when-layout-triggers",children:"When layout triggers"}),"\n",(0,o.jsxs)(n.p,{children:["Layouts are generally triggered whenever their container's size changes or a child of their container has a bounds change. But there are cases when this default behavior does not work as well. A good example is a ",(0,o.jsx)(n.code,{children:"Layout"})," that uses a child's ",(0,o.jsx)(d.m.view.idealSize,{})," in positioning. Such a ",(0,o.jsx)(n.code,{children:"Layout"})," won't be invoked when a child's ",(0,o.jsx)(d.m.view.idealSize,{})," changes, and will be out of date in some cases. The following demo shows this."]}),"\n",(0,o.jsxs)(a.c,{children:[(0,o.jsx)(s.c,{value:"Demo",children:(0,o.jsx)(r.u,{functionName:"layoutIdealIssue",height:"400"})}),(0,o.jsx)(s.c,{value:"Usage",children:(0,o.jsx)(l.A,{children:h})})]}),"\n",(0,o.jsxs)(n.admonition,{type:"info",children:[(0,o.jsxs)(n.p,{children:["Moving the slider changes the ideal width of the blue boxes. But the container isn't updated because the ",(0,o.jsx)(n.code,{children:"Layout"})," used does not indicate (via  ",(0,o.jsx)(d.m.LayoutRequiresLayout,{}),") it needs an updated when a View's ",(0,o.jsx)(d.m.SizePreferences,{})," change."]}),(0,o.jsx)(n.p,{children:"You can see that it is out of date by resizing the container after moving the slider."})]}),"\n",(0,o.jsxs)(n.p,{children:["This is why Doodle offers a ",(0,o.jsx)(d.m.Layout,{})," the chance to customize when they are invoked. In fact, Layouts are asked whether they want to respond to several potential triggers. These include ",(0,o.jsx)(d.m.view.size,{})," changes in the container, ",(0,o.jsx)(d.m.view.bounds,{})," and ",(0,o.jsx)(d.m.SizePreferences,{})," changes for children. The latter happens whenever ",(0,o.jsx)(n.code,{children:"minimumSize"})," or ",(0,o.jsx)(n.code,{children:"idealSize"})," are updated for a child. This way, a ",(0,o.jsx)(n.code,{children:"Layout"})," can fine tune what triggers it."]}),"\n",(0,o.jsxs)(n.p,{children:["The following shows how updating the ",(0,o.jsx)(n.code,{children:"Layout"})," so it replies to ",(0,o.jsx)(d.m.LayoutRequiresLayout,{})," for this scenario fixes the issue."]}),"\n",(0,o.jsxs)(a.c,{children:[(0,o.jsx)(s.c,{value:"Demo",children:(0,o.jsx)(r.u,{functionName:"layoutIdealIssue",args:"[true]",height:"400"})}),(0,o.jsx)(s.c,{value:"Usage",children:(0,o.jsx)(l.A,{children:p})})]}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["Notice that this ",(0,o.jsx)(n.code,{children:"Layout"})," will actually ignore changes to the container's ",(0,o.jsx)(n.code,{children:"size"}),"! Layouts are free to do that if the container's ",(0,o.jsx)(n.code,{children:"size"})," is irrelevant to the positioning of its children. This is very unlikely, but there might be cases where one dimension of ",(0,o.jsx)(n.code,{children:"size"}),", maybe ",(0,o.jsx)(n.code,{children:"width"})," or ",(0,o.jsx)(n.code,{children:"height"})," is irrelevant. In which case the ",(0,o.jsx)(n.code,{children:"Layout"})," can ignore updates if only that component changes."]})})]})}function j(e={}){const{wrapper:n}={...(0,t.M)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(f,{...e})}):f(e)}function v(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);