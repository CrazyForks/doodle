"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[921],{7691:(e,n,t)=>{t.d(n,{ZP:()=>s});var i=t(7462),o=(t(7294),t(3905)),r=(t(8209),t(4866),t(5162),t(1912));const a={toc:[]},l="wrapper";function s(e){let{components:n,...t}=e;return(0,o.kt)(l,(0,i.Z)({},a,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("admonition",{title:"Module Required",type:"info"},(0,o.kt)("p",null,"You must include the ",t.link," in your application in order to use these features."),(0,o.kt)(r.O,{mdxType:"KPlayground"},t.module),(0,o.kt)("p",{parentName:"admonition"},"Doodle uses opt-in modules like this to improve bundle size.")))}s.isMDXComponent=!0},6975:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>y,contentTitle:()=>w,default:()=>T,frontMatter:()=>g,metadata:()=>f,toc:()=>b});var i=t(7462),o=(t(7294),t(3905)),r=(t(8209),t(4866)),a=t(5162),l=t(4903),s=t(1912),p=t(1166),d=t(7691);const u="package pointerinput\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.application.Modules.Companion.PointerModule\nimport io.nacular.doodle.application.application\nimport io.nacular.doodle.core.Display\nimport org.kodein.di.instance\nimport rendering.MyApp\n\n//sampleStart\nfun main() {\n    /** Include [PointerModule] when launching your app */\n    application(modules = listOf(PointerModule)) {\n        MyApp(instance())\n    }\n}\n\n/**\n * Pointer events will fire for this app when launched with [PointerModule]\n */\nclass MyApp(display: Display): Application {\n    override fun shutdown() {}\n}\n//sampleEnd",c="package pointerinput\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.event.PointerListener.Companion.pressed\n\nfun filter(view: View) {\n//sampleStart\n    view.pointerFilter += pressed { event ->\n        // called whenever a pointer is pressed on this\n        // View or its children, before the target child\n        // is notified\n    }\n//sampleEnd\n}\n",m="package pointerinput\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.event.PointerListener.Companion.pressed\n\nfun consume(view: View) {\n//sampleStart\n    view.pointerChanged += pressed { event ->\n        // ... take action based on event\n\n        event.consume() // indicate that no other listeners should be notified\n    }\n//sampleEnd\n}\n",h="package io.nacular.doodle.docs.utils\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.renderProperty\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color.Companion.Red\nimport io.nacular.doodle.drawing.circle\nimport io.nacular.doodle.drawing.opacity\nimport io.nacular.doodle.event.PointerListener\nimport io.nacular.doodle.geometry.Circle\nimport io.nacular.doodle.geometry.Point\n\n//sampleStart\n/**\n * This view renders a circle and provides precise hit detection for it.\n */\nclass CircularView(radius: Double): View() {\n    private val circle      = Circle(Point(radius, radius), radius)\n    private var pointerOver by renderProperty(false)\n\n    init {\n        size = circle.boundingRectangle.size\n\n        pointerChanged += PointerListener.on(\n            entered = { pointerOver = true  },\n            exited  = { pointerOver = false }\n        )\n    }\n\n    override fun intersects(point: Point) = point - position in circle\n\n    override fun render(canvas: Canvas) {\n        canvas.circle(circle, color = if (pointerOver) Red opacity 0.5f else Red)\n    }\n}\n//sampleEnd",v="package io.nacular.doodle.docs.utils\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.renderProperty\nimport io.nacular.doodle.drawing.AffineTransform.Companion.Identity\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.event.PointerListener\nimport io.nacular.doodle.geometry.ConvexPolygon\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.reversed\nimport io.nacular.doodle.geometry.toPath\n\n//sampleStart\n/**\n * This view renders a triangular shape and provides precise hit detection for it.\n */\nclass TriangleView: View() {\n    private val outerPoly get() = ConvexPolygon(Point(width / 2), Point(width, height), Point(0, height))\n    private val innerPoly get() = Identity.scale(\n        around = Point(width / 2, height * 2 / 3),\n        x      = 0.5,\n        y      = 0.5\n    ).invoke(outerPoly.reversed())\n\n    private var pointerOver by renderProperty(false)\n\n    init {\n        pointerChanged += PointerListener.on(\n            entered = { pointerOver = true  },\n            exited  = { pointerOver = false }\n        )\n    }\n\n    /**\n     * Override [intersects] this instead of [contains] to get [point]\n     * that is mapped to this view's plane, where intersection logic is\n     * much simpler.\n     */\n    override fun intersects(point: Point) = (point - position).let {\n        it in outerPoly && it !in innerPoly\n    }\n\n    override fun render(canvas: Canvas) {\n        canvas.path(\n            path = outerPoly.toPath() + innerPoly.toPath(),\n            fill = if (pointerOver) Black.paint else White.paint\n        )\n    }\n}\n//sampleEnd",k="package pointerinput\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.event.PointerEvent\nimport io.nacular.doodle.event.PointerListener\nimport io.nacular.doodle.event.PointerListener.Companion.on\nimport io.nacular.doodle.event.PointerListener.Companion.pressed\n\nfun example(view: View) {\n//sampleStart\n    // Listen to pressed/exit via interface override\n    view.pointerChanged += object: PointerListener {\n        override fun pressed(event: PointerEvent) {\n            // ..\n        }\n\n        override fun exited(event: PointerEvent) {\n            // ..\n        }\n    }\n\n    // Listener to pressed via DSL\n    view.pointerChanged += pressed { event -> /* .. */ }\n\n    // Listen to pressed/exit via DSL\n    view.pointerChanged += on(\n        pressed = { event -> /* .. */ },\n        exited  = { event -> /* .. */ },\n    )\n//sampleEnd\n}",g={title:"Overview"},w="Pointer Input",f={unversionedId:"pointer_input/overview",id:"pointer_input/overview",title:"Overview",description:"Pointer handling is easy with Doodle; simply include the  when launching your app, and the underlying framework uses it to produce key events.",source:"@site/docs/pointer_input/overview.mdx",sourceDirName:"pointer_input",slug:"/pointer_input/overview",permalink:"/doodle/docs/pointer_input/overview",draft:!1,tags:[],version:"current",frontMatter:{title:"Overview"},sidebar:"tutorialSidebar",previous:{title:"Transforms",permalink:"/doodle/docs/transforms"},next:{title:"Pointer Motion Events",permalink:"/doodle/docs/pointer_input/pointermotion"}},y={},b=[{value:"Hit Detection",id:"hit-detection",level:2},{value:"Support For Transforms",id:"support-for-transforms",level:3},{value:"Pointer Listeners",id:"pointer-listeners",level:2},{value:"Pointer Event",id:"pointer-event",level:2},{value:"Event Bubbling",id:"event-bubbling",level:2},{value:"Event Filtering",id:"event-filtering",level:2}],P={toc:b},C="wrapper";function T(e){let{components:n,...t}=e;return(0,o.kt)(C,(0,i.Z)({},P,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"pointer-input"},"Pointer Input"),(0,o.kt)("p",null,"Pointer handling is easy with Doodle; simply include the ",(0,o.kt)(p.j4V,null)," when launching your app, and the underlying framework uses it to produce key events."),(0,o.kt)(d.ZP,{link:(0,o.kt)(p.j4V,null),module:u,mdxType:"ModuleRequired"}),(0,o.kt)("h2",{id:"hit-detection"},"Hit Detection"),(0,o.kt)("p",null,"The framework relies on the ",(0,o.kt)("inlineCode",{parentName:"p"},"View")," ",(0,o.kt)(p.TMK,null)," method to determine when the pointer is within a ",(0,o.kt)("inlineCode",{parentName:"p"},"View"),"'s boundaries. This method gets a point in the ",(0,o.kt)("strong",{parentName:"p"},"view's parent reference frame")," (or the ",(0,o.kt)("a",{parentName:"p",href:"/doodle/docs/display/overview#the-display-is-an-apps-root-container"},(0,o.kt)("strong",{parentName:"a"},"Display")),"'s for top-level Views)) and returns whether or not that point intersects the view. The default implementation just checks the point against ",(0,o.kt)(p.fzW,null)," and accounts for the view's ",(0,o.kt)(p.X8Q,null),"."),(0,o.kt)(r.Z,{mdxType:"Tabs"},(0,o.kt)(a.Z,{value:"Demo",mdxType:"TabItem"},(0,o.kt)(l.l,{functionName:"hitDetection",height:"250",mdxType:"DoodleApp"})),(0,o.kt)(a.Z,{value:"Code",mdxType:"TabItem"},(0,o.kt)(s.O,{mdxType:"KPlayground"},h))),(0,o.kt)("h3",{id:"support-for-transforms"},"Support For Transforms"),(0,o.kt)("p",null,"Doodle also accounts for transformations applied to the ",(0,o.kt)("inlineCode",{parentName:"p"},"View"),"'s ancestors when delivering pointer events. This means the ",(0,o.kt)("inlineCode",{parentName:"p"},"View")," will receive the right notification whenever the pointer intersects its parent despite transformations. Hit detection logic in the ",(0,o.kt)("inlineCode",{parentName:"p"},"View")," is then triggered as usual. The ",(0,o.kt)("inlineCode",{parentName:"p"},"View")," still needs to take its own transformation into account though, since the given point used in hit detection is within the parent coordinate space. This is automatically handled if the ",(0,o.kt)("inlineCode",{parentName:"p"},"View")," implements ",(0,o.kt)(p.pvh,null)," or if ",(0,o.kt)(p.TRm,null)," is used when overriding ",(0,o.kt)(p.TMK,null),"."),(0,o.kt)(r.Z,{mdxType:"Tabs"},(0,o.kt)(a.Z,{value:"Demo",mdxType:"TabItem"},(0,o.kt)(l.l,{functionName:"hitDetectionTransform",height:"500",mdxType:"DoodleApp"})),(0,o.kt)(a.Z,{value:"Code",mdxType:"TabItem"},(0,o.kt)(s.O,{mdxType:"KPlayground"},v))),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Override ",(0,o.kt)(p.pvh,null)," instead of ",(0,o.kt)(p.TMK,null)," unless you want to factor in the view's transform into your hit detection logic.")),(0,o.kt)("h2",{id:"pointer-listeners"},"Pointer Listeners"),(0,o.kt)("p",null,"Views are able to receive pointer events once the ",(0,o.kt)(p.j4V,null)," is loaded, they are ",(0,o.kt)(p.D$9,null)," and ",(0,o.kt)(p.tmC,null),". You can then attach a ",(0,o.kt)(p.aLQ,null)," to any ",(0,o.kt)("inlineCode",{parentName:"p"},"View"),"'s ",(0,o.kt)(p.uTz,null)," property and get notified whenever a pointer does one of the following:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Enters")," the View"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Pressed")," within the View"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Released")," within the View"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Clicked")," (Pressed then Released) within the View"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Exits")," the View")),(0,o.kt)(s.O,{mdxType:"KPlayground"},k),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)(p.aLQ,null)," has no-op defaults for each event, so you only need to implement the ones you need."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Notice that ",(0,o.kt)("inlineCode",{parentName:"p"},"pointerChanged"),"--like other observable properties--supports many observers and enables you to add/remove an observer any time.")),(0,o.kt)("h2",{id:"pointer-event"},"Pointer Event"),(0,o.kt)("p",null,"The event provided to ",(0,o.kt)(p.aLQ,null),"s carries information about the ",(0,o.kt)("inlineCode",{parentName:"p"},"View")," it originated from (",(0,o.kt)(p.gRs,null),"), the ",(0,o.kt)("inlineCode",{parentName:"p"},"View")," it is sent to (",(0,o.kt)(p.niG,null),"), various attributes about the state of the pointers--like buttons pressed--and their locations relative to the target ",(0,o.kt)("inlineCode",{parentName:"p"},"View"),"."),(0,o.kt)("p",null,"Pointer events are ",(0,o.kt)("strong",{parentName:"p"},"consumable"),". This means any observer can call ",(0,o.kt)(p.Lop,null)," on an event and prevent subsequent listeners from receiving it."),(0,o.kt)(s.O,{mdxType:"KPlayground"},m),(0,o.kt)("h2",{id:"event-bubbling"},"Event Bubbling"),(0,o.kt)("p",null,'Pointer events "bubble" up to ancestors of a ',(0,o.kt)("inlineCode",{parentName:"p"},"View"),". Events sent to a ",(0,o.kt)("inlineCode",{parentName:"p"},"View")," will also be sent up to its parent and so on. This means you can listen to all events that happen to the descendants of a ",(0,o.kt)("inlineCode",{parentName:"p"},"View"),"."),(0,o.kt)("p",null,"The event sent to a parent is slightly different from the one sent to the ",(0,o.kt)("inlineCode",{parentName:"p"},"View"),". These events continue to have the same ",(0,o.kt)(p.gRs,null)," (descendant ",(0,o.kt)("inlineCode",{parentName:"p"},"View")," where the event fired), but their ",(0,o.kt)(p.niG,null)," changes to the recipient ancestor as they bubble."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Bubbling is canceled if any listener calls ",(0,o.kt)(p.Lop,null),".")),(0,o.kt)("h2",{id:"event-filtering"},"Event Filtering"),(0,o.kt)("p",null,'Pointer events also "sink" from ancestors down to their target. The first phase of pointer event handling is the "sink" phase. It runs ',(0,o.kt)("strong",{parentName:"p"},"before"),' the "bubbling" phase. The root ancestor and all descendants toward the ',(0,o.kt)(p.gRs,null)," ",(0,o.kt)("inlineCode",{parentName:"p"},"View")," are notified of the event before the target is."),(0,o.kt)("p",null,'The filter phase is like the "bubbling" phase in reverse. Like with bubbling, ',(0,o.kt)(p.aLQ,null),' is used to handle the event. Unlike "bubbling", registration happens via the ',(0,o.kt)(p.Vxu,null),' property. This phase lets ancestors "veto" an event before it reaches the intended target.'),(0,o.kt)(s.O,{mdxType:"KPlayground"},c),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Calling ",(0,o.kt)(p.Lop,null)," during filter will prevent descendants (and the target) from receiving the event")))}T.isMDXComponent=!0}}]);