"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[5720],{9880:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>m,contentTitle:()=>w,default:()=>x,frontMatter:()=>p,metadata:()=>u,toc:()=>v});var t=i(7624),a=i(2172),r=i(7996),o=i(5720),l=i(3148);const s="package applications\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.view\n\n//sampleStart\nclass MyApp(display: Display): Application {\n    init {\n        display += view {}\n    }\n    // ...\n\n    override fun shutdown() { /*...*/ }\n}\n//sampleEnd",d='import io.nacular.doodle.core.View\nimport io.nacular.doodle.core.renderProperty\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.TextMetrics\nimport io.nacular.doodle.drawing.text\nimport io.nacular.doodle.geometry.Point\n\n//sampleStart\nclass UserInfo(textMetrics: TextMetrics, name: String, age: Int): View() {\n    var name by renderProperty(name) // causes repaint whenever changed\n    var age  by renderProperty(age )\n    private val nameHeight = textMetrics.height(name)\n\n    override fun render(canvas: Canvas) {\n        canvas.text("name: $name", color = Black)\n        canvas.text("age : $age", at = Point(y = nameHeight), color = Black)\n    }\n}\n//sampleEnd',c="import io.nacular.doodle.core.View\nimport io.nacular.doodle.core.view\n\n//sampleStart\nclass VSplitPanel: View() {\n    var left: View? = null\n        set(new) {\n            if (new == field) { return }\n\n            field?.let { children -= it }\n            field = new\n            field?.let { children += it }\n\n            // notify of change\n        }\n\n    val right: View? = null\n    // ...\n\n    private val handle = view {} // private View for splitter\n\n    init {\n        children += handle // add handle to children\n    }\n\n    // ...\n}\n//sampleEnd",h="package viewcreation\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.view\n\n//sampleStart\nclass MyView: View() {\n    // ...\n}\n\nval view1 = object: View() {\n    // ...\n}\n\nval view2 = view {\n    // ...\n}\n//sampleEnd",p={hide_title:!0,title:"Views"},w=void 0,u={id:"views",title:"Views",description:"App building blocks",source:"@site/docs/views.mdx",sourceDirName:".",slug:"/views",permalink:"/doodle/docs/views",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{hide_title:!0,title:"Views"},sidebar:"tutorialSidebar",previous:{title:"Applications",permalink:"/doodle/docs/applications"},next:{title:"Displays",permalink:"/doodle/docs/display"}},m={},v=[{value:"App building blocks",id:"app-building-blocks",level:2},{value:"State and rendering",id:"state-and-rendering",level:2},{value:"View hierarchies",id:"view-hierarchies",level:2}];function g(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",...(0,a.M)(),...e.components};return l||y("api",!1),l.View||y("api.View",!0),l.ViewChildren||y("api.ViewChildren",!0),l.ViewDsl||y("api.ViewDsl",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"app-building-blocks",children:"App building blocks"}),"\n",(0,t.jsxs)(n.p,{children:["Views are the building blocks of Doodle apps. They encapsulate state, display content on the screen and respond to user input. Apps typically contain many ",(0,t.jsx)(n.code,{children:"View"})," instances at runtime. And they often use a wide range of ",(0,t.jsx)(n.code,{children:"View"})," types that provide specialized rendering and user interactions."]}),"\n",(0,t.jsxs)(n.p,{children:["You create a new ",(0,t.jsx)(n.code,{children:"View"})," by extending the ",(0,t.jsx)(l.View,{})," base class, instantiating an inline object directly or through the ",(0,t.jsx)(l.ViewDsl,{})," DSL."]}),"\n",(0,t.jsx)(o.A,{children:h}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["You will see how to get your ",(0,t.jsx)(n.code,{children:"View"}),"s onto the screen when we discuss the ",(0,t.jsx)(n.a,{href:"/doodle/docs/display",children:"Display"}),"."]})}),"\n",(0,t.jsx)(n.h2,{id:"state-and-rendering",children:"State and rendering"}),"\n",(0,t.jsxs)(n.p,{children:["Below is an example of a ",(0,t.jsx)(l.View,{})," that holds some user data (name and age). It tracks this state and repaints itself whenever any of these properties is changed. This is done using ",(0,t.jsx)(n.code,{children:"renderProperty"}),", which automatically triggers ",(0,t.jsx)(n.code,{children:"render"})," on any value change."]}),"\n",(0,t.jsxs)(n.p,{children:["Notice the ",(0,t.jsx)(n.code,{children:"render"})," method in this class. It is responsible for all paint operations for a View, and it gets called whenever a View should be repainted. There are a number of reasons why ",(0,t.jsx)(n.code,{children:"render"})," can be called, including: the first time a View is displayed, any time its ",(0,t.jsx)(n.code,{children:"size"})," changes, or if there is an explicit call to ",(0,t.jsx)(n.code,{children:"View.rerender()"}),"."]}),"\n",(0,t.jsx)(r.u,{functionName:"userInfo",height:"120"}),"\n",(0,t.jsx)(o.A,{children:d}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["Learn more about ",(0,t.jsx)(n.a,{href:"/doodle/docs/rendering/overview",children:"rendering"}),"."]})}),"\n",(0,t.jsx)(n.h2,{id:"view-hierarchies",children:"View hierarchies"}),"\n",(0,t.jsxs)(n.p,{children:["Apps generally have one or more top-level View with other Views nested in them. Doodle allow you to do the same. You specify which Views will represent your top-level items and add them to the ",(0,t.jsx)(n.a,{href:"/doodle/docs/display",children:"Display"}),". These Views in turn will typically have nested Views that are either dynamically added, or part of the internal representation of their parent."]}),"\n",(0,t.jsx)(o.A,{children:s}),"\n",(0,t.jsxs)(n.p,{children:["All Views support nested ",(0,t.jsx)(l.ViewChildren,{}),". However, they ",(0,t.jsx)(n.code,{children:"protect"})," that list--and other traits related to being a container--by default, to improve encapsulation and API control."]}),"\n",(0,t.jsxs)(n.p,{children:["Consider a split panel. It is reasonable to think about it as having a left and right child (ignoring orientation for now). However, an implementation of this concept might choose to have an additional child to represent the splitter. This choice is an internal detail of the implementation that would be leaked if the ",(0,t.jsx)(n.code,{children:"children"})," list were public. Worse, a caller could remove the splitter or add more children than expected and break the behavior."]}),"\n",(0,t.jsx)(n.p,{children:"Doodle helps with these design challenges by letting you selectively expose a View's internals to callers."}),"\n",(0,t.jsx)(o.A,{children:c}),"\n",(0,t.jsxs)(n.p,{children:["This design prevents direct access to the panel's ",(0,t.jsx)(n.code,{children:"children"}),", which side-steps many issues. It also presents are more intuitive and reliable API. ",(0,t.jsx)(n.code,{children:"left"})," and ",(0,t.jsx)(n.code,{children:"right"})," are fairly self-documenting compared to ",(0,t.jsx)(n.code,{children:"children[n]"})," and ",(0,t.jsx)(n.code,{children:"children[m]"}),". Moreover, the panel is able to encapsulate the fact that it uses additional Views for presentation."]})]})}function x(e={}){const{wrapper:n}={...(0,a.M)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(g,{...e})}):g(e)}function y(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);