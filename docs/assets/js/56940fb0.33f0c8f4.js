"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[5088],{4682:(e,i,o)=>{o.r(i),o.d(i,{assets:()=>w,contentTitle:()=>h,default:()=>u,frontMatter:()=>c,metadata:()=>p,toc:()=>m});var n=o(7624),s=o(4552),t=(o(7793),o(6236),o(5272)),r=o(7492),a=o(3220);const d="\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.geometry.Point\n\nfun positioning(display: Display) {\n//sampleStart\n    val view  = view {}\n    val panel = view {}\n\n    view.x        = 10.0          // move to       [10, 0]\n    view.position = Point(13, -2) // reposition to [13,-2]\n\n    display += panel              // panel's position is 0,0\n//sampleEnd\n}",l="import io.nacular.doodle.core.View\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.utils.Resizer\n\nfun resizer(view: View) {\n//sampleStart\n    view.apply {\n        bounds = Rectangle(100, 100)\n        Resizer(this) // monitors the View and manages resize/move\n    }\n//sampleEnd\n}",c={title:"Positioning",hide_title:!0},h=void 0,p={id:"layouts/overview",title:"Positioning",description:"Positioning Views",source:"@site/docs/layouts/overview.mdx",sourceDirName:"layouts",slug:"/layouts/overview",permalink:"/doodle/docs/layouts/overview",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Positioning",hide_title:!0},sidebar:"tutorialSidebar",previous:{title:"Behaviors",permalink:"/doodle/docs/rendering/behaviors"},next:{title:"Using Layouts",permalink:"/doodle/docs/layouts/"}},w={},m=[{value:"Positioning Views",id:"positioning-views",level:2},{value:"Transform views",id:"transform-views",level:2}];function v(e){const i={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",...(0,s.M)(),...e.components};return a.m||x("api",!1),a.m.Identity||x("api.Identity",!0),a.m.Resizer||x("api.Resizer",!0),a.m.view||x("api.view",!1),a.m.view.boundingBox||x("api.view.boundingBox",!0),a.m.view.bounds||x("api.view.bounds",!0),a.m.view.position||x("api.view.position",!0),a.m.view.transform||x("api.view.transform",!0),a.m.view.x||x("api.view.x",!0),a.m.view.y||x("api.view.y",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.h2,{id:"positioning-views",children:"Positioning Views"}),"\n",(0,n.jsxs)(i.p,{children:["Every View has an ",(0,n.jsx)(a.m.view.x,{}),", ",(0,n.jsx)(a.m.view.y,{})," position (in pixels) relative to its parent. This is exactly where the View will be rendered--unless it (or an ancestor) also has a ",(0,n.jsx)(a.m.view.transform,{}),". Doodle ensures that there is never a disconnect between a View's ",(0,n.jsx)(a.m.view.position,{}),", ",(0,n.jsx)(a.m.view.transform,{})," and render coordinates."]}),"\n",(0,n.jsxs)(i.p,{children:["You can set a View's ",(0,n.jsx)(a.m.view.x,{}),", ",(0,n.jsx)(a.m.view.y,{}),", or ",(0,n.jsx)(a.m.view.position,{})," directly to move it around. These are proxies to the View's ",(0,n.jsx)(a.m.view.bounds,{}),", which represents its rectangular boundary relative to its parent. By default a View's position is set to ",(0,n.jsx)(i.code,{children:"0,0"}),", and it will only change if set explicitly or via a ",(0,n.jsx)(i.a,{href:"/doodle/docs/layouts/",children:"Layout"}),"."]}),"\n",(0,n.jsx)(r.A,{children:d}),"\n",(0,n.jsxs)(i.p,{children:["This demo shows how the pointer can be used to position Views easily. In this case, we use the ",(0,n.jsx)(a.m.Resizer,{})," utility to provide simple resize/move operations. The Resizer simply monitors the View for Pointer events and updates its ",(0,n.jsx)(i.code,{children:"bounds"})," accordingly."]}),"\n",(0,n.jsx)(r.A,{children:l}),"\n",(0,n.jsx)(t.u,{functionName:"positioning",height:"400"}),"\n",(0,n.jsx)(i.h2,{id:"transform-views",children:"Transform views"}),"\n",(0,n.jsxs)(i.p,{children:["You can change the shape of a View using a linear ",(0,n.jsx)(i.a,{href:"/doodle/docs/transforms",children:"transform"}),". This will change the way the View is rendered to the screen, and can even change the size of the View. But a transformed View still retains the same ",(0,n.jsx)(a.m.view.bounds,{}),", while its ",(0,n.jsx)(a.m.view.boundingBox,{})," changes with the transform. This means layouts will continue to treat the View as though nothing about it changed."]}),"\n",(0,n.jsx)(i.p,{children:"Hit detection and other behavior also works as expected for Views that have been transformed."}),"\n",(0,n.jsx)(t.u,{functionName:"transforms",height:"400"}),"\n",(0,n.jsx)(i.admonition,{type:"tip",children:(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"boundingBox"})," == ",(0,n.jsx)(i.code,{children:"bounds"})," when ",(0,n.jsx)(a.m.view.transform,{})," == ",(0,n.jsx)(a.m.Identity,{}),"."]})})]})}function u(e={}){const{wrapper:i}={...(0,s.M)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(v,{...e})}):v(e)}function x(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);