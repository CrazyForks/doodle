"use strict";(self.webpackChunkdoodle_docs=self.webpackChunkdoodle_docs||[]).push([[3444],{1487:(n,e,o)=>{o.d(e,{A:()=>i});const i='package display\n\nimport io.nacular.doodle.controls.popupmenu.MenuBehavior.ItemInfo\nimport io.nacular.doodle.core.Icon\nimport io.nacular.doodle.core.Window\n\nfun example(window: Window, icon1: Icon<ItemInfo>, icon2: Icon<ItemInfo>) {\n//sampleStart\n    window.menuBar {\n        menu("Menu 1") {\n            action("Do action 2", icon1) { /*..*/ }\n            menu("Sub menu") {\n                action("Do action sub", icon = icon2) { /*..*/ }\n                separator()\n                prompt("Some Prompt sub") { /*..*/ }\n            }\n            separator()\n            prompt("Some Prompt") { /*..*/ }\n        }\n\n        menu("Menu 2") {\n            // ...\n        }\n    }\n//sampleEnd\n}'},1775:(n,e,o)=>{o.d(e,{A:()=>i});const i='import io.nacular.doodle.controls.text.Label\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.layout.constraints.fill\n\nfun labelFitText() {\n//sampleStart\n    view {\n        + Label("Hello") // Label fits its text by default\n\n        layout = constrain(children.first(), fill) // \u274c Label would ignore layout\n    }\n//sampleEnd\n}'},2315:(n,e,o)=>{o.d(e,{A:()=>i});const i="package elementview\n\nimport io.nacular.doodle.HtmlElementViewFactory\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.application.HtmlElementViewModule\nimport io.nacular.doodle.application.Modules\nimport io.nacular.doodle.application.application\nimport io.nacular.doodle.core.Display\nimport org.kodein.di.instance\nimport org.w3c.dom.HTMLElement\n\nprivate class MyApp(\n    display    : Display,\n    viewFactory: HtmlElementViewFactory,\n    element    : HTMLElement\n): Application {\n    init {\n        display += viewFactory(element)\n    }\n\n    override fun shutdown() {}\n}\n\nfun main(element: HTMLElement) {\n//sampleStart\n    application(modules = listOf(Modules.HtmlElementViewModule)) {\n         MyApp(display = instance(), viewFactory = instance(), element = element)\n    }\n//sampleEnd\n}\n"},2341:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>I,contentTitle:()=>D,default:()=>N,frontMatter:()=>L,metadata:()=>i,toc:()=>R});const i=JSON.parse('{"id":"whatsnew","title":"Whats New \u2728","description":"0.11.0 \u2022 Mar 2025","source":"@site/docs/whatsnew.mdx","sourceDirName":".","slug":"/whatsnew","permalink":"/doodle/docs/whatsnew","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"hide_title":true,"title":"Whats New \u2728"},"sidebar":"tutorialSidebar","previous":{"title":"Hello Doodle","permalink":"/doodle/docs/introduction"},"next":{"title":"Migrating to 0.11.0","permalink":"/doodle/docs/migrating/0.10.x_0.11.0"}}');var t=o(4848),a=o(8453),r=o(5537),l=o(9329),s=o(7269),d=o(4069),c=o(7045),p=o(9172),u=o(8832),m=o(1487),h=o(6990),g=o(4240),w=o(2315);const v='package io.nacular.doodle.docs.apps\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.controls.buttons.PushButton\nimport io.nacular.doodle.controls.form.Always\nimport io.nacular.doodle.controls.form.Form\nimport io.nacular.doodle.controls.form.labeled\nimport io.nacular.doodle.controls.form.textField\nimport io.nacular.doodle.controls.form.verticalLayout\nimport io.nacular.doodle.controls.text.TextField\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.drawing.Font\nimport io.nacular.doodle.event.KeyCode.Companion.Enter\nimport io.nacular.doodle.event.KeyListener.Companion.pressed\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.theme.Theme\nimport io.nacular.doodle.theme.ThemeManager\nimport io.nacular.doodle.utils.Resizer\n\nclass EnterKeyInterceptApp(\n    display     : Display,\n    font        : Font,\n    themeManager: ThemeManager,\n    theme       : Theme\n): Application {\n    private lateinit var name    : TextField\n    private lateinit var password: TextField\n\n    private val submit = PushButton("Submit").apply {\n        this.font     = font\n        this.enabled  = false\n        this.fired   += {\n            // clear fields\n            name.text     = ""\n            password.text = ""\n        }\n\n        suggestSize(Size(100, 32))\n    }\n\n    private val form = Form { this (\n        + labeled("Name",     showRequired = Always()) { textField(Regex(".{3,}")) { name     = textField } },\n        + labeled("Password", showRequired = Always()) { textField(Regex(".{3,}")) { password = textField } },\n        onInvalid = { submit.enabled = false },\n    ) { _,_ ->\n        submit.enabled = true\n    } }.apply {\n        this.font      = font\n        this.layout    = verticalLayout(spacing = 12.0)\n        this.focusable = false\n\n        suggestSize(Size(300, 100))\n\n        Resizer(this, movable = false)\n    }\n\n    init {\n        themeManager.selected = theme\n\n//sampleStart\n        form.keyFilter += pressed {\n            if (it.code == Enter && submit.enabled) {\n                it.consume()\n                submit.click()\n            }\n        }\n//sampleEnd\n\n        display += listOf(form, submit)\n\n        display.layout = constrain(form, submit) { form_, submit_ ->\n            val spacing = 10\n\n            form_.size      eq form_.idealSize\n            form_.center    eq parent.center - Point(y = (spacing + submit_.height.readOnly) / 2)\n\n            submit_.top     eq form_.bottom + spacing\n            submit_.centerX eq form_.centerX\n        }\n    }\n\n    override fun shutdown() {}\n}';var y=o(8144);const f="package io.nacular.doodle.docs.apps\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.container\nimport io.nacular.doodle.core.renderProperty\nimport io.nacular.doodle.docs.utils.BlueColor\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.drawing.SweepGradientPaint\nimport io.nacular.doodle.drawing.opacity\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.event.PointerEvent\nimport io.nacular.doodle.event.PointerListener.Companion.entered\nimport io.nacular.doodle.event.PointerMotionListener.Companion.on\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.geometry.ringSection\nimport io.nacular.doodle.layout.constraints.center\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.layout.constraints.fill\nimport io.nacular.doodle.utils.lerp\nimport io.nacular.measured.units.Angle.Companion.degrees\nimport io.nacular.measured.units.times\nimport kotlin.math.max\nimport kotlin.math.min\n\nclass SweepGradientProgressApp(display: Display): Application {\n\n    private class Progress: View() {\n        var progress by renderProperty(1f)\n\n        private val thickness  =  50.0\n        private val startAngle =  20 * degrees\n        private val endAngle   = 360 * degrees\n\n        init {\n            clipCanvasToBounds = false\n        }\n\n        override fun render(canvas: Canvas) {\n            val center      = Point(width / 2, height / 2)\n            val outerRadius = min(center.x, center.y)\n\n//sampleStart\n            canvas.outerShadow(vertical = 10.0, blurRadius = 10.0, color = Black opacity 0.5f) {\n                path(\n                    ringSection(\n                        center      = center,\n                        innerRadius = max(0.0, outerRadius - thickness),\n                        outerRadius = outerRadius,\n                        start       = startAngle,\n                        end         = lerp(startAngle, endAngle, progress),\n                        endCap      = { _,it ->\n                            arcTo(it, radius = thickness / 2, largeArch = true, sweep = true)\n                        }\n                    ),\n                    SweepGradientPaint(\n                        color1      = BlueColor opacity 0f,\n                        color2      = BlueColor opacity 1f,\n                        center      = center,\n                        rotation    = startAngle\n                    )\n                )\n            }\n//sampleEnd\n        }\n    }\n\n    init {\n        display += container {\n            val bar = Progress().apply { suggestSize(Size(200)) }\n\n            +bar\n            layout = constrain(bar, center)\n\n            val updateProgress = { event: PointerEvent ->\n                bar.progress = (toLocal(event.location, event.target).x / width).toFloat()\n            }\n\n            pointerChanged += entered {\n                updateProgress(it)\n            }\n\n            pointerMotionChanged += on(\n                moved   = updateProgress,\n                dragged = updateProgress\n            )\n        }\n\n        display.layout = constrain(display.first(), fill)\n\n        display.fill(White.paint)\n    }\n\n    override fun shutdown() {}\n}";var x=o(9491);const b="package controls\n\nimport io.nacular.doodle.controls.range.Slider\nimport io.nacular.measured.units.Length.Companion.meters\nimport io.nacular.measured.units.Length.Companion.miles\nimport io.nacular.measured.units.Time.Companion.hours\nimport io.nacular.measured.units.Time.Companion.seconds\nimport io.nacular.measured.units.div\nimport io.nacular.measured.units.times\n\n//sampleStart\nval velocitySlider = Slider(10 * meters / seconds .. 100 * miles / hours)\n//sampleEnd",j="package controls\n\nimport io.nacular.doodle.controls.ConfinedValueModel\nimport io.nacular.doodle.controls.range.Slider\nimport io.nacular.doodle.utils.Interpolator\n\nfun <T: Comparable<T>> customSlider(model: ConfinedValueModel<T>, interpolator: Interpolator<T>) {\n//sampleStart\n    val slider: Slider<T> = Slider(model, interpolator = interpolator)\n//sampleEnd\n}",S="package controls\n\nimport io.nacular.doodle.controls.ConfinedValueModel\nimport io.nacular.doodle.controls.form.Form\nimport io.nacular.doodle.controls.form.slider\nimport io.nacular.doodle.utils.Interpolator\nimport io.nacular.measured.units.Length.Companion.meters\nimport io.nacular.measured.units.Length.Companion.miles\nimport io.nacular.measured.units.Measure\nimport io.nacular.measured.units.Time.Companion.hours\nimport io.nacular.measured.units.Time.Companion.seconds\nimport io.nacular.measured.units.Velocity\nimport io.nacular.measured.units.div\nimport io.nacular.measured.units.times\n\nfun <T: Comparable<T>> slidersInForm(model: ConfinedValueModel<T>, interpolator: Interpolator<T>) {\n//sampleStart\n    Form {this(\n        + slider('A' .. 'Z'),\n        + slider(10 * meters/seconds .. 10 * miles/hours),\n        + slider(model, interpolator = interpolator),\n        onInvalid = {}\n    ) { _: Char, _: Measure<Velocity>, _: T ->\n\n    }}\n//sampleEnd\n}",C="package controls\n\nimport io.nacular.doodle.controls.range.Slider\n\n//sampleStart\nval charSlider = Slider('A' .. 'Z')\n//sampleEnd";var k=o(8968);const A='package io.nacular.doodle.docs.apps\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.View.SizeAuditor.Companion.preserveAspect\nimport io.nacular.doodle.core.center\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.core.width\nimport io.nacular.doodle.drawing.AffineTransform.Companion.Identity\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.drawing.FrostedGlassPaint\nimport io.nacular.doodle.drawing.GradientPaint.Stop\nimport io.nacular.doodle.drawing.LinearGradientPaint\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.drawing.SweepGradientPaint\nimport io.nacular.doodle.drawing.TextMetrics\nimport io.nacular.doodle.drawing.opacity\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.geometry.Circle\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.Point.Companion.Origin\nimport io.nacular.doodle.geometry.ringSection\nimport io.nacular.doodle.geometry.star\nimport io.nacular.doodle.utils.Resizer\nimport io.nacular.measured.units.Angle.Companion.degrees\nimport io.nacular.measured.units.times\nimport kotlin.math.min\n\nclass GlassPaintApp(display: Display, textMetrics: TextMetrics): Application {\n    val inset          = 20\n    val cardRadius     = 20.0\n    val cardWidth      = min(display.width - 2 * inset, 340.0)\n    val cardNumber     = "1253 5432 3521 3090"\n    val cardHolder     = "John Smith"\n    val cardExpiry     = "Exp 02/29"\n    val cardAspect     = 1.586\n    val cardNumberSize = textMetrics.size(cardNumber)\n    val cardHolderSize = textMetrics.size(cardHolder)\n    val expirySize     = textMetrics.size(cardExpiry)\n    val starRadius     = 12.0\n    val starLogo       = star(Circle(radius = starRadius), points = 4)!!\n    val colors         = listOf(0xd278efu, 0x8dedd7u, 0xeecf87u, 0xd278efu).map { Color(it) }\n    val signalRadius   = 12.0\n\n    val drawLogo: Canvas.(Point) -> Unit = { point ->\n        translate(by = point) {\n            poly(\n                starLogo, fill = SweepGradientPaint(\n                    colors = colors.mapIndexed { index, color ->\n                        Stop(color, index * 1f / colors.size)\n                    },\n                    center = Point(starRadius, starRadius),\n                    rotation = 120 * (degrees)\n                )\n            )\n        }\n    }\n\n    val drawSignals: Canvas.(Point) -> Unit = { point ->\n        val thickness = 2.0\n        val gap       = 2.0\n\n        translate(by = point) {\n            repeat(3) {\n                val outerRadius = signalRadius - it * (thickness + gap)\n\n                path(\n                    ringSection(\n                        center = Origin,\n                        innerRadius = outerRadius - thickness,\n                        outerRadius = outerRadius,\n                        start = -45 * degrees,\n                        end = 45 * degrees,\n                        startCap = { _, it ->\n                            arcTo(it, radius = thickness / 2, largeArch = true, sweep = true)\n                        },\n                        endCap = { _, it ->\n                            arcTo(it, radius = thickness / 2, largeArch = true, sweep = true)\n                        }\n                    ),\n                    White.paint\n                )\n            }\n        }\n    }\n\n    init {\n        display += view {\n            render = {\n                val textScale   = (width - inset * 2) / cardNumberSize.width\n                val cardNumberY = height - textScale * cardNumberSize.height - 2 * inset - cardHolderSize.height\n                val cardHolderY = cardNumberY + textScale * cardNumberSize.height + inset\n\n                // Card background\n                rect(\n                    rectangle = bounds.atOrigin,\n                    radius    = cardRadius,\n                    fill      = SweepGradientPaint(\n                        colors = colors.mapIndexed { index, color ->\n                            Stop(color, index * 1f / colors.size)\n                        },\n                        center   = Point(width / 2.0, height / 2.0),\n                        rotation = 120 * (degrees)\n                    )\n                )\n\n                scale(around = Point(inset, cardNumberY), textScale, textScale) {\n                    text(cardNumber, at = Point(inset, cardNumberY), fill = White.paint)                        // Card Number\n                }\n\n                drawLogo(Point(2 * inset, 2 * inset))                                                           // Card Logo\n\n                text(cardHolder, at = Point(inset, cardHolderY                           ), fill = White.paint) // Cardholder Name\n                text(cardExpiry, at = Point(width - expirySize.width - inset, cardHolderY), fill = White.paint) // Expiry\n            }\n\n            // ensure aspect ratio\n            sizeAuditor = preserveAspect(cardAspect)\n\n            suggestWidth(cardWidth)\n            Resizer(this).apply { directions = emptySet() }\n\n            boundsChanged += { _,o,n ->\n                if (o.size != n.size) {\n                    // Center card once its size is updated\n                    suggestPosition(display.center - Point(n.width / 2, n.height / 2))\n                }\n            }\n        }\n\n        display += view {\n            val borderThickness = 2.0\n\n            render = {\n                val textScale   = (width - inset * 2) * 0.75 / cardNumberSize.width\n                val cardNumberY = inset\n                val cardHolderY = height - cardHolderSize.height - inset\n\n                // Card background\n//sampleStart\n                rect(\n                    rectangle = bounds.atOrigin.inset(borderThickness / 2),\n                    radius    = cardRadius,\n                    fill      = FrostedGlassPaint(Color(0x09008bu) opacity 0.2f, blurRadius = 10.0)\n                )\n//sampleEnd\n                // Card outline\n                rect(\n                    rectangle = bounds.atOrigin.inset(borderThickness / 2),\n                    radius    = cardRadius,\n                    stroke    = Stroke(\n                        fill = LinearGradientPaint(\n                            color1 = Color(0xf1d580u),\n                            color2 = Color(0x8780e5u),\n                            start  = Origin,\n                            end    = Point(width, height),\n                        ),\n                        thickness = borderThickness\n                    )\n                )\n\n                scale(around = Point(inset, cardNumberY), textScale, textScale) {\n                    text(cardNumber, at = Point(inset, cardNumberY), fill = White.paint)                                // Card Number\n                }\n\n                drawLogo   (Point(width - starRadius   - inset, cardHolderY - starRadius - inset                     )) // Card Logo\n                drawSignals(Point(width - signalRadius - inset, (cardNumberY + textScale * cardHolderSize.height / 2))) // Signal Logo\n\n                text(cardHolder, at = Point(inset, cardHolderY),                            fill = White.paint)         // Cardholder Name\n                text(cardExpiry, at = Point(width - expirySize.width - inset, cardHolderY), fill = White.paint)         // Expiry\n            }\n\n            sizeAuditor = preserveAspect(cardAspect)\n\n            suggestWidth(cardWidth)\n            Resizer(this).apply { directions = emptySet() }\n\n            boundsChanged += { _,o,n ->\n                if (o.size != n.size) {\n                    val newCenter = display.center + Point(n.height / 3, 0.0)\n\n                    // Center card once it\'s size is updated\n                    suggestPosition(newCenter - Point(n.width / 2, n.height / 2))\n\n                    // Rotate card\n                    transform = Identity.rotate(by = 45 * degrees, around = newCenter)\n                }\n            }\n        }\n\n        display.fill(Color(0x0e131fu).paint)\n    }\n\n    override fun shutdown() {}\n}',T='package rendering\n\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.Color.Companion.Transparent\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.geometry.Point.Companion.Origin\n\nfun outlinedText() {\n    view {\n//sampleStart\n        render = {\n            text(\n                text   = "Hello Doodle!",\n                at     = Origin,\n                fill   = Transparent.paint,\n                stroke = Stroke()\n            )\n        }\n//sampleEnd\n    }\n}',P='package rendering\n\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.geometry.Point.Companion.Origin\nimport io.nacular.doodle.text.invoke\nimport io.nacular.doodle.text.rangeTo\n\nfun outlinedStyledText(stroke: Stroke) {\n    view {\n//sampleStart\n        render = {\n            text(\n                text = "Hello " .. stroke { "Doodle!" },\n                at   = Origin,\n            )\n        }\n//sampleEnd\n    }\n}';var B=o(7157),F=o(1775),M=o(8726);const L={hide_title:!0,title:"Whats New \u2728"},D=void 0,I={},R=[{value:"0.11.0 \u2022 Mar 2025",id:"0110--mar-2025",level:2},{value:"New Layout System",id:"new-layout-system",level:3},{value:"Frosted Glass Paint",id:"frosted-glass-paint",level:3},{value:"Text Outlining",id:"text-outlining",level:3},{value:"Inline Constraints for Forms",id:"inline-constraints-for-forms",level:3},{value:"0.10.2 \u2022 June 2024",id:"0102--june-2024",level:2},{value:"Animation Chaining",id:"animation-chaining",level:3},{value:"Desktop Accessibility",id:"desktop-accessibility",level:3},{value:"SpinButton Accessibility",id:"spinbutton-accessibility",level:3},{value:"Improved Sliders",id:"improved-sliders",level:3},{value:"0.10.1 \u2022 May 2024",id:"0101--may-2024",level:2},{value:"Sweep Gradient Paint",id:"sweep-gradient-paint",level:3},{value:"0.10.0 \u2022 Feb 2024",id:"0100--feb-2024",level:2},{value:"Host arbitrary HTML elements (Browser)",id:"host-arbitrary-html-elements-browser",level:3},{value:"WASM JS (Browser)",id:"wasm-js-browser",level:3},{value:"Multi-window apps (Desktop)",id:"multi-window-apps-desktop",level:3},{value:"Native window menus (Desktop)",id:"native-window-menus-desktop",level:3},{value:"Native context menus",id:"native-context-menus",level:3},{value:"Key event filters and bubbling (All Platforms)",id:"key-event-filters-and-bubbling-all-platforms",level:3}];function z(n){const e={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return p.F||E("api",!1),p.F.AccessibilityModuleDesktop||E("api.AccessibilityModuleDesktop",!0),p.F.BasicCircularProgressIndicatorBehavior||E("api.BasicCircularProgressIndicatorBehavior",!0),p.F.BasicCircularRangeSliderBehavior||E("api.BasicCircularRangeSliderBehavior",!0),p.F.Layout||E("api.Layout",!0),p.F.SpinButtonRole||E("api.SpinButtonRole",!0),p.F.Stroke||E("api.Stroke",!0),p.F.StyledText||E("api.StyledText",!0),p.F.SweepGradientPaint||E("api.SweepGradientPaint",!0),p.F.View||E("api.View",!0),p.F.view||E("api.view",!1),p.F.view.keyChanged||E("api.view.keyChanged",!0),p.F.view.keyFilter||E("api.view.keyFilter",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.h2,{id:"0110--mar-2025",children:[(0,t.jsx)(e.a,{href:"https://github.com/nacular/doodle/releases/tag/v0.11.0",children:"0.11.0"})," \u2022 Mar 2025"]}),"\n",(0,t.jsx)(e.h3,{id:"new-layout-system",children:(0,t.jsx)(e.a,{href:"migrating/0.10.x_0.11.0#adjust-to-the-new-layout-paradigm",children:"New Layout System"})}),"\n",(0,t.jsxs)(e.p,{children:["A ",(0,t.jsx)(p.F.View,{}),"'s bounds is no longer editable directly as it was in previous versions of Doodle. This is a major change to the way Doodle layout functions; but it is important to avoid some major pitfalls of the previous approach. Namely, it was very easy to write code that would not produce the expected layout. This is a good example of something that would cause issues before:"]}),"\n",(0,t.jsx)(e.admonition,{title:"0.10.x",type:"note",children:(0,t.jsx)(d.v,{children:F.A})}),"\n",(0,t.jsxs)(e.p,{children:["Now it just works as expected since ",(0,t.jsx)(p.F.View,{}),"s cannot override the ",(0,t.jsx)(p.F.Layout,{})," they are managed by."]}),"\n",(0,t.jsx)(e.admonition,{title:"0.11.0",type:"tip",children:(0,t.jsx)(d.v,{children:M.A})}),"\n",(0,t.jsx)(e.h3,{id:"frosted-glass-paint",children:(0,t.jsx)(e.a,{href:"rendering#frosted-glass",children:"Frosted Glass Paint"})}),"\n",(0,t.jsxs)(e.p,{children:["New ",(0,t.jsx)(e.code,{children:"Paint"})," that lets you create glass like material that blurs the underlying content. This, like all paints, can be used to fill any shape, stroke, or text."]}),"\n",(0,t.jsx)(s.T,{functionName:"frostedGlass",height:"400"}),"\n",(0,t.jsxs)("div",{style:{fontSize:"10px",textAlign:"right",color:"gray"},children:["Inspired by ",(0,t.jsx)("a",{style:{color:"gray"},href:"https://dribbble.com/shots/21666321-Filly-Finance-Mobile-App",title:"Filly Finance Mobile App",children:"Mehmet \xd6zsoy"})]}),"\n",(0,t.jsx)(d.v,{children:A}),"\n",(0,t.jsx)(e.h3,{id:"text-outlining",children:"Text Outlining"}),"\n",(0,t.jsxs)(e.p,{children:["You can now outline text using ",(0,t.jsx)(p.F.Stroke,{}),"s like other shapes. This includes ",(0,t.jsx)(p.F.StyledText,{}),", which now supports strokes for styled segments."]}),"\n",(0,t.jsxs)(r.A,{children:[(0,t.jsxs)(l.A,{value:"Regular Text",children:[(0,t.jsx)(s.T,{functionName:"text",height:"300"}),(0,t.jsx)(d.v,{children:T})]}),(0,t.jsxs)(l.A,{value:"Styled Text",children:[(0,t.jsx)(s.T,{functionName:"outlinedStyledText",height:"300"}),(0,t.jsx)(d.v,{children:P})]})]}),"\n",(0,t.jsx)(e.h3,{id:"inline-constraints-for-forms",children:"Inline Constraints for Forms"}),"\n",(0,t.jsxs)(e.p,{children:["Forms have ",(0,t.jsx)(p.F.Layout,{}),"s that you can specify explicitly. But now you can also define constraint-based layouts declaratively when defining a Form."]}),"\n",(0,t.jsx)(s.T,{functionName:"formLayout",height:"300"}),"\n",(0,t.jsx)(d.v,{children:B.A}),"\n",(0,t.jsxs)(e.h2,{id:"0102--june-2024",children:[(0,t.jsx)(e.a,{href:"https://github.com/nacular/doodle/releases/tag/v0.10.2",children:"0.10.2"})," \u2022 June 2024"]}),"\n",(0,t.jsx)(e.h3,{id:"animation-chaining",children:(0,t.jsx)(e.a,{href:"animations#chaining-animations",children:"Animation Chaining"})}),"\n",(0,t.jsxs)(e.p,{children:["Animations can now be chained within an animation block using the new ",(0,t.jsx)(e.code,{children:"then"}),' method. This makes it easier to have sequential animations and avoids the need to explicitly track secondary animations for cancellation, since these are tied to their "parent" animation.']}),"\n",(0,t.jsx)(s.T,{functionName:"animationChaining",height:"400"}),"\n",(0,t.jsx)(d.v,{children:k.A}),"\n",(0,t.jsx)(e.h3,{id:"desktop-accessibility",children:"Desktop Accessibility"}),"\n",(0,t.jsxs)(e.p,{children:["Doodle's web apps have had accessibility support for some time. Now those capabilities are available for desktop apps as well. You simply include the ",(0,t.jsx)(p.F.AccessibilityModuleDesktop,{})," in your app and follow the ",(0,t.jsx)(e.a,{href:"accessibility",children:"guidelines"})," of how to add roles, labels, etc. to your Views."]}),"\n",(0,t.jsx)(e.h3,{id:"spinbutton-accessibility",children:"SpinButton Accessibility"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.a,{href:"ui_components/overview#spinbutton",children:"SpinButton"}),"s now use the new ",(0,t.jsx)(p.F.SpinButtonRole,{})," that allows assistive tools to better read them. This role exposes the currently selected value based on a new ",(0,t.jsx)(e.code,{children:"valueAccessibilityLabeler"})," function that converts the value to a ",(0,t.jsx)(e.code,{children:"String"}),"."]}),"\n",(0,t.jsxs)(e.h3,{id:"improved-sliders",children:["Improved ",(0,t.jsx)(e.a,{href:"ui_components/overview#slider",children:"Sliders"})]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Arbitrary Types"})}),"\n",(0,t.jsxs)(e.p,{children:["Sliders can now represent values of any ",(0,t.jsx)(e.code,{children:"Comparable"})," type ",(0,t.jsx)(e.code,{children:"T"})," between two ",(0,t.jsx)(e.code,{children:"start"})," and ",(0,t.jsx)(e.code,{children:"end"})," values. This is possible for ",(0,t.jsx)(e.code,{children:"T"}),"s that have some interpolation between a ",(0,t.jsx)(e.code,{children:"start"})," and ",(0,t.jsx)(e.code,{children:"end"})," based on some value between ",(0,t.jsx)(e.code,{children:"0"})," and ",(0,t.jsx)(e.code,{children:"1"}),". This is done via a new ",(0,t.jsx)(e.code,{children:"TypeConverter<T>"})," that defines the interpolation (and its inverse)."]}),"\n",(0,t.jsxs)(e.p,{children:["This means you can now create sliders for numeric types like ",(0,t.jsx)(e.code,{children:"Measure<T>"})," directly and their ",(0,t.jsx)(e.code,{children:"value"})," will be of the right type."]}),"\n",(0,t.jsx)(s.T,{functionName:"velocitySlider",height:"200"}),"\n",(0,t.jsx)(d.v,{children:b}),"\n",(0,t.jsx)(s.T,{functionName:"charSlider",height:"200"}),"\n",(0,t.jsx)(d.v,{children:C}),"\n",(0,t.jsxs)(e.p,{children:["You can also create Sliders for any type ",(0,t.jsx)(e.code,{children:"T"}),", as long as it is ",(0,t.jsx)(e.code,{children:"Comparable"})," and you can create an ",(0,t.jsx)(e.code,{children:"Interpolator"})," for it."]}),"\n",(0,t.jsx)(d.v,{children:j}),"\n",(0,t.jsx)(e.p,{children:"These, more flexible Sliders can also be used in forms as expected."}),"\n",(0,t.jsx)(d.v,{children:S}),"\n",(0,t.jsx)(e.admonition,{type:"tip",children:(0,t.jsx)(e.p,{children:"This change applies to range, circular and circular-range sliders as well."})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Non-linearity"})}),"\n",(0,t.jsx)(e.p,{children:"Sliders are linear by default, which means a change in their position translates to a linear change in their value. There are cases however, when it makes sense to have a slider's value change in a non-linear way. You can do this by providing a function that maps values between the slider's input and output spaces. These values are all within the [0-1] domain, and work very similarly to easing functions used for animations. The big difference is they have two forms: f(x) and f^-1(x)."}),"\n",(0,t.jsx)(e.p,{children:"This examples shows two sliders that control the rectangle's opacity. One uses a logarithmic function while the other is the typical linear slider. Notice the difference in how quickly the opacity changes in the beginning when adjusting the logarithmic slider."}),"\n",(0,t.jsxs)(r.A,{children:[(0,t.jsx)(l.A,{value:"Non-linearity",children:(0,t.jsx)(s.T,{functionName:"nonLinearSlider",height:"350"})}),(0,t.jsx)(l.A,{value:"Usage",children:(0,t.jsx)(d.v,{children:x.A})})]}),"\n",(0,t.jsx)(e.admonition,{type:"tip",children:(0,t.jsx)(e.p,{children:"All slider types support custom functions to make them non-linear."})}),"\n",(0,t.jsxs)(e.h2,{id:"0101--may-2024",children:[(0,t.jsx)(e.a,{href:"https://github.com/nacular/doodle/releases/tag/v0.10.1",children:"0.10.1"})," \u2022 May 2024"]}),"\n",(0,t.jsxs)(e.p,{children:["This version is mostly focused on bug fixes, but it also includes a new ",(0,t.jsx)(e.code,{children:"Paint"})," type."]}),"\n",(0,t.jsx)(e.h3,{id:"sweep-gradient-paint",children:"Sweep Gradient Paint"}),"\n",(0,t.jsxs)(e.p,{children:["You can now render content using the new ",(0,t.jsx)(p.F.SweepGradientPaint,{}),". This paint creates a smooth gradient between colors around a center point. It is a great match for radial progress indicators."]}),"\n",(0,t.jsx)(s.T,{functionName:"sweepGradientPaint",height:"300"}),"\n",(0,t.jsx)(d.v,{children:y.A}),"\n",(0,t.jsx)(e.p,{children:"This new paint makes it easy to create gradient controls like this simple progress indicator."}),"\n",(0,t.jsxs)(r.A,{children:[(0,t.jsx)(l.A,{value:"Example",children:(0,t.jsx)(s.T,{functionName:"sweepGradientProgress",height:"300"})}),(0,t.jsx)(l.A,{value:"Code",children:(0,t.jsx)(d.v,{children:f})})]}),"\n",(0,t.jsx)(e.admonition,{type:"tip",children:(0,t.jsxs)(e.p,{children:["You can also use this paint with circular ",(0,t.jsx)(e.a,{href:"ui_components/overview#progressbar",children:"ProgressIndicator"})," and ",(0,t.jsx)(e.a,{href:"ui_components/overview#circularslider",children:"CircularRangeSlider"})," via ",(0,t.jsx)(p.F.BasicCircularProgressIndicatorBehavior,{})," and ",(0,t.jsx)(p.F.BasicCircularRangeSliderBehavior,{})," respectively."]})}),"\n",(0,t.jsxs)(e.h2,{id:"0100--feb-2024",children:[(0,t.jsx)(e.a,{href:"https://github.com/nacular/doodle/releases/tag/v0.10.0",children:"0.10.0"})," \u2022 Feb 2024"]}),"\n",(0,t.jsx)(e.p,{children:"The latest version of Doodle brings lots of important updates, especially in terms of better platform support for both Browser and Desktop. Some of the key highlights include:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"New ability to host embed arbitrary HTML elements as Views on Web"}),"\n",(0,t.jsx)(e.li,{children:"WASM JS support"}),"\n",(0,t.jsx)(e.li,{children:"Multiple windows in Desktop apps"}),"\n",(0,t.jsx)(e.li,{children:"OS menu bars in Desktop"}),"\n",(0,t.jsx)(e.li,{children:"More native context menus in Desktop apps"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"host-arbitrary-html-elements-browser",children:"Host arbitrary HTML elements (Browser)"}),"\n",(0,t.jsx)(e.p,{children:"You can now embed any HTML element into your app as a View. This means Doodle apps can now host React and other web components and interop with a much larger part of the Web ecosystem out of the box!"}),"\n",(0,t.jsx)(c.Z,{height:"400"}),"\n",(0,t.jsxs)(r.A,{children:[(0,t.jsx)(l.A,{value:"App",children:(0,t.jsx)(d.v,{children:g.A})}),(0,t.jsx)(l.A,{value:"Example Launcher",children:(0,t.jsx)(d.v,{children:w.A})})]}),"\n",(0,t.jsx)(e.admonition,{type:"info",children:(0,t.jsxs)(e.p,{children:["This app embeds a ",(0,t.jsx)(e.a,{href:"https://projects.wojtekmaj.pl/react-calendar/",children:"react-calendar"}),"."]})}),"\n",(0,t.jsx)(e.h3,{id:"wasm-js-browser",children:"WASM JS (Browser)"}),"\n",(0,t.jsxs)(e.p,{children:["Doodle now supports the ",(0,t.jsx)(e.a,{href:"/docs/installation",children:"WasmJS"})," build target. This means apps can also target WebAssembly for the Browser. The APIs/features for this new target are identical as those for the ",(0,t.jsx)(e.code,{children:"js"})," target; which means code can be shared between apps targeting both. The only difference is that the ",(0,t.jsx)(e.code,{children:"application"})," launchers need to be called from separate source sets (i.e. ",(0,t.jsx)(e.code,{children:"jsMain"})," vs ",(0,t.jsx)(e.code,{children:"wasmJsMain"}),")."]}),"\n",(0,t.jsx)(e.h3,{id:"multi-window-apps-desktop",children:"Multi-window apps (Desktop)"}),"\n",(0,t.jsxs)(e.p,{children:["Apps for Desktop can now create/manage multiple windows using the new ",(0,t.jsx)(e.code,{children:"WindowGroup"})," interface. Simply inject it into your app to get started. The API provides access to an app's ",(0,t.jsx)(e.code,{children:"main"})," window as well as methods for creating new windows. Single window apps continue to work as they did before. That is, an app that injects the ",(0,t.jsx)(e.code,{children:"Display"})," will receive the ",(0,t.jsx)(e.code,{children:"main"})," window display and can manipulate it as before. But apps that want to manage their window(s) will need to inject this new type."]}),"\n",(0,t.jsx)(d.v,{children:u.A}),"\n",(0,t.jsx)(e.admonition,{type:"tip",children:(0,t.jsxs)(e.p,{children:["There's no need to inject ",(0,t.jsx)(e.code,{children:"Display"})," if you already inject ",(0,t.jsx)(e.code,{children:"WindowGroup"}),". That's because the injected ",(0,t.jsx)(e.code,{children:"Display"})," is equivalent to ",(0,t.jsx)(e.code,{children:"windowGroup.main.display"})]})}),"\n",(0,t.jsx)(e.h3,{id:"native-window-menus-desktop",children:"Native window menus (Desktop)"}),"\n",(0,t.jsx)(e.p,{children:"Apps can now set up native menus for their windows. This looks a lot like working with the existing menu APIs, but it results in changes to the OS window decoration. These menus are just as interactive as the in-app ones as well, meaning they trigger events when the user interacts with them."}),"\n",(0,t.jsx)(d.v,{children:m.A}),"\n",(0,t.jsx)(e.h3,{id:"native-context-menus",children:"Native context menus"}),"\n",(0,t.jsx)(e.p,{children:"Apps can now set up native context/popup menus for their windows. The API is very similar to native menus."}),"\n",(0,t.jsx)(d.v,{children:h.A}),"\n",(0,t.jsx)(e.h3,{id:"key-event-filters-and-bubbling-all-platforms",children:"Key event filters and bubbling (All Platforms)"}),"\n",(0,t.jsxs)(e.p,{children:['Key events now "sink" and "bubble" like pointer events. This means ancestor Views can intercept (and veto) them before they are delivered to their target (the focused View). They also bubble up to ancestors after being delivered to the target if they are not consumed. The notifications for the first phase happen via a new ',(0,t.jsx)(p.F.view.keyFilter,{})," property, while the bubbling phase is notified via the existing ",(0,t.jsx)(p.F.view.keyChanged,{})," property."]}),"\n",(0,t.jsxs)(e.p,{children:["This change makes it much easier to create Views like the following; which intercepts the ",(0,t.jsx)(e.code,{children:"ENTER"})," key to press the submit button."]}),"\n",(0,t.jsx)(s.T,{functionName:"enterKeyIntercept",height:"300"}),"\n",(0,t.jsx)(d.v,{children:v})]})}function N(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(z,{...n})}):z(n)}function E(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}},4240:(n,e,o)=>{o.d(e,{A:()=>i});const i='package io.nacular.doodle.docs.apps\n\nimport io.nacular.doodle.HtmlElementViewFactory\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.controls.text.Label\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.docs.utils.DateRangeSelectionModel\nimport io.nacular.doodle.docs.utils.HorizontalCalendar\nimport io.nacular.doodle.docs.utils.ShadowCard\nimport io.nacular.doodle.drawing.Font\nimport io.nacular.doodle.geometry.PathMetrics\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.theme.Theme\nimport io.nacular.doodle.theme.ThemeManager\nimport kotlinx.datetime.DatePeriod\nimport kotlinx.datetime.LocalDate\nimport kotlinx.datetime.plus\nimport org.w3c.dom.HTMLElement\n\nclass ReactCalendarApp(\n    display        : Display,\n    font           : Font,\n    today          : LocalDate,\n    animate        : Animator,\n    pathMetrics    : PathMetrics,\n    themeManager   : ThemeManager,\n    theme          : Theme,\n    htmlElementView: HtmlElementViewFactory,\n    reactCalendar  : HTMLElement,\n    appHeight      : (Double) -> Unit\n): Application {\n\n    private val doodleCalendar = HorizontalCalendar(\n        today          = today,\n        animate        = animate,\n        pathMetrics    = pathMetrics,\n        startDate      = today,\n        endDate        = today + DatePeriod(years = 10),\n        selectionModel = DateRangeSelectionModel()\n    ).apply {\n        this.font = font\n    }\n\n    init {\n        themeManager.selected = theme\n\n//sampleStart\n\n        display += Label("Doodle").apply { this.font = font }\n        display += Label("React" ).apply { this.font = font }\n        display += ShadowCard(doodleCalendar)\n        display += htmlElementView(element = reactCalendar)\n\n//sampleEnd\n\n        val spacing = 20\n\n        display.children.last().boundsChanged += { _,_,new ->\n            // signal to outer docs about height of the app\n            appHeight(display.children.maxOf { it.bounds.bottom } + spacing)\n        }\n\n        display.layout = constrain(\n            display.children[0],\n            display.children[1],\n            display.children[2],\n            display.children[3]\n        ) { doodleLabel, reactLabel, doodle, react ->\n\n            doodle.top          eq doodleLabel.bottom + spacing\n            doodle.height       eq 280\n\n            react.height        eq doodle.height\n\n            doodleLabel.top     eq spacing\n            doodleLabel.centerX eq doodle.centerX\n            doodleLabel.size.preserve\n\n            reactLabel.centerX  eq react.centerX\n            reactLabel.size.preserve\n\n            when {\n                parent.width.readOnly > 800 -> {\n                    doodle.width    eq (parent.width - 3 * spacing) / 2\n                    doodle.right    eq parent.centerX - spacing / 2\n                    react.top       eq doodle.top\n                    react.width     eq doodle.width\n                    react.left      eq doodle.right + spacing\n                    reactLabel.top  eq doodleLabel.top\n                }\n                else -> {\n                    doodle.left     eq spacing\n                    doodle.right    eq parent.right - spacing\n                    react.top       eq reactLabel.bottom + spacing\n                    react.left      eq spacing\n                    react.right     eq parent.right - spacing\n                    reactLabel.top  eq doodle.bottom + spacing\n                }\n            }\n        }\n    }\n\n    override fun shutdown() {\n        // no-op\n    }\n}'},6990:(n,e,o)=>{o.d(e,{A:()=>i});const i='package display\n\nimport io.nacular.doodle.controls.popupmenu.MenuBehavior.ItemInfo\nimport io.nacular.doodle.core.Icon\nimport io.nacular.doodle.core.Window\nimport io.nacular.doodle.geometry.Point\n\nfun contextMenu(window: Window, icon1: Icon<ItemInfo>, icon2: Icon<ItemInfo>) {\n//sampleStart\n    window.popupMenu(at = Point()) {\n        action("Do action 2", icon1) { /*..*/ }\n        menu("Sub menu") {\n            action("Do action sub", icon = icon2) { /*..*/ }\n            separator()\n            prompt("Some Prompt sub") { /*..*/ }\n        }\n        separator()\n        prompt("Some Prompt") { /*..*/ }\n    }\n//sampleEnd\n}'},7045:(n,e,o)=>{o.d(e,{Z:()=>d});var i=o(6540),t=o(3387),a=o.n(t),r=o(7528),l=o(8596),s=(o(7957),o(4848));class d extends i.Component{constructor(n){super(n),n.args&&(this.args=JSON.parse(n.args)),this.height=n.height,this.functionName="reactComponent",this.ref=i.createRef()}componentDidMount(){let n=this.ref.current.children[1];this.ref.current.removeChild(this.ref.current.children[1]),this.app=a()[this.functionName](this.ref.current.children[0],n)}componentWillUnmount(){this.app}render(){return(0,s.jsxs)("div",{className:r.A.doodle,ref:this.ref,children:[(0,s.jsx)("div",{style:{position:"relative",height:this.height+"px"}}),(0,s.jsx)(l.Ay,{})]})}}},7157:(n,e,o)=>{o.d(e,{A:()=>i});const i='package io.nacular.doodle.docs.apps\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.controls.form.Form\nimport io.nacular.doodle.controls.form.labeled\nimport io.nacular.doodle.controls.form.spinButton\nimport io.nacular.doodle.controls.form.textField\nimport io.nacular.doodle.core.Behavior\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.docs.utils.BlueColor\nimport io.nacular.doodle.docs.utils.colorStrip\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.Color.Companion.Blue\nimport io.nacular.doodle.drawing.Color.Companion.Green\nimport io.nacular.doodle.drawing.Color.Companion.Lightgray\nimport io.nacular.doodle.drawing.Color.Companion.Red\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.drawing.lighter\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.geometry.Size.Companion.Empty\nimport io.nacular.doodle.layout.Insets\nimport io.nacular.doodle.layout.constraints.Strength.Companion.Strong\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.theme.Theme\nimport io.nacular.doodle.theme.ThemeManager\nimport io.nacular.doodle.utils.Direction.East\nimport io.nacular.doodle.utils.Direction.West\nimport io.nacular.doodle.utils.Resizer\nimport kotlin.Double.Companion.POSITIVE_INFINITY\n\nclass FormLayoutApp(display: Display, themeManager: ThemeManager, theme: Theme): Application {\n    init {\n        themeManager.selected = theme\n\n//sampleStart\n        val form = Form { this (\n            "Bob" to labeled("Name" ) { textField (                                  ) },\n            21    to labeled("Age"  ) { spinButton(1..120                            ) },\n            Green to labeled("Color") { colorStrip(Red, Green, Blue, BlueColor, Black) },\n\n            // define constraint layout for form with fields in declaration order\n            layout = { name, age, color ->\n                name.top      eq parent.insets.top\n                name.left     eq parent.insets.left\n                name.right    eq age.left - 12 strength Strong\n                name.height   eq name.idealHeight\n\n                age.top       eq name.top\n                age.width     eq 80\n                age.right     eq parent.right - parent.insets.right\n                age.height    eq age.idealHeight\n\n                color.top     eq name.bottom + 12\n                color.left    eq name.top\n                color.right   eq age.right strength Strong\n                color.height  eq color.preferredSize(\n                    min = Empty,\n                    max = Size(parent.width.readOnly, POSITIVE_INFINITY)\n                ).height\n\n                parent.bottom eq color.bottom + parent.insets.bottom\n            },\n\n            onInvalid = {}\n\n        ) { name: String, color: Int, age: Color ->\n            // ...\n        } }\n//sampleEnd\n\n        form.apply {\n            insets    = Insets(12.0)\n            focusable = false\n            behavior  = object: Behavior<Form> {\n                override fun render(view: Form, canvas: Canvas) {\n                    canvas.rect(view.bounds.atOrigin, Lightgray.lighter(0.75f).paint)\n                }\n            }\n\n            suggestWidth(300.0)\n\n            Resizer(this, movable = false).apply { directions = setOf(East, West) }\n        }\n\n        display += form\n\n        display.layout = constrain(form) {\n            it.center eq parent.center\n            it.height eq it.idealHeight\n        }\n\n        display.fill(White.paint)\n    }\n\n    override fun shutdown() {}\n}'},8144:(n,e,o)=>{o.d(e,{A:()=>i});const i="package rendering\n\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.Color\nimport io.nacular.doodle.drawing.GradientPaint.Stop\nimport io.nacular.doodle.drawing.SweepGradientPaint\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.measured.units.Angle\nimport io.nacular.measured.units.Measure\n\n/**\n * Example showing how to use [SweepGradientPaint]s.\n */\nfun sweepGradientPaint(color1: Color, color2: Color, center: Point, rotation: Measure<Angle>) {\n//sampleStart\n    view {\n        render = {\n            // Simple version with 2 colors\n            rect(bounds.atOrigin, SweepGradientPaint(\n                color1,\n                color2,\n                center,\n                rotation\n            ))\n        }\n    }\n\n    view {\n        render = {\n            // Also able to use a list of color stops\n            rect(\n                bounds.atOrigin, SweepGradientPaint(\n                    listOf(\n                        Stop(color1, 0f),\n                        Stop(color1, 1f / 3),\n                        // ...\n                    ),\n                    center,\n                    rotation\n                )\n            )\n        }\n    }\n//sampleEnd\n}"},8726:(n,e,o)=>{o.d(e,{A:()=>i});const i='import io.nacular.doodle.controls.text.Label\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.layout.constraints.fill\n\nfun labelFitText() {\n//sampleStart\n    view {\n        + Label("Hello") // Label fits its text by default\n\n        layout = constrain(children.first(), fill) // \u2705 works as expected\n    }\n//sampleEnd\n}'},8832:(n,e,o)=>{o.d(e,{A:()=>i});const i='package display\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.core.WindowGroup\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.layout.constraints.fill\n\n//sampleStart\nclass MyCoolApp(windows: WindowGroup): Application {\n    init {\n        // main window\'s display, same as if Display were injected\n        windows.main.apply {\n            title = "Main Window"\n\n            // manipulate main window\'s display\n            display += view {}\n        }\n\n        // create a new window\n        windows {\n            title                = "A New Window!"\n            size                 = Size(500)\n            enabled              = false\n            resizable            = false\n            triesToAlwaysBeOnTop = true\n\n            // manipulate the new window\'s display\n            display += view {}\n            display.layout = constrain(display.first(), fill)\n\n            closed += {\n                // handle window close\n            }\n        }\n    }\n\n    override fun shutdown() {}\n}\n//sampleEnd'},8968:(n,e,o)=>{o.d(e,{A:()=>i});const i="package io.nacular.doodle.docs.apps\n\nimport io.nacular.doodle.animation.Animation\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.transition.easeOutBounce\nimport io.nacular.doodle.animation.tween\nimport io.nacular.doodle.animation.tweenDouble\nimport io.nacular.doodle.animation.tweenPoint\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.height\nimport io.nacular.doodle.core.renderProperty\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.core.width\nimport io.nacular.doodle.docs.utils.controlBackgroundColor\nimport io.nacular.doodle.drawing.AffineTransform.Companion.Identity\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.Color.Companion.Lightgray\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.drawing.opacity\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.event.PointerListener.Companion.on\nimport io.nacular.doodle.geometry.Circle\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.geometry.Vector3D\nimport io.nacular.doodle.geometry.circumference\nimport io.nacular.doodle.geometry.inset\nimport io.nacular.doodle.geometry.lineTo\nimport io.nacular.doodle.geometry.path\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.layout.constraints.fill\nimport io.nacular.doodle.utils.autoCanceling\nimport io.nacular.measured.units.Angle.Companion.acos\nimport io.nacular.measured.units.Angle.Companion.degrees\nimport io.nacular.measured.units.Time.Companion.seconds\nimport io.nacular.measured.units.times\nimport kotlin.math.PI\nimport kotlin.math.cos\nimport kotlin.math.sqrt\n\nclass AnimationChainingApp(private val display: Display, private val animate: Animator): Application {\n    private class Wheel: View() {\n        val radius        get() =  circle.radius + thickness / 2\n        val circumference get() =  2 * PI * radius\n        var bottom        get() = position + Point(radius, 2 * radius); set(new) {\n            suggestPosition(new - Point(radius, 2 * radius))\n        }\n        var rotation           by renderProperty(0 * degrees)\n\n        private val thickness        =  20.0\n        private val dashLength get() =  circle.circumference / 8\n        private val circle     get() = Circle(\n            center = Point(width, height) / 2.0,\n            radius = minOf(width/2, height/2) - thickness / 2\n        )\n\n        override fun contains(point: Point) = false\n\n        override fun render(canvas: Canvas) {\n            val c = circle\n            val d = dashLength\n\n            canvas.circle(c.inset(-thickness / 2 + 0.5), Stroke(Lightgray))\n            canvas.circle(c.inset( thickness / 2      ), Stroke(Lightgray))\n\n            canvas.rotate(around = Point(radius, radius), by = rotation) {\n            circle(\n                c,\n                Stroke(\n                    color     = Color.Blue,\n                    dashes    = doubleArrayOf(d, d),\n                    thickness = thickness,\n                )\n            )}\n        }\n    }\n\n    private var animation: Animation<*>? by autoCanceling()\n\n    private val wheel        = Wheel().apply { suggestSize(Size(100)) }\n    private var rampBounds   = calculateRampBounds()\n    private val rollBounce   = easeOutBounce(0.15f)\n    private val fallDuration = 1 * seconds\n    private val rollDuration = 3 * seconds\n\n    init {\n        display += view {\n            + wheel\n\n            render = {\n                outerShadow(\n                    color      = Black opacity 0.05f,\n                    vertical   = -10.0,\n                    blurRadius =  10.0\n                ) {\n                    path(\n                        path(0.0, rampBounds.y)\n                            .lineTo(rampBounds.position                )\n                            .lineTo(rampBounds.right, rampBounds.bottom)\n                            .lineTo(0.0,              rampBounds.bottom)\n                            .finish(),\n                        White.paint\n                    )\n                }\n            }\n\n            pointerChanged += on(\n                entered = { startAnimation() },\n                pressed = { startAnimation() }\n            )\n\n            wheel.boundsChanged += { _,old,new ->\n                if (old.size != new.size) {\n                    rampBounds = calculateRampBounds()\n                    animation?.cancel()\n                    resetWheel()\n                    rerender()\n                }\n            }\n        }\n\n        display.fill(controlBackgroundColor.paint)\n\n        display.layout       = constrain(display.first(), fill)\n        display.sizeChanged += { _,_,_ ->\n            rampBounds = calculateRampBounds()\n            animation?.cancel()\n            resetWheel()\n        }\n    }\n\n    private fun resetWheel() {\n        wheel.bottom    = Point(wheel.radius, 2 * wheel.radius)\n        wheel.rotation  = 0 * degrees\n        wheel.transform = Identity\n    }\n\n    private fun startAnimation() {\n        resetWheel()\n\n        animation = animate {\n            val wheelBottomStart        = Point(wheel.radius, 2 * wheel.radius)\n            val rampLength              = sqrt(rampBounds.width * rampBounds.width + rampBounds.height * rampBounds.height)\n            val radiusLengthRatio       = wheel.radius / rampLength\n            val bottomYOffsetFromCenter = rampBounds.width  * radiusLengthRatio\n            val bottomXOffsetFromCenter = rampBounds.height * radiusLengthRatio\n            val bottomXOffsetWall       = wheel.radius + bottomXOffsetFromCenter\n            val bottomYOffsetFloor      = bottomXOffsetWall * rampBounds.height / rampBounds.width\n            val tippingPoint            = Identity.rotate(\n                around = Point(wheel.radius, rampBounds.y),\n                by     = acos(rampBounds.width / rampLength)\n            )(Point(wheel.radius, rampBounds.y - wheel.radius))\n\n            val wheelBottomEnd          = Point(\n                rampBounds.right  - bottomXOffsetWall  + bottomXOffsetFromCenter,\n                rampBounds.bottom - bottomYOffsetFloor - bottomYOffsetFromCenter + wheel.radius\n            )\n            val rollLength              = wheelBottomEnd distanceFrom wheelBottomStart\n            val rotations               = rollLength / wheel.circumference\n\n//sampleStart\n            wheelBottomStart to Point(wheel.radius, rampBounds.y) using (tweenPoint(easeOutBounce, fallDuration)) {\n                // (1) Ball falls and bounces\n                wheel.bottom = it\n            } then {\n                // (2) Then it slides down the hill and bounces off the wall, by animating x and deriving y\n                wheel.bottom.x to rampBounds.width using (tweenDouble(rollBounce, rollDuration)) { x ->\n                    wheel.bottom = Point(x, wheelBottomY(x, tippingPoint))\n                }\n\n                // (2) While rolling at the same time\n                0 * degrees to 360 * degrees * rotations using (tween(degrees, rollBounce, rollDuration)) {\n                    wheel.rotation = it\n                }\n            }\n//sampleEnd\n        }\n    }\n\n    /**\n     * Calculate the ball's bottom position to keep it on the ramp as it moves horizontally.\n     *\n     * The first phase of the move is the portion where the ball is rolling over the edge.\n     * Then it transitions to normal linear motion.\n     */\n    private fun wheelBottomY(centerX: Double, tippingPoint: Vector3D) = when {\n        centerX < tippingPoint.x -> rampBounds.y - wheel.radius * cos((centerX - wheel.radius) / wheel.radius)\n        else                     -> tippingPoint.y + (centerX - tippingPoint.x) * rampBounds.height / rampBounds.width\n    } + wheel.radius\n\n    private fun calculateRampBounds() = Rectangle(\n        x      = wheel.radius,\n        y      = display.height / 2,\n        width  = display.width - wheel.radius,\n        height = display.height / 2\n    )\n\n    override fun shutdown() {\n        animation?.cancel()\n    }\n}"},9491:(n,e,o)=>{o.d(e,{A:()=>i});const i="package controls\n\nimport io.nacular.doodle.controls.range.InvertibleFunction\nimport io.nacular.doodle.controls.range.Slider\nimport kotlin.math.log\nimport kotlin.math.pow\n\n//sampleStart\n/**\n * Logarithmic function and inverse https://www.desmos.com/calculator/qq59ey0bub\n */\nprivate object LogFunction: InvertibleFunction {\n    override fun invoke (value: Float) = log((10f - 1) * value + 1, 10f)\n    override fun inverse(value: Float) = (10f.pow(value) - 1)/(10 - 1)\n}\n\nval logarithmicSlider = Slider(0.0 .. 1.0, function = LogFunction)\n//sampleEnd"}}]);